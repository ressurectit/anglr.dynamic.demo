{"version":3,"file":"9494.chunk.d2dc745c1c4130478127.js","mappings":"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","sources":["webpack://ng-universal-demo/../../../../packages/core/src/reflection/reflection_capabilities.ts","webpack://ng-universal-demo/../../../../packages/core/src/di/metadata_attr.ts","webpack://ng-universal-demo/../../../../packages/core/src/di/jit/util.ts","webpack://ng-universal-demo/../../../../packages/core/src/linker/ng_module_registration.ts","webpack://ng-universal-demo/../../../../packages/core/src/render3/features/host_directives_feature.ts","webpack://ng-universal-demo/../../../../packages/core/src/render3/features/copy_definition_feature.ts","webpack://ng-universal-demo/../../../../packages/core/src/render3/instructions/property_interpolation.ts","webpack://ng-universal-demo/../../../../packages/core/src/render3/interfaces/i18n.ts","webpack://ng-universal-demo/../../../../packages/core/src/render3/node_manipulation_i18n.ts","webpack://ng-universal-demo/../../../../packages/core/src/render3/i18n/i18n_insert_before_index.ts","webpack://ng-universal-demo/../../../../packages/core/src/render3/i18n/i18n_util.ts","webpack://ng-universal-demo/../../../../packages/core/src/render3/i18n/i18n_apply.ts","webpack://ng-universal-demo/../../../../packages/core/src/render3/instructions/i18n_icu_container_visitor.ts","webpack://ng-universal-demo/../../../../packages/core/src/render3/i18n/i18n_parse.ts","webpack://ng-universal-demo/../../../../packages/core/src/render3/i18n/i18n_postprocess.ts","webpack://ng-universal-demo/../../../../packages/core/src/render3/instructions/i18n.ts","webpack://ng-universal-demo/../../../../packages/core/src/render3/jit/environment.ts","webpack://ng-universal-demo/../../../../packages/core/src/render3/instructions/attribute_interpolation.ts","webpack://ng-universal-demo/../../../../packages/core/src/render3/instructions/style_map_interpolation.ts","webpack://ng-universal-demo/../../../../packages/core/src/render3/instructions/style_prop_interpolation.ts","webpack://ng-universal-demo/../../../../packages/core/src/sanitization/iframe_attrs_validation.ts","webpack://ng-universal-demo/../../../../packages/core/src/render3/jit/util.ts","webpack://ng-universal-demo/../../../../packages/core/src/render3/jit/module.ts","webpack://ng-universal-demo/../../../../packages/core/src/render3/jit/directive.ts","webpack://ng-universal-demo/../../../../packages/core/src/render3/jit/pipe.ts","webpack://ng-universal-demo/../../../../packages/core/src/metadata/directives.ts","webpack://ng-universal-demo/../../../../packages/core/src/render3/instructions/class_map_interpolation.ts"],"sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {isType, Type} from '../interface/type';\nimport {newArray} from '../util/array_utils';\nimport {ANNOTATIONS, PARAMETERS, PROP_METADATA} from '../util/decorators';\nimport {global} from '../util/global';\n\nimport {PlatformReflectionCapabilities} from './platform_reflection_capabilities';\n\n\n\n/*\n * #########################\n * Attention: These Regular expressions have to hold even if the code is minified!\n * ##########################\n */\n\n/**\n * Regular expression that detects pass-through constructors for ES5 output. This Regex\n * intends to capture the common delegation pattern emitted by TypeScript and Babel. Also\n * it intends to capture the pattern where existing constructors have been downleveled from\n * ES2015 to ES5 using TypeScript w/ downlevel iteration. e.g.\n *\n * ```\n *   function MyClass() {\n *     var _this = _super.apply(this, arguments) || this;\n * ```\n *\n * downleveled to ES5 with `downlevelIteration` for TypeScript < 4.2:\n * ```\n *   function MyClass() {\n *     var _this = _super.apply(this, __spread(arguments)) || this;\n * ```\n *\n * or downleveled to ES5 with `downlevelIteration` for TypeScript >= 4.2:\n * ```\n *   function MyClass() {\n *     var _this = _super.apply(this, __spreadArray([], __read(arguments), false)) || this;\n * ```\n *\n * More details can be found in: https://github.com/angular/angular/issues/38453.\n */\nexport const ES5_DELEGATE_CTOR =\n    /^function\\s+\\S+\\(\\)\\s*{[\\s\\S]+\\.apply\\(this,\\s*(arguments|(?:[^()]+\\(\\[\\],)?[^()]+\\(arguments\\).*)\\)/;\n/** Regular expression that detects ES2015 classes which extend from other classes. */\nexport const ES2015_INHERITED_CLASS = /^class\\s+[A-Za-z\\d$_]*\\s*extends\\s+[^{]+{/;\n/**\n * Regular expression that detects ES2015 classes which extend from other classes and\n * have an explicit constructor defined.\n */\nexport const ES2015_INHERITED_CLASS_WITH_CTOR =\n    /^class\\s+[A-Za-z\\d$_]*\\s*extends\\s+[^{]+{[\\s\\S]*constructor\\s*\\(/;\n/**\n * Regular expression that detects ES2015 classes which extend from other classes\n * and inherit a constructor.\n */\nexport const ES2015_INHERITED_CLASS_WITH_DELEGATE_CTOR =\n    /^class\\s+[A-Za-z\\d$_]*\\s*extends\\s+[^{]+{[\\s\\S]*constructor\\s*\\(\\)\\s*{[^}]*super\\(\\.\\.\\.arguments\\)/;\n\n/**\n * Determine whether a stringified type is a class which delegates its constructor\n * to its parent.\n *\n * This is not trivial since compiled code can actually contain a constructor function\n * even if the original source code did not. For instance, when the child class contains\n * an initialized instance property.\n */\nexport function isDelegateCtor(typeStr: string): boolean {\n  return ES5_DELEGATE_CTOR.test(typeStr) ||\n      ES2015_INHERITED_CLASS_WITH_DELEGATE_CTOR.test(typeStr) ||\n      (ES2015_INHERITED_CLASS.test(typeStr) && !ES2015_INHERITED_CLASS_WITH_CTOR.test(typeStr));\n}\n\nexport class ReflectionCapabilities implements PlatformReflectionCapabilities {\n  private _reflect: any;\n\n  constructor(reflect?: any) {\n    this._reflect = reflect || global['Reflect'];\n  }\n\n  factory<T>(t: Type<T>): (args: any[]) => T {\n    return (...args: any[]) => new t(...args);\n  }\n\n  /** @internal */\n  _zipTypesAndAnnotations(paramTypes: any[], paramAnnotations: any[]): any[][] {\n    let result: any[][];\n\n    if (typeof paramTypes === 'undefined') {\n      result = newArray(paramAnnotations.length);\n    } else {\n      result = newArray(paramTypes.length);\n    }\n\n    for (let i = 0; i < result.length; i++) {\n      // TS outputs Object for parameters without types, while Traceur omits\n      // the annotations. For now we preserve the Traceur behavior to aid\n      // migration, but this can be revisited.\n      if (typeof paramTypes === 'undefined') {\n        result[i] = [];\n      } else if (paramTypes[i] && paramTypes[i] != Object) {\n        result[i] = [paramTypes[i]];\n      } else {\n        result[i] = [];\n      }\n      if (paramAnnotations && paramAnnotations[i] != null) {\n        result[i] = result[i].concat(paramAnnotations[i]);\n      }\n    }\n    return result;\n  }\n\n  private _ownParameters(type: Type<any>, parentCtor: any): any[][]|null {\n    const typeStr = type.toString();\n    // If we have no decorators, we only have function.length as metadata.\n    // In that case, to detect whether a child class declared an own constructor or not,\n    // we need to look inside of that constructor to check whether it is\n    // just calling the parent.\n    // This also helps to work around for https://github.com/Microsoft/TypeScript/issues/12439\n    // that sets 'design:paramtypes' to []\n    // if a class inherits from another class but has no ctor declared itself.\n    if (isDelegateCtor(typeStr)) {\n      return null;\n    }\n\n    // Prefer the direct API.\n    if ((<any>type).parameters && (<any>type).parameters !== parentCtor.parameters) {\n      return (<any>type).parameters;\n    }\n\n    // API of tsickle for lowering decorators to properties on the class.\n    const tsickleCtorParams = (<any>type).ctorParameters;\n    if (tsickleCtorParams && tsickleCtorParams !== parentCtor.ctorParameters) {\n      // Newer tsickle uses a function closure\n      // Retain the non-function case for compatibility with older tsickle\n      const ctorParameters =\n          typeof tsickleCtorParams === 'function' ? tsickleCtorParams() : tsickleCtorParams;\n      const paramTypes = ctorParameters.map((ctorParam: any) => ctorParam && ctorParam.type);\n      const paramAnnotations = ctorParameters.map(\n          (ctorParam: any) =>\n              ctorParam && convertTsickleDecoratorIntoMetadata(ctorParam.decorators));\n      return this._zipTypesAndAnnotations(paramTypes, paramAnnotations);\n    }\n\n    // API for metadata created by invoking the decorators.\n    const paramAnnotations = type.hasOwnProperty(PARAMETERS) && (type as any)[PARAMETERS];\n    const paramTypes = this._reflect && this._reflect.getOwnMetadata &&\n        this._reflect.getOwnMetadata('design:paramtypes', type);\n    if (paramTypes || paramAnnotations) {\n      return this._zipTypesAndAnnotations(paramTypes, paramAnnotations);\n    }\n\n    // If a class has no decorators, at least create metadata\n    // based on function.length.\n    // Note: We know that this is a real constructor as we checked\n    // the content of the constructor above.\n    return newArray<any[]>(type.length);\n  }\n\n  parameters(type: Type<any>): any[][] {\n    // Note: only report metadata if we have at least one class decorator\n    // to stay in sync with the static reflector.\n    if (!isType(type)) {\n      return [];\n    }\n    const parentCtor = getParentCtor(type);\n    let parameters = this._ownParameters(type, parentCtor);\n    if (!parameters && parentCtor !== Object) {\n      parameters = this.parameters(parentCtor);\n    }\n    return parameters || [];\n  }\n\n  private _ownAnnotations(typeOrFunc: Type<any>, parentCtor: any): any[]|null {\n    // Prefer the direct API.\n    if ((<any>typeOrFunc).annotations && (<any>typeOrFunc).annotations !== parentCtor.annotations) {\n      let annotations = (<any>typeOrFunc).annotations;\n      if (typeof annotations === 'function' && annotations.annotations) {\n        annotations = annotations.annotations;\n      }\n      return annotations;\n    }\n\n    // API of tsickle for lowering decorators to properties on the class.\n    if ((<any>typeOrFunc).decorators && (<any>typeOrFunc).decorators !== parentCtor.decorators) {\n      return convertTsickleDecoratorIntoMetadata((<any>typeOrFunc).decorators);\n    }\n\n    // API for metadata created by invoking the decorators.\n    if (typeOrFunc.hasOwnProperty(ANNOTATIONS)) {\n      return (typeOrFunc as any)[ANNOTATIONS];\n    }\n    return null;\n  }\n\n  annotations(typeOrFunc: Type<any>): any[] {\n    if (!isType(typeOrFunc)) {\n      return [];\n    }\n    const parentCtor = getParentCtor(typeOrFunc);\n    const ownAnnotations = this._ownAnnotations(typeOrFunc, parentCtor) || [];\n    const parentAnnotations = parentCtor !== Object ? this.annotations(parentCtor) : [];\n    return parentAnnotations.concat(ownAnnotations);\n  }\n\n  private _ownPropMetadata(typeOrFunc: any, parentCtor: any): {[key: string]: any[]}|null {\n    // Prefer the direct API.\n    if ((<any>typeOrFunc).propMetadata &&\n        (<any>typeOrFunc).propMetadata !== parentCtor.propMetadata) {\n      let propMetadata = (<any>typeOrFunc).propMetadata;\n      if (typeof propMetadata === 'function' && propMetadata.propMetadata) {\n        propMetadata = propMetadata.propMetadata;\n      }\n      return propMetadata;\n    }\n\n    // API of tsickle for lowering decorators to properties on the class.\n    if ((<any>typeOrFunc).propDecorators &&\n        (<any>typeOrFunc).propDecorators !== parentCtor.propDecorators) {\n      const propDecorators = (<any>typeOrFunc).propDecorators;\n      const propMetadata = <{[key: string]: any[]}>{};\n      Object.keys(propDecorators).forEach(prop => {\n        propMetadata[prop] = convertTsickleDecoratorIntoMetadata(propDecorators[prop]);\n      });\n      return propMetadata;\n    }\n\n    // API for metadata created by invoking the decorators.\n    if (typeOrFunc.hasOwnProperty(PROP_METADATA)) {\n      return (typeOrFunc as any)[PROP_METADATA];\n    }\n    return null;\n  }\n\n  propMetadata(typeOrFunc: any): {[key: string]: any[]} {\n    if (!isType(typeOrFunc)) {\n      return {};\n    }\n    const parentCtor = getParentCtor(typeOrFunc);\n    const propMetadata: {[key: string]: any[]} = {};\n    if (parentCtor !== Object) {\n      const parentPropMetadata = this.propMetadata(parentCtor);\n      Object.keys(parentPropMetadata).forEach((propName) => {\n        propMetadata[propName] = parentPropMetadata[propName];\n      });\n    }\n    const ownPropMetadata = this._ownPropMetadata(typeOrFunc, parentCtor);\n    if (ownPropMetadata) {\n      Object.keys(ownPropMetadata).forEach((propName) => {\n        const decorators: any[] = [];\n        if (propMetadata.hasOwnProperty(propName)) {\n          decorators.push(...propMetadata[propName]);\n        }\n        decorators.push(...ownPropMetadata[propName]);\n        propMetadata[propName] = decorators;\n      });\n    }\n    return propMetadata;\n  }\n\n  ownPropMetadata(typeOrFunc: any): {[key: string]: any[]} {\n    if (!isType(typeOrFunc)) {\n      return {};\n    }\n    return this._ownPropMetadata(typeOrFunc, getParentCtor(typeOrFunc)) || {};\n  }\n\n  hasLifecycleHook(type: any, lcProperty: string): boolean {\n    return type instanceof Type && lcProperty in type.prototype;\n  }\n}\n\nfunction convertTsickleDecoratorIntoMetadata(decoratorInvocations: any[]): any[] {\n  if (!decoratorInvocations) {\n    return [];\n  }\n  return decoratorInvocations.map(decoratorInvocation => {\n    const decoratorType = decoratorInvocation.type;\n    const annotationCls = decoratorType.annotationCls;\n    const annotationArgs = decoratorInvocation.args ? decoratorInvocation.args : [];\n    return new annotationCls(...annotationArgs);\n  });\n}\n\nfunction getParentCtor(ctor: Function): Type<any> {\n  const parentProto = ctor.prototype ? Object.getPrototypeOf(ctor.prototype) : null;\n  const parentCtor = parentProto ? parentProto.constructor : null;\n  // Note: We always use `Object` as the null value\n  // to simplify checking later on.\n  return parentCtor || Object;\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {injectAttribute} from '../render3/instructions/di_attr';\nimport {makeParamDecorator} from '../util/decorators';\n\n\n/**\n * Type of the Attribute decorator / constructor function.\n *\n * @publicApi\n */\nexport interface AttributeDecorator {\n  /**\n   * Parameter decorator for a directive constructor that designates\n   * a host-element attribute whose value is injected as a constant string literal.\n   *\n   * @usageNotes\n   *\n   * Suppose we have an `<input>` element and want to know its `type`.\n   *\n   * ```html\n   * <input type=\"text\">\n   * ```\n   *\n   * The following example uses the decorator to inject the string literal `text` in a directive.\n   *\n   * {@example core/ts/metadata/metadata.ts region='attributeMetadata'}\n   *\n   * The following example uses the decorator in a component constructor.\n   *\n   * {@example core/ts/metadata/metadata.ts region='attributeFactory'}\n   *\n   */\n  (name: string): any;\n  new(name: string): Attribute;\n}\n\n/**\n * Type of the Attribute metadata.\n *\n * @publicApi\n */\nexport interface Attribute {\n  /**\n   * The name of the attribute whose value can be injected.\n   */\n  attributeName: string;\n}\n\n/**\n * Attribute decorator and metadata.\n *\n * @Annotation\n * @publicApi\n */\nexport const Attribute: AttributeDecorator = makeParamDecorator(\n    'Attribute',\n    (attributeName?: string) =>\n        ({attributeName, __NG_ELEMENT_ID__: () => injectAttribute(attributeName!)}));\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {R3DependencyMetadataFacade} from '../../compiler/compiler_facade';\nimport {RuntimeError, RuntimeErrorCode} from '../../errors';\nimport {Type} from '../../interface/type';\nimport {ReflectionCapabilities} from '../../reflection/reflection_capabilities';\nimport {Host, Inject, Optional, Self, SkipSelf} from '../metadata';\nimport {Attribute} from '../metadata_attr';\n\nlet _reflect: ReflectionCapabilities|null = null;\n\nexport function getReflect(): ReflectionCapabilities {\n  return (_reflect = _reflect || new ReflectionCapabilities());\n}\n\nexport function reflectDependencies(type: Type<any>): R3DependencyMetadataFacade[] {\n  return convertDependencies(getReflect().parameters(type));\n}\n\nexport function convertDependencies(deps: any[]): R3DependencyMetadataFacade[] {\n  return deps.map(dep => reflectDependency(dep));\n}\n\nfunction reflectDependency(dep: any|any[]): R3DependencyMetadataFacade {\n  const meta: R3DependencyMetadataFacade = {\n    token: null,\n    attribute: null,\n    host: false,\n    optional: false,\n    self: false,\n    skipSelf: false,\n  };\n\n  if (Array.isArray(dep) && dep.length > 0) {\n    for (let j = 0; j < dep.length; j++) {\n      const param = dep[j];\n      if (param === undefined) {\n        // param may be undefined if type of dep is not set by ngtsc\n        continue;\n      }\n\n      const proto = Object.getPrototypeOf(param);\n\n      if (param instanceof Optional || proto.ngMetadataName === 'Optional') {\n        meta.optional = true;\n      } else if (param instanceof SkipSelf || proto.ngMetadataName === 'SkipSelf') {\n        meta.skipSelf = true;\n      } else if (param instanceof Self || proto.ngMetadataName === 'Self') {\n        meta.self = true;\n      } else if (param instanceof Host || proto.ngMetadataName === 'Host') {\n        meta.host = true;\n      } else if (param instanceof Inject) {\n        meta.token = param.token;\n      } else if (param instanceof Attribute) {\n        if (param.attributeName === undefined) {\n          throw new RuntimeError(\n              RuntimeErrorCode.INVALID_INJECTION_TOKEN,\n              ngDevMode && `Attribute name must be defined.`);\n        }\n        meta.attribute = param.attributeName;\n      } else {\n        meta.token = param;\n      }\n    }\n  } else if (dep === undefined || (Array.isArray(dep) && dep.length === 0)) {\n    meta.token = null;\n  } else {\n    meta.token = dep;\n  }\n  return meta;\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n\nimport {Type} from '../interface/type';\nimport {NgModuleType} from '../metadata/ng_module_def';\nimport {getNgModuleDef} from '../render3/definition';\nimport {stringify} from '../util/stringify';\n\n/**\n * Map of module-id to the corresponding NgModule.\n */\nconst modules = new Map<string, NgModuleType>();\n\n/**\n * Whether to check for duplicate NgModule registrations.\n *\n * This can be disabled for testing.\n */\nlet checkForDuplicateNgModules = true;\n\nfunction assertSameOrNotExisting(id: string, type: Type<any>|null, incoming: Type<any>): void {\n  if (type && type !== incoming && checkForDuplicateNgModules) {\n    throw new Error(\n        `Duplicate module registered for ${id} - ${stringify(type)} vs ${stringify(type.name)}`);\n  }\n}\n\n/**\n * Adds the given NgModule type to Angular's NgModule registry.\n *\n * This is generated as a side-effect of NgModule compilation. Note that the `id` is passed in\n * explicitly and not read from the NgModule definition. This is for two reasons: it avoids a\n * megamorphic read, and in JIT there's a chicken-and-egg problem where the NgModule may not be\n * fully resolved when it's registered.\n *\n * @codeGenApi\n */\nexport function registerNgModuleType(ngModuleType: NgModuleType, id: string): void {\n  const existing = modules.get(id) || null;\n  assertSameOrNotExisting(id, existing, ngModuleType);\n  modules.set(id, ngModuleType);\n}\n\nexport function clearModulesForTest(): void {\n  modules.clear();\n}\n\nexport function getRegisteredNgModuleType(id: string): NgModuleType|undefined {\n  return modules.get(id);\n}\n\n/**\n * Control whether the NgModule registration system enforces that each NgModule type registered has\n * a unique id.\n *\n * This is useful for testing as the NgModule registry cannot be properly reset between tests with\n * Angular's current API.\n */\nexport function setAllowDuplicateNgModuleIdsForTest(allowDuplicates: boolean): void {\n  checkForDuplicateNgModules = !allowDuplicates;\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport {resolveForwardRef} from '../../di';\nimport {RuntimeError, RuntimeErrorCode} from '../../errors';\nimport {Type} from '../../interface/type';\nimport {assertEqual} from '../../util/assert';\nimport {EMPTY_OBJ} from '../../util/empty';\nimport {getComponentDef, getDirectiveDef} from '../definition';\nimport {DirectiveDef, HostDirectiveBindingMap, HostDirectiveDef, HostDirectiveDefs} from '../interfaces/definition';\n\n/** Values that can be used to define a host directive through the `HostDirectivesFeature`. */\ntype HostDirectiveConfig = Type<unknown>|{\n  directive: Type<unknown>;\n  inputs?: string[];\n  outputs?: string[];\n};\n\n/**\n * This feature adds the host directives behavior to a directive definition by patching a\n * function onto it. The expectation is that the runtime will invoke the function during\n * directive matching.\n *\n * For example:\n * ```ts\n * class ComponentWithHostDirective {\n *   static cmp = defineComponent({\n *    type: ComponentWithHostDirective,\n *    features: [HostDirectivesFeature([\n *      SimpleHostDirective,\n *      {directive: AdvancedHostDirective, inputs: ['foo: alias'], outputs: ['bar']},\n *    ])]\n *  });\n * }\n * ```\n *\n * @codeGenApi\n */\nexport function HostDirectivesFeature(rawHostDirectives: HostDirectiveConfig[]|\n                                        (() => HostDirectiveConfig[])) {\n  return (definition: DirectiveDef<unknown>) => {\n    definition.findHostDirectiveDefs = findHostDirectiveDefs;\n    definition.hostDirectives =\n        (Array.isArray(rawHostDirectives) ? rawHostDirectives : rawHostDirectives()).map(dir => {\n          return typeof dir === 'function' ?\n              {directive: resolveForwardRef(dir), inputs: EMPTY_OBJ, outputs: EMPTY_OBJ} :\n              {\n                directive: resolveForwardRef(dir.directive),\n                inputs: bindingArrayToMap(dir.inputs),\n                outputs: bindingArrayToMap(dir.outputs)\n              };\n        });\n  };\n}\n\nfunction findHostDirectiveDefs(\n    currentDef: DirectiveDef<unknown>, matchedDefs: DirectiveDef<unknown>[],\n    hostDirectiveDefs: HostDirectiveDefs): void {\n  if (currentDef.hostDirectives !== null) {\n    for (const hostDirectiveConfig of currentDef.hostDirectives) {\n      const hostDirectiveDef = getDirectiveDef(hostDirectiveConfig.directive)!;\n\n      if (typeof ngDevMode === 'undefined' || ngDevMode) {\n        validateHostDirective(hostDirectiveConfig, hostDirectiveDef, matchedDefs);\n      }\n\n      // We need to patch the `declaredInputs` so that\n      // `ngOnChanges` can map the properties correctly.\n      patchDeclaredInputs(hostDirectiveDef.declaredInputs, hostDirectiveConfig.inputs);\n\n      // Host directives execute before the host so that its host bindings can be overwritten.\n      findHostDirectiveDefs(hostDirectiveDef, matchedDefs, hostDirectiveDefs);\n      hostDirectiveDefs.set(hostDirectiveDef, hostDirectiveConfig);\n      matchedDefs.push(hostDirectiveDef);\n    }\n  }\n}\n\n/**\n * Converts an array in the form of `['publicName', 'alias', 'otherPublicName', 'otherAlias']` into\n * a map in the form of `{publicName: 'alias', otherPublicName: 'otherAlias'}`.\n */\nfunction bindingArrayToMap(bindings: string[]|undefined): HostDirectiveBindingMap {\n  if (bindings === undefined || bindings.length === 0) {\n    return EMPTY_OBJ;\n  }\n\n  const result: HostDirectiveBindingMap = {};\n\n  for (let i = 0; i < bindings.length; i += 2) {\n    result[bindings[i]] = bindings[i + 1];\n  }\n\n  return result;\n}\n\n/**\n * `ngOnChanges` has some leftover legacy ViewEngine behavior where the keys inside the\n * `SimpleChanges` event refer to the *declared* name of the input, not its public name or its\n * minified name. E.g. in `@Input('alias') foo: string`, the name in the `SimpleChanges` object\n * will always be `foo`, and not `alias` or the minified name of `foo` in apps using property\n * minification.\n *\n * This is achieved through the `DirectiveDef.declaredInputs` map that is constructed when the\n * definition is declared. When a property is written to the directive instance, the\n * `NgOnChangesFeature` will try to remap the property name being written to using the\n * `declaredInputs`.\n *\n * Since the host directive input remapping happens during directive matching, `declaredInputs`\n * won't contain the new alias that the input is available under. This function addresses the\n * issue by patching the host directive aliases to the `declaredInputs`. There is *not* a risk of\n * this patching accidentally introducing new inputs to the host directive, because `declaredInputs`\n * is used *only* by the `NgOnChangesFeature` when determining what name is used in the\n * `SimpleChanges` object which won't be reached if an input doesn't exist.\n */\nfunction patchDeclaredInputs(\n    declaredInputs: Record<string, string>, exposedInputs: HostDirectiveBindingMap): void {\n  for (const publicName in exposedInputs) {\n    if (exposedInputs.hasOwnProperty(publicName)) {\n      const remappedPublicName = exposedInputs[publicName];\n      const privateName = declaredInputs[publicName];\n\n      // We *technically* shouldn't be able to hit this case because we can't have multiple\n      // inputs on the same property and we have validations against conflicting aliases in\n      // `validateMappings`. If we somehow did, it would lead to `ngOnChanges` being invoked\n      // with the wrong name so we have a non-user-friendly assertion here just in case.\n      if ((typeof ngDevMode === 'undefined' || ngDevMode) &&\n          declaredInputs.hasOwnProperty(remappedPublicName)) {\n        assertEqual(\n            declaredInputs[remappedPublicName], declaredInputs[publicName],\n            `Conflicting host directive input alias ${publicName}.`);\n      }\n\n      declaredInputs[remappedPublicName] = privateName;\n    }\n  }\n}\n\n/**\n * Verifies that the host directive has been configured correctly.\n * @param hostDirectiveConfig Host directive configuration object.\n * @param directiveDef Directive definition of the host directive.\n * @param matchedDefs Directives that have been matched so far.\n */\nfunction validateHostDirective(\n    hostDirectiveConfig: HostDirectiveDef<unknown>, directiveDef: DirectiveDef<any>|null,\n    matchedDefs: DirectiveDef<unknown>[]): asserts directiveDef is DirectiveDef<unknown> {\n  const type = hostDirectiveConfig.directive;\n\n  if (directiveDef === null) {\n    if (getComponentDef(type) !== null) {\n      throw new RuntimeError(\n          RuntimeErrorCode.HOST_DIRECTIVE_COMPONENT,\n          `Host directive ${type.name} cannot be a component.`);\n    }\n\n    throw new RuntimeError(\n        RuntimeErrorCode.HOST_DIRECTIVE_UNRESOLVABLE,\n        `Could not resolve metadata for host directive ${type.name}. ` +\n            `Make sure that the ${type.name} class is annotated with an @Directive decorator.`);\n  }\n\n  if (!directiveDef.standalone) {\n    throw new RuntimeError(\n        RuntimeErrorCode.HOST_DIRECTIVE_NOT_STANDALONE,\n        `Host directive ${directiveDef.type.name} must be standalone.`);\n  }\n\n  if (matchedDefs.indexOf(directiveDef) > -1) {\n    throw new RuntimeError(\n        RuntimeErrorCode.DUPLICATE_DIRECTITVE,\n        `Directive ${directiveDef.type.name} matches multiple times on the same element. ` +\n            `Directives can only match an element once.`);\n  }\n\n  validateMappings('input', directiveDef, hostDirectiveConfig.inputs);\n  validateMappings('output', directiveDef, hostDirectiveConfig.outputs);\n}\n\n/**\n * Checks that the host directive inputs/outputs configuration is valid.\n * @param bindingType Kind of binding that is being validated. Used in the error message.\n * @param def Definition of the host directive that is being validated against.\n * @param hostDirectiveBindings Host directive mapping object that shold be validated.\n */\nfunction validateMappings(\n    bindingType: 'input'|'output', def: DirectiveDef<unknown>,\n    hostDirectiveBindings: HostDirectiveBindingMap) {\n  const className = def.type.name;\n  const bindings: Record<string, string> = bindingType === 'input' ? def.inputs : def.outputs;\n\n  for (const publicName in hostDirectiveBindings) {\n    if (hostDirectiveBindings.hasOwnProperty(publicName)) {\n      if (!bindings.hasOwnProperty(publicName)) {\n        throw new RuntimeError(\n            RuntimeErrorCode.HOST_DIRECTIVE_UNDEFINED_BINDING,\n            `Directive ${className} does not have an ${bindingType} with a public name of ${\n                publicName}.`);\n      }\n\n      const remappedPublicName = hostDirectiveBindings[publicName];\n\n      if (bindings.hasOwnProperty(remappedPublicName) &&\n          bindings[remappedPublicName] !== publicName) {\n        throw new RuntimeError(\n            RuntimeErrorCode.HOST_DIRECTIVE_CONFLICTING_ALIAS,\n            `Cannot alias ${bindingType} ${publicName} of host directive ${className} to ${\n                remappedPublicName}, because it already has a different ${\n                bindingType} with the same public name.`);\n      }\n    }\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {ComponentDef, DirectiveDef} from '../interfaces/definition';\nimport {isComponentDef} from '../interfaces/type_checks';\n\nimport {getSuperType} from './inherit_definition_feature';\n\n/**\n * Fields which exist on either directive or component definitions, and need to be copied from\n * parent to child classes by the `CopyDefinitionFeature`.\n */\nconst COPY_DIRECTIVE_FIELDS: (keyof DirectiveDef<unknown>)[] = [\n  // The child class should use the providers of its parent.\n  'providersResolver',\n\n  // Not listed here are any fields which are handled by the `InheritDefinitionFeature`, such\n  // as inputs, outputs, and host binding functions.\n];\n\n/**\n * Fields which exist only on component definitions, and need to be copied from parent to child\n * classes by the `CopyDefinitionFeature`.\n *\n * The type here allows any field of `ComponentDef` which is not also a property of `DirectiveDef`,\n * since those should go in `COPY_DIRECTIVE_FIELDS` above.\n */\nconst COPY_COMPONENT_FIELDS: Exclude<keyof ComponentDef<unknown>, keyof DirectiveDef<unknown>>[] = [\n  // The child class should use the template function of its parent, including all template\n  // semantics.\n  'template',\n  'decls',\n  'consts',\n  'vars',\n  'onPush',\n  'ngContentSelectors',\n\n  // The child class should use the CSS styles of its parent, including all styling semantics.\n  'styles',\n  'encapsulation',\n\n  // The child class should be checked by the runtime in the same way as its parent.\n  'schemas',\n];\n\n/**\n * Copies the fields not handled by the `InheritDefinitionFeature` from the supertype of a\n * definition.\n *\n * This exists primarily to support ngcc migration of an existing View Engine pattern, where an\n * entire decorator is inherited from a parent to a child class. When ngcc detects this case, it\n * generates a skeleton definition on the child class, and applies this feature.\n *\n * The `CopyDefinitionFeature` then copies any needed fields from the parent class' definition,\n * including things like the component template function.\n *\n * @param definition The definition of a child class which inherits from a parent class with its\n * own definition.\n *\n * @codeGenApi\n */\nexport function CopyDefinitionFeature(definition: DirectiveDef<any>|ComponentDef<any>): void {\n  let superType = getSuperType(definition.type)!;\n\n  let superDef: DirectiveDef<any>|ComponentDef<any>|undefined = undefined;\n  if (isComponentDef(definition)) {\n    // Don't use getComponentDef/getDirectiveDef. This logic relies on inheritance.\n    superDef = superType.cmp!;\n  } else {\n    // Don't use getComponentDef/getDirectiveDef. This logic relies on inheritance.\n    superDef = superType.dir!;\n  }\n\n  // Needed because `definition` fields are readonly.\n  const defAny = (definition as any);\n\n  // Copy over any fields that apply to either directives or components.\n  for (const field of COPY_DIRECTIVE_FIELDS) {\n    defAny[field] = superDef[field];\n  }\n\n  if (isComponentDef(superDef)) {\n    // Copy over any component-specific fields.\n    for (const field of COPY_COMPONENT_FIELDS) {\n      defAny[field] = superDef[field];\n    }\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport {SanitizerFn} from '../interfaces/sanitization';\nimport {RENDERER} from '../interfaces/view';\nimport {getBindingIndex, getLView, getSelectedTNode, getTView} from '../state';\nimport {NO_CHANGE} from '../tokens';\n\nimport {interpolation1, interpolation2, interpolation3, interpolation4, interpolation5, interpolation6, interpolation7, interpolation8, interpolationV} from './interpolation';\nimport {elementPropertyInternal, storePropertyBindingMetadata} from './shared';\n\n\n/**\n *\n * Update an interpolated property on an element with a lone bound value\n *\n * Used when the value passed to a property has 1 interpolated value in it, an no additional text\n * surrounds that interpolated value:\n *\n * ```html\n * <div title=\"{{v0}}\"></div>\n * ```\n *\n * Its compiled representation is::\n *\n * ```ts\n * propertyInterpolate('title', v0);\n * ```\n *\n * If the property name also exists as an input property on one of the element's directives,\n * the component property will be set instead of the element property. This check must\n * be conducted at runtime so child components that add new `@Inputs` don't have to be re-compiled.\n *\n * @param propName The name of the property to update\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @param sanitizer An optional sanitizer function\n * @returns itself, so that it may be chained.\n * @codeGenApi\n */\nexport function propertyInterpolate(\n    propName: string, v0: any, sanitizer?: SanitizerFn): typeof propertyInterpolate {\n  propertyInterpolate1(propName, '', v0, '', sanitizer);\n  return propertyInterpolate;\n}\n\n\n/**\n *\n * Update an interpolated property on an element with single bound value surrounded by text.\n *\n * Used when the value passed to a property has 1 interpolated value in it:\n *\n * ```html\n * <div title=\"prefix{{v0}}suffix\"></div>\n * ```\n *\n * Its compiled representation is::\n *\n * ```ts\n * propertyInterpolate1('title', 'prefix', v0, 'suffix');\n * ```\n *\n * If the property name also exists as an input property on one of the element's directives,\n * the component property will be set instead of the element property. This check must\n * be conducted at runtime so child components that add new `@Inputs` don't have to be re-compiled.\n *\n * @param propName The name of the property to update\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @param sanitizer An optional sanitizer function\n * @returns itself, so that it may be chained.\n * @codeGenApi\n */\nexport function propertyInterpolate1(\n    propName: string, prefix: string, v0: any, suffix: string,\n    sanitizer?: SanitizerFn): typeof propertyInterpolate1 {\n  const lView = getLView();\n  const interpolatedValue = interpolation1(lView, prefix, v0, suffix);\n  if (interpolatedValue !== NO_CHANGE) {\n    const tView = getTView();\n    const tNode = getSelectedTNode();\n    elementPropertyInternal(\n        tView, tNode, lView, propName, interpolatedValue, lView[RENDERER], sanitizer, false);\n    ngDevMode &&\n        storePropertyBindingMetadata(\n            tView.data, tNode, propName, getBindingIndex() - 1, prefix, suffix);\n  }\n  return propertyInterpolate1;\n}\n\n/**\n *\n * Update an interpolated property on an element with 2 bound values surrounded by text.\n *\n * Used when the value passed to a property has 2 interpolated values in it:\n *\n * ```html\n * <div title=\"prefix{{v0}}-{{v1}}suffix\"></div>\n * ```\n *\n * Its compiled representation is::\n *\n * ```ts\n * propertyInterpolate2('title', 'prefix', v0, '-', v1, 'suffix');\n * ```\n *\n * If the property name also exists as an input property on one of the element's directives,\n * the component property will be set instead of the element property. This check must\n * be conducted at runtime so child components that add new `@Inputs` don't have to be re-compiled.\n *\n * @param propName The name of the property to update\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @param sanitizer An optional sanitizer function\n * @returns itself, so that it may be chained.\n * @codeGenApi\n */\nexport function propertyInterpolate2(\n    propName: string, prefix: string, v0: any, i0: string, v1: any, suffix: string,\n    sanitizer?: SanitizerFn): typeof propertyInterpolate2 {\n  const lView = getLView();\n  const interpolatedValue = interpolation2(lView, prefix, v0, i0, v1, suffix);\n  if (interpolatedValue !== NO_CHANGE) {\n    const tView = getTView();\n    const tNode = getSelectedTNode();\n    elementPropertyInternal(\n        tView, tNode, lView, propName, interpolatedValue, lView[RENDERER], sanitizer, false);\n    ngDevMode &&\n        storePropertyBindingMetadata(\n            tView.data, tNode, propName, getBindingIndex() - 2, prefix, i0, suffix);\n  }\n  return propertyInterpolate2;\n}\n\n/**\n *\n * Update an interpolated property on an element with 3 bound values surrounded by text.\n *\n * Used when the value passed to a property has 3 interpolated values in it:\n *\n * ```html\n * <div title=\"prefix{{v0}}-{{v1}}-{{v2}}suffix\"></div>\n * ```\n *\n * Its compiled representation is::\n *\n * ```ts\n * propertyInterpolate3(\n * 'title', 'prefix', v0, '-', v1, '-', v2, 'suffix');\n * ```\n *\n * If the property name also exists as an input property on one of the element's directives,\n * the component property will be set instead of the element property. This check must\n * be conducted at runtime so child components that add new `@Inputs` don't have to be re-compiled.\n *\n * @param propName The name of the property to update\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param i1 Static value used for concatenation only.\n * @param v2 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @param sanitizer An optional sanitizer function\n * @returns itself, so that it may be chained.\n * @codeGenApi\n */\nexport function propertyInterpolate3(\n    propName: string, prefix: string, v0: any, i0: string, v1: any, i1: string, v2: any,\n    suffix: string, sanitizer?: SanitizerFn): typeof propertyInterpolate3 {\n  const lView = getLView();\n  const interpolatedValue = interpolation3(lView, prefix, v0, i0, v1, i1, v2, suffix);\n  if (interpolatedValue !== NO_CHANGE) {\n    const tView = getTView();\n    const tNode = getSelectedTNode();\n    elementPropertyInternal(\n        tView, tNode, lView, propName, interpolatedValue, lView[RENDERER], sanitizer, false);\n    ngDevMode &&\n        storePropertyBindingMetadata(\n            tView.data, tNode, propName, getBindingIndex() - 3, prefix, i0, i1, suffix);\n  }\n  return propertyInterpolate3;\n}\n\n/**\n *\n * Update an interpolated property on an element with 4 bound values surrounded by text.\n *\n * Used when the value passed to a property has 4 interpolated values in it:\n *\n * ```html\n * <div title=\"prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}suffix\"></div>\n * ```\n *\n * Its compiled representation is::\n *\n * ```ts\n * propertyInterpolate4(\n * 'title', 'prefix', v0, '-', v1, '-', v2, '-', v3, 'suffix');\n * ```\n *\n * If the property name also exists as an input property on one of the element's directives,\n * the component property will be set instead of the element property. This check must\n * be conducted at runtime so child components that add new `@Inputs` don't have to be re-compiled.\n *\n * @param propName The name of the property to update\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param i1 Static value used for concatenation only.\n * @param v2 Value checked for change.\n * @param i2 Static value used for concatenation only.\n * @param v3 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @param sanitizer An optional sanitizer function\n * @returns itself, so that it may be chained.\n * @codeGenApi\n */\nexport function propertyInterpolate4(\n    propName: string, prefix: string, v0: any, i0: string, v1: any, i1: string, v2: any, i2: string,\n    v3: any, suffix: string, sanitizer?: SanitizerFn): typeof propertyInterpolate4 {\n  const lView = getLView();\n  const interpolatedValue = interpolation4(lView, prefix, v0, i0, v1, i1, v2, i2, v3, suffix);\n  if (interpolatedValue !== NO_CHANGE) {\n    const tView = getTView();\n    const tNode = getSelectedTNode();\n    elementPropertyInternal(\n        tView, tNode, lView, propName, interpolatedValue, lView[RENDERER], sanitizer, false);\n    ngDevMode &&\n        storePropertyBindingMetadata(\n            tView.data, tNode, propName, getBindingIndex() - 4, prefix, i0, i1, i2, suffix);\n  }\n  return propertyInterpolate4;\n}\n\n/**\n *\n * Update an interpolated property on an element with 5 bound values surrounded by text.\n *\n * Used when the value passed to a property has 5 interpolated values in it:\n *\n * ```html\n * <div title=\"prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}-{{v4}}suffix\"></div>\n * ```\n *\n * Its compiled representation is::\n *\n * ```ts\n * propertyInterpolate5(\n * 'title', 'prefix', v0, '-', v1, '-', v2, '-', v3, '-', v4, 'suffix');\n * ```\n *\n * If the property name also exists as an input property on one of the element's directives,\n * the component property will be set instead of the element property. This check must\n * be conducted at runtime so child components that add new `@Inputs` don't have to be re-compiled.\n *\n * @param propName The name of the property to update\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param i1 Static value used for concatenation only.\n * @param v2 Value checked for change.\n * @param i2 Static value used for concatenation only.\n * @param v3 Value checked for change.\n * @param i3 Static value used for concatenation only.\n * @param v4 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @param sanitizer An optional sanitizer function\n * @returns itself, so that it may be chained.\n * @codeGenApi\n */\nexport function propertyInterpolate5(\n    propName: string, prefix: string, v0: any, i0: string, v1: any, i1: string, v2: any, i2: string,\n    v3: any, i3: string, v4: any, suffix: string,\n    sanitizer?: SanitizerFn): typeof propertyInterpolate5 {\n  const lView = getLView();\n  const interpolatedValue =\n      interpolation5(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, suffix);\n  if (interpolatedValue !== NO_CHANGE) {\n    const tView = getTView();\n    const tNode = getSelectedTNode();\n    elementPropertyInternal(\n        tView, tNode, lView, propName, interpolatedValue, lView[RENDERER], sanitizer, false);\n    ngDevMode &&\n        storePropertyBindingMetadata(\n            tView.data, tNode, propName, getBindingIndex() - 5, prefix, i0, i1, i2, i3, suffix);\n  }\n  return propertyInterpolate5;\n}\n\n/**\n *\n * Update an interpolated property on an element with 6 bound values surrounded by text.\n *\n * Used when the value passed to a property has 6 interpolated values in it:\n *\n * ```html\n * <div title=\"prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}-{{v4}}-{{v5}}suffix\"></div>\n * ```\n *\n * Its compiled representation is::\n *\n * ```ts\n * propertyInterpolate6(\n *    'title', 'prefix', v0, '-', v1, '-', v2, '-', v3, '-', v4, '-', v5, 'suffix');\n * ```\n *\n * If the property name also exists as an input property on one of the element's directives,\n * the component property will be set instead of the element property. This check must\n * be conducted at runtime so child components that add new `@Inputs` don't have to be re-compiled.\n *\n * @param propName The name of the property to update\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param i1 Static value used for concatenation only.\n * @param v2 Value checked for change.\n * @param i2 Static value used for concatenation only.\n * @param v3 Value checked for change.\n * @param i3 Static value used for concatenation only.\n * @param v4 Value checked for change.\n * @param i4 Static value used for concatenation only.\n * @param v5 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @param sanitizer An optional sanitizer function\n * @returns itself, so that it may be chained.\n * @codeGenApi\n */\nexport function propertyInterpolate6(\n    propName: string, prefix: string, v0: any, i0: string, v1: any, i1: string, v2: any, i2: string,\n    v3: any, i3: string, v4: any, i4: string, v5: any, suffix: string,\n    sanitizer?: SanitizerFn): typeof propertyInterpolate6 {\n  const lView = getLView();\n  const interpolatedValue =\n      interpolation6(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, suffix);\n  if (interpolatedValue !== NO_CHANGE) {\n    const tView = getTView();\n    const tNode = getSelectedTNode();\n    elementPropertyInternal(\n        tView, tNode, lView, propName, interpolatedValue, lView[RENDERER], sanitizer, false);\n    ngDevMode &&\n        storePropertyBindingMetadata(\n            tView.data, tNode, propName, getBindingIndex() - 6, prefix, i0, i1, i2, i3, i4, suffix);\n  }\n  return propertyInterpolate6;\n}\n\n/**\n *\n * Update an interpolated property on an element with 7 bound values surrounded by text.\n *\n * Used when the value passed to a property has 7 interpolated values in it:\n *\n * ```html\n * <div title=\"prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}-{{v4}}-{{v5}}-{{v6}}suffix\"></div>\n * ```\n *\n * Its compiled representation is::\n *\n * ```ts\n * propertyInterpolate7(\n *    'title', 'prefix', v0, '-', v1, '-', v2, '-', v3, '-', v4, '-', v5, '-', v6, 'suffix');\n * ```\n *\n * If the property name also exists as an input property on one of the element's directives,\n * the component property will be set instead of the element property. This check must\n * be conducted at runtime so child components that add new `@Inputs` don't have to be re-compiled.\n *\n * @param propName The name of the property to update\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param i1 Static value used for concatenation only.\n * @param v2 Value checked for change.\n * @param i2 Static value used for concatenation only.\n * @param v3 Value checked for change.\n * @param i3 Static value used for concatenation only.\n * @param v4 Value checked for change.\n * @param i4 Static value used for concatenation only.\n * @param v5 Value checked for change.\n * @param i5 Static value used for concatenation only.\n * @param v6 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @param sanitizer An optional sanitizer function\n * @returns itself, so that it may be chained.\n * @codeGenApi\n */\nexport function propertyInterpolate7(\n    propName: string, prefix: string, v0: any, i0: string, v1: any, i1: string, v2: any, i2: string,\n    v3: any, i3: string, v4: any, i4: string, v5: any, i5: string, v6: any, suffix: string,\n    sanitizer?: SanitizerFn): typeof propertyInterpolate7 {\n  const lView = getLView();\n  const interpolatedValue =\n      interpolation7(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, suffix);\n  if (interpolatedValue !== NO_CHANGE) {\n    const tView = getTView();\n    const tNode = getSelectedTNode();\n    elementPropertyInternal(\n        tView, tNode, lView, propName, interpolatedValue, lView[RENDERER], sanitizer, false);\n    ngDevMode &&\n        storePropertyBindingMetadata(\n            tView.data, tNode, propName, getBindingIndex() - 7, prefix, i0, i1, i2, i3, i4, i5,\n            suffix);\n  }\n  return propertyInterpolate7;\n}\n\n/**\n *\n * Update an interpolated property on an element with 8 bound values surrounded by text.\n *\n * Used when the value passed to a property has 8 interpolated values in it:\n *\n * ```html\n * <div title=\"prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}-{{v4}}-{{v5}}-{{v6}}-{{v7}}suffix\"></div>\n * ```\n *\n * Its compiled representation is::\n *\n * ```ts\n * propertyInterpolate8(\n *  'title', 'prefix', v0, '-', v1, '-', v2, '-', v3, '-', v4, '-', v5, '-', v6, '-', v7, 'suffix');\n * ```\n *\n * If the property name also exists as an input property on one of the element's directives,\n * the component property will be set instead of the element property. This check must\n * be conducted at runtime so child components that add new `@Inputs` don't have to be re-compiled.\n *\n * @param propName The name of the property to update\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param i1 Static value used for concatenation only.\n * @param v2 Value checked for change.\n * @param i2 Static value used for concatenation only.\n * @param v3 Value checked for change.\n * @param i3 Static value used for concatenation only.\n * @param v4 Value checked for change.\n * @param i4 Static value used for concatenation only.\n * @param v5 Value checked for change.\n * @param i5 Static value used for concatenation only.\n * @param v6 Value checked for change.\n * @param i6 Static value used for concatenation only.\n * @param v7 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @param sanitizer An optional sanitizer function\n * @returns itself, so that it may be chained.\n * @codeGenApi\n */\nexport function propertyInterpolate8(\n    propName: string, prefix: string, v0: any, i0: string, v1: any, i1: string, v2: any, i2: string,\n    v3: any, i3: string, v4: any, i4: string, v5: any, i5: string, v6: any, i6: string, v7: any,\n    suffix: string, sanitizer?: SanitizerFn): typeof propertyInterpolate8 {\n  const lView = getLView();\n  const interpolatedValue = interpolation8(\n      lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, i6, v7, suffix);\n  if (interpolatedValue !== NO_CHANGE) {\n    const tView = getTView();\n    const tNode = getSelectedTNode();\n    elementPropertyInternal(\n        tView, tNode, lView, propName, interpolatedValue, lView[RENDERER], sanitizer, false);\n    ngDevMode &&\n        storePropertyBindingMetadata(\n            tView.data, tNode, propName, getBindingIndex() - 8, prefix, i0, i1, i2, i3, i4, i5, i6,\n            suffix);\n  }\n  return propertyInterpolate8;\n}\n\n/**\n * Update an interpolated property on an element with 9 or more bound values surrounded by text.\n *\n * Used when the number of interpolated values exceeds 8.\n *\n * ```html\n * <div\n *  title=\"prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}-{{v4}}-{{v5}}-{{v6}}-{{v7}}-{{v8}}-{{v9}}suffix\"></div>\n * ```\n *\n * Its compiled representation is::\n *\n * ```ts\n * propertyInterpolateV(\n *  'title', ['prefix', v0, '-', v1, '-', v2, '-', v3, '-', v4, '-', v5, '-', v6, '-', v7, '-', v9,\n *  'suffix']);\n * ```\n *\n * If the property name also exists as an input property on one of the element's directives,\n * the component property will be set instead of the element property. This check must\n * be conducted at runtime so child components that add new `@Inputs` don't have to be re-compiled.\n *\n * @param propName The name of the property to update.\n * @param values The collection of values and the strings in between those values, beginning with a\n * string prefix and ending with a string suffix.\n * (e.g. `['prefix', value0, '-', value1, '-', value2, ..., value99, 'suffix']`)\n * @param sanitizer An optional sanitizer function\n * @returns itself, so that it may be chained.\n * @codeGenApi\n */\nexport function propertyInterpolateV(\n    propName: string, values: any[], sanitizer?: SanitizerFn): typeof propertyInterpolateV {\n  const lView = getLView();\n  const interpolatedValue = interpolationV(lView, values);\n  if (interpolatedValue !== NO_CHANGE) {\n    const tView = getTView();\n    const tNode = getSelectedTNode();\n    elementPropertyInternal(\n        tView, tNode, lView, propName, interpolatedValue, lView[RENDERER], sanitizer, false);\n    if (ngDevMode) {\n      const interpolationInBetween = [values[0]];  // prefix\n      for (let i = 2; i < values.length; i += 2) {\n        interpolationInBetween.push(values[i]);\n      }\n      storePropertyBindingMetadata(\n          tView.data, tNode, propName, getBindingIndex() - interpolationInBetween.length + 1,\n          ...interpolationInBetween);\n    }\n  }\n  return propertyInterpolateV;\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {SanitizerFn} from './sanitization';\n\n\n/**\n * Stores a list of nodes which need to be removed.\n *\n * Numbers are indexes into the `LView`\n * - index > 0: `removeRNode(lView[0])`\n * - index < 0: `removeICU(~lView[0])`\n */\nexport interface I18nRemoveOpCodes extends Array<number> {\n  __brand__: 'I18nRemoveOpCodes';\n}\n\n/**\n * `I18nMutateOpCode` defines OpCodes for `I18nMutateOpCodes` array.\n *\n * OpCodes are efficient operations which can be applied to the DOM to update it. (For example to\n * update to a new ICU case requires that we clean up previous elements and create new ones.)\n *\n * OpCodes contain three parts:\n *  1) Parent node index offset. (p)\n *  2) Reference node index offset. (r)\n *  3) The instruction to execute. (i)\n *\n * pppp pppp pppp pppp rrrr rrrr rrrr riii\n * 3322 2222 2222 1111 1111 1110 0000 0000\n * 1098 7654 3210 9876 5432 1098 7654 3210\n *\n * ```\n * var parent = lView[opCode >>> SHIFT_PARENT];\n * var refNode = lView[((opCode & MASK_REF) >>> SHIFT_REF)];\n * var instruction = opCode & MASK_OPCODE;\n * ```\n *\n * See: `I18nCreateOpCodes` for example of usage.\n */\nexport const enum IcuCreateOpCode {\n  /**\n   * Stores shift amount for bits 17-3 that contain reference index.\n   */\n  SHIFT_REF = 1,\n  /**\n   * Stores shift amount for bits 31-17 that contain parent index.\n   */\n  SHIFT_PARENT = 17,\n  /**\n   * Mask for OpCode\n   */\n  MASK_INSTRUCTION = 0b1,\n\n  /**\n   * Mask for the Reference node (bits 16-3)\n   */\n  MASK_REF = 0b11111111111111110,\n  //           11111110000000000\n  //           65432109876543210\n\n  /**\n   * Instruction to append the current node to `PARENT`.\n   */\n  AppendChild = 0b0,\n\n  /**\n   * Instruction to set the attribute of a node.\n   */\n  Attr = 0b1,\n}\n\n\n/**\n * Array storing OpCode for dynamically creating `i18n` blocks.\n *\n * Example:\n * ```ts\n * <I18nCreateOpCode>[\n *   // For adding text nodes\n *   // ---------------------\n *   // Equivalent to:\n *   //   lView[1].appendChild(lView[0] = document.createTextNode('xyz'));\n *   'xyz', 0, 1 << SHIFT_PARENT | 0 << SHIFT_REF | AppendChild,\n *\n *   // For adding element nodes\n *   // ---------------------\n *   // Equivalent to:\n *   //   lView[1].appendChild(lView[0] = document.createElement('div'));\n *   ELEMENT_MARKER, 'div', 0, 1 << SHIFT_PARENT | 0 << SHIFT_REF | AppendChild,\n *\n *   // For adding comment nodes\n *   // ---------------------\n *   // Equivalent to:\n *   //   lView[1].appendChild(lView[0] = document.createComment(''));\n *   ICU_MARKER, '', 0, 1 << SHIFT_PARENT | 0 << SHIFT_REF | AppendChild,\n *\n *   // For moving existing nodes to a different location\n *   // --------------------------------------------------\n *   // Equivalent to:\n *   //   const node = lView[1];\n *   //   lView[2].appendChild(node);\n *   1 << SHIFT_REF | Select, 2 << SHIFT_PARENT | 0 << SHIFT_REF | AppendChild,\n *\n *   // For removing existing nodes\n *   // --------------------------------------------------\n *   //   const node = lView[1];\n *   //   removeChild(tView.data(1), node, lView);\n *   1 << SHIFT_REF | Remove,\n *\n *   // For writing attributes\n *   // --------------------------------------------------\n *   //   const node = lView[1];\n *   //   node.setAttribute('attr', 'value');\n *   1 << SHIFT_REF | Attr, 'attr', 'value'\n * ];\n * ```\n */\nexport interface IcuCreateOpCodes extends Array<number|string|ELEMENT_MARKER|ICU_MARKER|null>,\n                                          I18nDebug {\n  __brand__: 'I18nCreateOpCodes';\n}\n\nexport const enum I18nUpdateOpCode {\n  /**\n   * Stores shift amount for bits 17-2 that contain reference index.\n   */\n  SHIFT_REF = 2,\n  /**\n   * Mask for OpCode\n   */\n  MASK_OPCODE = 0b11,\n\n  /**\n   * Instruction to update a text node.\n   */\n  Text = 0b00,\n  /**\n   * Instruction to update a attribute of a node.\n   */\n  Attr = 0b01,\n  /**\n   * Instruction to switch the current ICU case.\n   */\n  IcuSwitch = 0b10,\n  /**\n   * Instruction to update the current ICU case.\n   */\n  IcuUpdate = 0b11,\n}\n\n/**\n * Marks that the next string is an element name.\n *\n * See `I18nMutateOpCodes` documentation.\n */\nexport const ELEMENT_MARKER: ELEMENT_MARKER = {\n  marker: 'element'\n};\nexport interface ELEMENT_MARKER {\n  marker: 'element';\n}\n\n/**\n * Marks that the next string is comment text need for ICU.\n *\n * See `I18nMutateOpCodes` documentation.\n */\nexport const ICU_MARKER: ICU_MARKER = {\n  marker: 'ICU'\n};\n\nexport interface ICU_MARKER {\n  marker: 'ICU';\n}\n\nexport interface I18nDebug {\n  /**\n   * Human readable representation of the OpCode arrays.\n   *\n   * NOTE: This property only exists if `ngDevMode` is set to `true` and it is not present in\n   * production. Its presence is purely to help debug issue in development, and should not be relied\n   * on in production application.\n   */\n  debug?: string[];\n}\n\n/**\n * Array storing OpCode for dynamically creating `i18n` translation DOM elements.\n *\n * This array creates a sequence of `Text` and `Comment` (as ICU anchor) DOM elements. It consists\n * of a pair of `number` and `string` pairs which encode the operations for the creation of the\n * translated block.\n *\n * The number is shifted and encoded according to `I18nCreateOpCode`\n *\n * Pseudocode:\n * ```\n * const i18nCreateOpCodes = [\n *   10 << I18nCreateOpCode.SHIFT, \"Text Node add to DOM\",\n *   11 << I18nCreateOpCode.SHIFT | I18nCreateOpCode.COMMENT, \"Comment Node add to DOM\",\n *   12 << I18nCreateOpCode.SHIFT | I18nCreateOpCode.APPEND_LATER, \"Text Node added later\"\n * ];\n *\n * for(var i=0; i<i18nCreateOpCodes.length; i++) {\n *   const opcode = i18NCreateOpCodes[i++];\n *   const index = opcode >> I18nCreateOpCode.SHIFT;\n *   const text = i18NCreateOpCodes[i];\n *   let node: Text|Comment;\n *   if (opcode & I18nCreateOpCode.COMMENT === I18nCreateOpCode.COMMENT) {\n *     node = lView[~index] = document.createComment(text);\n *   } else {\n *     node = lView[index] = document.createText(text);\n *   }\n *   if (opcode & I18nCreateOpCode.APPEND_EAGERLY !== I18nCreateOpCode.APPEND_EAGERLY) {\n *     parentNode.appendChild(node);\n *   }\n * }\n * ```\n */\nexport interface I18nCreateOpCodes extends Array<number|string>, I18nDebug {\n  __brand__: 'I18nCreateOpCodes';\n}\n\n/**\n * See `I18nCreateOpCodes`\n */\nexport enum I18nCreateOpCode {\n  /**\n   * Number of bits to shift index so that it can be combined with the `APPEND_EAGERLY` and\n   * `COMMENT`.\n   */\n  SHIFT = 2,\n\n  /**\n   * Should the node be appended to parent immediately after creation.\n   */\n  APPEND_EAGERLY = 0b01,\n\n  /**\n   * If set the node should be comment (rather than a text) node.\n   */\n  COMMENT = 0b10,\n}\n\n\n/**\n * Stores DOM operations which need to be applied to update DOM render tree due to changes in\n * expressions.\n *\n * The basic idea is that `i18nExp` OpCodes capture expression changes and update a change\n * mask bit. (Bit 1 for expression 1, bit 2 for expression 2 etc..., bit 32 for expression 32 and\n * higher.) The OpCodes then compare its own change mask against the expression change mask to\n * determine if the OpCodes should execute.\n *\n * NOTE: 32nd bit is special as it says 32nd or higher. This way if we have more than 32 bindings\n * the code still works, but with lower efficiency. (it is unlikely that a translation would have\n * more than 32 bindings.)\n *\n * These OpCodes can be used by both the i18n block as well as ICU sub-block.\n *\n * ## Example\n *\n * Assume\n * ```ts\n *   if (rf & RenderFlags.Update) {\n *    i18nExp(ctx.exp1); // If changed set mask bit 1\n *    i18nExp(ctx.exp2); // If changed set mask bit 2\n *    i18nExp(ctx.exp3); // If changed set mask bit 3\n *    i18nExp(ctx.exp4); // If changed set mask bit 4\n *    i18nApply(0);            // Apply all changes by executing the OpCodes.\n *  }\n * ```\n * We can assume that each call to `i18nExp` sets an internal `changeMask` bit depending on the\n * index of `i18nExp`.\n *\n * ### OpCodes\n * ```ts\n * <I18nUpdateOpCodes>[\n *   // The following OpCodes represent: `<div i18n-title=\"pre{{exp1}}in{{exp2}}post\">`\n *   // If `changeMask & 0b11`\n *   //        has changed then execute update OpCodes.\n *   //        has NOT changed then skip `8` values and start processing next OpCodes.\n *   0b11, 8,\n *   // Concatenate `newValue = 'pre'+lView[bindIndex-4]+'in'+lView[bindIndex-3]+'post';`.\n *   'pre', -4, 'in', -3, 'post',\n *   // Update attribute: `elementAttribute(1, 'title', sanitizerFn(newValue));`\n *   1 << SHIFT_REF | Attr, 'title', sanitizerFn,\n *\n *   // The following OpCodes represent: `<div i18n>Hello {{exp3}}!\">`\n *   // If `changeMask & 0b100`\n *   //        has changed then execute update OpCodes.\n *   //        has NOT changed then skip `4` values and start processing next OpCodes.\n *   0b100, 4,\n *   // Concatenate `newValue = 'Hello ' + lView[bindIndex -2] + '!';`.\n *   'Hello ', -2, '!',\n *   // Update text: `lView[1].textContent = newValue;`\n *   1 << SHIFT_REF | Text,\n *\n *   // The following OpCodes represent: `<div i18n>{exp4, plural, ... }\">`\n *   // If `changeMask & 0b1000`\n *   //        has changed then execute update OpCodes.\n *   //        has NOT changed then skip `2` values and start processing next OpCodes.\n *   0b1000, 2,\n *   // Concatenate `newValue = lView[bindIndex -1];`.\n *   -1,\n *   // Switch ICU: `icuSwitchCase(lView[1], 0, newValue);`\n *   0 << SHIFT_ICU | 1 << SHIFT_REF | IcuSwitch,\n *\n *   // Note `changeMask & -1` is always true, so the IcuUpdate will always execute.\n *   -1, 1,\n *   // Update ICU: `icuUpdateCase(lView[1], 0);`\n *   0 << SHIFT_ICU | 1 << SHIFT_REF | IcuUpdate,\n *\n * ];\n * ```\n *\n */\nexport interface I18nUpdateOpCodes extends Array<string|number|SanitizerFn|null>, I18nDebug {\n  __brand__: 'I18nUpdateOpCodes';\n}\n\n/**\n * Store information for the i18n translation block.\n */\nexport interface TI18n {\n  /**\n   * A set of OpCodes which will create the Text Nodes and ICU anchors for the translation blocks.\n   *\n   * NOTE: The ICU anchors are filled in with ICU Update OpCode.\n   */\n  create: I18nCreateOpCodes;\n\n  /**\n   * A set of OpCodes which will be executed on each change detection to determine if any changes to\n   * DOM are required.\n   */\n  update: I18nUpdateOpCodes;\n}\n\n/**\n * Defines the ICU type of `select` or `plural`\n */\nexport const enum IcuType {\n  select = 0,\n  plural = 1,\n}\n\nexport interface TIcu {\n  /**\n   * Defines the ICU type of `select` or `plural`\n   */\n  type: IcuType;\n\n  /**\n   * Index in `LView` where the anchor node is stored. `<!-- ICU 0:0 -->`\n   */\n  anchorIdx: number;\n\n  /**\n   * Currently selected ICU case pointer.\n   *\n   * `lView[currentCaseLViewIndex]` stores the currently selected case. This is needed to know how\n   * to clean up the current case when transitioning no the new case.\n   *\n   * If the value stored is:\n   * `null`: No current case selected.\n   *   `<0`: A flag which means that the ICU just switched and that `icuUpdate` must be executed\n   *         regardless of the `mask`. (After the execution the flag is cleared)\n   *   `>=0` A currently selected case index.\n   */\n  currentCaseLViewIndex: number;\n\n  /**\n   * A list of case values which the current ICU will try to match.\n   *\n   * The last value is `other`\n   */\n  cases: any[];\n\n  /**\n   * A set of OpCodes to apply in order to build up the DOM render tree for the ICU\n   */\n  create: IcuCreateOpCodes[];\n\n  /**\n   * A set of OpCodes to apply in order to destroy the DOM render tree for the ICU.\n   */\n  remove: I18nRemoveOpCodes[];\n\n  /**\n   * A set of OpCodes to apply in order to update the DOM render tree for the ICU bindings.\n   */\n  update: I18nUpdateOpCodes[];\n}\n\n// Note: This hack is necessary so we don't erroneously get a circular dependency\n// failure based on types.\nexport const unusedValueExportToPlacateAjd = 1;\n\n/**\n * Parsed ICU expression\n */\nexport interface IcuExpression {\n  type: IcuType;\n  mainBinding: number;\n  cases: string[];\n  values: (string|IcuExpression)[][];\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {assertDomNode, assertIndexInRange} from '../util/assert';\n\nimport {TNode, TNodeFlags, TNodeType} from './interfaces/node';\nimport {Renderer} from './interfaces/renderer';\nimport {RElement, RNode} from './interfaces/renderer_dom';\nimport {LView} from './interfaces/view';\nimport {getInsertInFrontOfRNodeWithNoI18n, nativeInsertBefore} from './node_manipulation';\nimport {unwrapRNode} from './util/view_utils';\n\n\n/**\n * Find a node in front of which `currentTNode` should be inserted (takes i18n into account).\n *\n * This method determines the `RNode` in front of which we should insert the `currentRNode`. This\n * takes `TNode.insertBeforeIndex` into account.\n *\n * @param parentTNode parent `TNode`\n * @param currentTNode current `TNode` (The node which we would like to insert into the DOM)\n * @param lView current `LView`\n */\nexport function getInsertInFrontOfRNodeWithI18n(\n    parentTNode: TNode, currentTNode: TNode, lView: LView): RNode|null {\n  const tNodeInsertBeforeIndex = currentTNode.insertBeforeIndex;\n  const insertBeforeIndex =\n      Array.isArray(tNodeInsertBeforeIndex) ? tNodeInsertBeforeIndex[0] : tNodeInsertBeforeIndex;\n  if (insertBeforeIndex === null) {\n    return getInsertInFrontOfRNodeWithNoI18n(parentTNode, currentTNode, lView);\n  } else {\n    ngDevMode && assertIndexInRange(lView, insertBeforeIndex);\n    return unwrapRNode(lView[insertBeforeIndex]);\n  }\n}\n\n\n/**\n * Process `TNode.insertBeforeIndex` by adding i18n text nodes.\n *\n * See `TNode.insertBeforeIndex`\n */\nexport function processI18nInsertBefore(\n    renderer: Renderer, childTNode: TNode, lView: LView, childRNode: RNode|RNode[],\n    parentRElement: RElement|null): void {\n  const tNodeInsertBeforeIndex = childTNode.insertBeforeIndex;\n  if (Array.isArray(tNodeInsertBeforeIndex)) {\n    // An array indicates that there are i18n nodes that need to be added as children of this\n    // `childRNode`. These i18n nodes were created before this `childRNode` was available and so\n    // only now can be added. The first element of the array is the normal index where we should\n    // insert the `childRNode`. Additional elements are the extra nodes to be added as children of\n    // `childRNode`.\n    ngDevMode && assertDomNode(childRNode);\n    let i18nParent: RElement|null = childRNode as RElement;\n    let anchorRNode: RNode|null = null;\n    if (!(childTNode.type & TNodeType.AnyRNode)) {\n      anchorRNode = i18nParent;\n      i18nParent = parentRElement;\n    }\n    if (i18nParent !== null && childTNode.componentOffset === -1) {\n      for (let i = 1; i < tNodeInsertBeforeIndex.length; i++) {\n        // No need to `unwrapRNode` because all of the indexes point to i18n text nodes.\n        // see `assertDomNode` below.\n        const i18nChild = lView[tNodeInsertBeforeIndex[i]];\n        nativeInsertBefore(renderer, i18nParent, i18nChild, anchorRNode, false);\n      }\n    }\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {assertEqual} from '../../util/assert';\nimport {TNode, TNodeType} from '../interfaces/node';\nimport {setI18nHandling} from '../node_manipulation';\nimport {getInsertInFrontOfRNodeWithI18n, processI18nInsertBefore} from '../node_manipulation_i18n';\n\n/**\n * Add `tNode` to `previousTNodes` list and update relevant `TNode`s in `previousTNodes` list\n * `tNode.insertBeforeIndex`.\n *\n * Things to keep in mind:\n * 1. All i18n text nodes are encoded as `TNodeType.Element` and are created eagerly by the\n *    `i18nStart` instruction.\n * 2. All `TNodeType.Placeholder` `TNodes` are elements which will be created later by\n *    `elementStart` instruction.\n * 3. `elementStart` instruction will create `TNode`s in the ascending `TNode.index` order. (So a\n *    smaller index `TNode` is guaranteed to be created before a larger one)\n *\n * We use the above three invariants to determine `TNode.insertBeforeIndex`.\n *\n * In an ideal world `TNode.insertBeforeIndex` would always be `TNode.next.index`. However,\n * this will not work because `TNode.next.index` may be larger than `TNode.index` which means that\n * the next node is not yet created and therefore we can't insert in front of it.\n *\n * Rule1: `TNode.insertBeforeIndex = null` if `TNode.next === null` (Initial condition, as we don't\n *        know if there will be further `TNode`s inserted after.)\n * Rule2: If `previousTNode` is created after the `tNode` being inserted, then\n *        `previousTNode.insertBeforeNode = tNode.index` (So when a new `tNode` is added we check\n *        previous to see if we can update its `insertBeforeTNode`)\n *\n * See `TNode.insertBeforeIndex` for more context.\n *\n * @param previousTNodes A list of previous TNodes so that we can easily traverse `TNode`s in\n *     reverse order. (If `TNode` would have `previous` this would not be necessary.)\n * @param newTNode A TNode to add to the `previousTNodes` list.\n */\nexport function addTNodeAndUpdateInsertBeforeIndex(previousTNodes: TNode[], newTNode: TNode) {\n  // Start with Rule1\n  ngDevMode &&\n      assertEqual(newTNode.insertBeforeIndex, null, 'We expect that insertBeforeIndex is not set');\n\n  previousTNodes.push(newTNode);\n  if (previousTNodes.length > 1) {\n    for (let i = previousTNodes.length - 2; i >= 0; i--) {\n      const existingTNode = previousTNodes[i];\n      // Text nodes are created eagerly and so they don't need their `indexBeforeIndex` updated.\n      // It is safe to ignore them.\n      if (!isI18nText(existingTNode)) {\n        if (isNewTNodeCreatedBefore(existingTNode, newTNode) &&\n            getInsertBeforeIndex(existingTNode) === null) {\n          // If it was created before us in time, (and it does not yet have `insertBeforeIndex`)\n          // then add the `insertBeforeIndex`.\n          setInsertBeforeIndex(existingTNode, newTNode.index);\n        }\n      }\n    }\n  }\n}\n\nfunction isI18nText(tNode: TNode): boolean {\n  return !(tNode.type & TNodeType.Placeholder);\n}\n\nfunction isNewTNodeCreatedBefore(existingTNode: TNode, newTNode: TNode): boolean {\n  return isI18nText(newTNode) || existingTNode.index > newTNode.index;\n}\n\nfunction getInsertBeforeIndex(tNode: TNode): number|null {\n  const index = tNode.insertBeforeIndex;\n  return Array.isArray(index) ? index[0] : index;\n}\n\nfunction setInsertBeforeIndex(tNode: TNode, value: number): void {\n  const index = tNode.insertBeforeIndex;\n  if (Array.isArray(index)) {\n    // Array is stored if we have to insert child nodes. See `TNode.insertBeforeIndex`\n    index[0] = value;\n  } else {\n    setI18nHandling(getInsertInFrontOfRNodeWithI18n, processI18nInsertBefore);\n    tNode.insertBeforeIndex = value;\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {assertEqual, assertGreaterThan, assertGreaterThanOrEqual, throwError} from '../../util/assert';\nimport {assertTIcu, assertTNode} from '../assert';\nimport {createTNodeAtIndex} from '../instructions/shared';\nimport {IcuCreateOpCode, TIcu} from '../interfaces/i18n';\nimport {TIcuContainerNode, TNode, TNodeType} from '../interfaces/node';\nimport {LView, TView} from '../interfaces/view';\nimport {assertTNodeType} from '../node_assert';\nimport {setI18nHandling} from '../node_manipulation';\nimport {getInsertInFrontOfRNodeWithI18n, processI18nInsertBefore} from '../node_manipulation_i18n';\nimport {addTNodeAndUpdateInsertBeforeIndex} from './i18n_insert_before_index';\n\n\n/**\n * Retrieve `TIcu` at a given `index`.\n *\n * The `TIcu` can be stored either directly (if it is nested ICU) OR\n * it is stored inside tho `TIcuContainer` if it is top level ICU.\n *\n * The reason for this is that the top level ICU need a `TNode` so that they are part of the render\n * tree, but nested ICU's have no TNode, because we don't know ahead of time if the nested ICU is\n * expressed (parent ICU may have selected a case which does not contain it.)\n *\n * @param tView Current `TView`.\n * @param index Index where the value should be read from.\n */\nexport function getTIcu(tView: TView, index: number): TIcu|null {\n  const value = tView.data[index] as null | TIcu | TIcuContainerNode | string;\n  if (value === null || typeof value === 'string') return null;\n  if (ngDevMode &&\n      !(value.hasOwnProperty('tViews') || value.hasOwnProperty('currentCaseLViewIndex'))) {\n    throwError('We expect to get \\'null\\'|\\'TIcu\\'|\\'TIcuContainer\\', but got: ' + value);\n  }\n  // Here the `value.hasOwnProperty('currentCaseLViewIndex')` is a polymorphic read as it can be\n  // either TIcu or TIcuContainerNode. This is not ideal, but we still think it is OK because it\n  // will be just two cases which fits into the browser inline cache (inline cache can take up to\n  // 4)\n  const tIcu = value.hasOwnProperty('currentCaseLViewIndex') ? value as TIcu :\n                                                               (value as TIcuContainerNode).value;\n  ngDevMode && assertTIcu(tIcu);\n  return tIcu;\n}\n\n/**\n * Store `TIcu` at a give `index`.\n *\n * The `TIcu` can be stored either directly (if it is nested ICU) OR\n * it is stored inside tho `TIcuContainer` if it is top level ICU.\n *\n * The reason for this is that the top level ICU need a `TNode` so that they are part of the render\n * tree, but nested ICU's have no TNode, because we don't know ahead of time if the nested ICU is\n * expressed (parent ICU may have selected a case which does not contain it.)\n *\n * @param tView Current `TView`.\n * @param index Index where the value should be stored at in `Tview.data`\n * @param tIcu The TIcu to store.\n */\nexport function setTIcu(tView: TView, index: number, tIcu: TIcu): void {\n  const tNode = tView.data[index] as null | TIcuContainerNode;\n  ngDevMode &&\n      assertEqual(\n          tNode === null || tNode.hasOwnProperty('tViews'), true,\n          'We expect to get \\'null\\'|\\'TIcuContainer\\'');\n  if (tNode === null) {\n    tView.data[index] = tIcu;\n  } else {\n    ngDevMode && assertTNodeType(tNode, TNodeType.Icu);\n    tNode.value = tIcu;\n  }\n}\n\n/**\n * Set `TNode.insertBeforeIndex` taking the `Array` into account.\n *\n * See `TNode.insertBeforeIndex`\n */\nexport function setTNodeInsertBeforeIndex(tNode: TNode, index: number) {\n  ngDevMode && assertTNode(tNode);\n  let insertBeforeIndex = tNode.insertBeforeIndex;\n  if (insertBeforeIndex === null) {\n    setI18nHandling(getInsertInFrontOfRNodeWithI18n, processI18nInsertBefore);\n    insertBeforeIndex = tNode.insertBeforeIndex =\n        [null!/* may be updated to number later */, index];\n  } else {\n    assertEqual(Array.isArray(insertBeforeIndex), true, 'Expecting array here');\n    (insertBeforeIndex as number[]).push(index);\n  }\n}\n\n/**\n * Create `TNode.type=TNodeType.Placeholder` node.\n *\n * See `TNodeType.Placeholder` for more information.\n */\nexport function createTNodePlaceholder(\n    tView: TView, previousTNodes: TNode[], index: number): TNode {\n  const tNode = createTNodeAtIndex(tView, index, TNodeType.Placeholder, null, null);\n  addTNodeAndUpdateInsertBeforeIndex(previousTNodes, tNode);\n  return tNode;\n}\n\n\n/**\n * Returns current ICU case.\n *\n * ICU cases are stored as index into the `TIcu.cases`.\n * At times it is necessary to communicate that the ICU case just switched and that next ICU update\n * should update all bindings regardless of the mask. In such a case the we store negative numbers\n * for cases which have just been switched. This function removes the negative flag.\n */\nexport function getCurrentICUCaseIndex(tIcu: TIcu, lView: LView) {\n  const currentCase: number|null = lView[tIcu.currentCaseLViewIndex];\n  return currentCase === null ? currentCase : (currentCase < 0 ? ~currentCase : currentCase);\n}\n\nexport function getParentFromIcuCreateOpCode(mergedCode: number): number {\n  return mergedCode >>> IcuCreateOpCode.SHIFT_PARENT;\n}\n\nexport function getRefFromIcuCreateOpCode(mergedCode: number): number {\n  return (mergedCode & IcuCreateOpCode.MASK_REF) >>> IcuCreateOpCode.SHIFT_REF;\n}\n\nexport function getInstructionFromIcuCreateOpCode(mergedCode: number): number {\n  return mergedCode & IcuCreateOpCode.MASK_INSTRUCTION;\n}\n\nexport function icuCreateOpCode(opCode: IcuCreateOpCode, parentIdx: number, refIdx: number) {\n  ngDevMode && assertGreaterThanOrEqual(parentIdx, 0, 'Missing parent index');\n  ngDevMode && assertGreaterThan(refIdx, 0, 'Missing ref index');\n  return opCode | parentIdx << IcuCreateOpCode.SHIFT_PARENT | refIdx << IcuCreateOpCode.SHIFT_REF;\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {RuntimeError, RuntimeErrorCode} from '../../errors';\nimport {getPluralCase} from '../../i18n/localization';\nimport {assertDefined, assertDomNode, assertEqual, assertGreaterThan, assertIndexInRange, throwError} from '../../util/assert';\nimport {assertIndexInExpandoRange, assertTIcu} from '../assert';\nimport {attachPatchData} from '../context_discovery';\nimport {elementPropertyInternal, setElementAttribute} from '../instructions/shared';\nimport {ELEMENT_MARKER, I18nCreateOpCode, I18nCreateOpCodes, I18nUpdateOpCode, I18nUpdateOpCodes, ICU_MARKER, IcuCreateOpCode, IcuCreateOpCodes, IcuType, TI18n, TIcu} from '../interfaces/i18n';\nimport {TNode} from '../interfaces/node';\nimport {RElement, RNode, RText} from '../interfaces/renderer_dom';\nimport {SanitizerFn} from '../interfaces/sanitization';\nimport {HEADER_OFFSET, LView, RENDERER, TView} from '../interfaces/view';\nimport {createCommentNode, createElementNode, createTextNode, nativeInsertBefore, nativeParentNode, nativeRemoveNode, updateTextNode} from '../node_manipulation';\nimport {getBindingIndex} from '../state';\nimport {renderStringify} from '../util/stringify_utils';\nimport {getNativeByIndex, unwrapRNode} from '../util/view_utils';\n\nimport {getLocaleId} from './i18n_locale_id';\nimport {getCurrentICUCaseIndex, getParentFromIcuCreateOpCode, getRefFromIcuCreateOpCode, getTIcu} from './i18n_util';\n\n\n\n/**\n * Keep track of which input bindings in `i18nExp` have changed.\n *\n * This is used to efficiently update expressions in i18n only when the corresponding input has\n * changed.\n *\n * 1) Each bit represents which of the `i18nExp` has changed.\n * 2) There are 32 bits allowed in JS.\n * 3) Bit 32 is special as it is shared for all changes past 32. (In other words if you have more\n * than 32 `i18nExp` then all changes past 32nd `i18nExp` will be mapped to same bit. This means\n * that we may end up changing more than we need to. But i18n expressions with 32 bindings is rare\n * so in practice it should not be an issue.)\n */\nlet changeMask = 0b0;\n\n/**\n * Keeps track of which bit needs to be updated in `changeMask`\n *\n * This value gets incremented on every call to `i18nExp`\n */\nlet changeMaskCounter = 0;\n\n/**\n * Keep track of which input bindings in `i18nExp` have changed.\n *\n * `setMaskBit` gets invoked by each call to `i18nExp`.\n *\n * @param hasChange did `i18nExp` detect a change.\n */\nexport function setMaskBit(hasChange: boolean) {\n  if (hasChange) {\n    changeMask = changeMask | (1 << Math.min(changeMaskCounter, 31));\n  }\n  changeMaskCounter++;\n}\n\nexport function applyI18n(tView: TView, lView: LView, index: number) {\n  if (changeMaskCounter > 0) {\n    ngDevMode && assertDefined(tView, `tView should be defined`);\n    const tI18n = tView.data[index] as TI18n | I18nUpdateOpCodes;\n    // When `index` points to an `i18nAttributes` then we have an array otherwise `TI18n`\n    const updateOpCodes: I18nUpdateOpCodes =\n        Array.isArray(tI18n) ? tI18n as I18nUpdateOpCodes : (tI18n as TI18n).update;\n    const bindingsStartIndex = getBindingIndex() - changeMaskCounter - 1;\n    applyUpdateOpCodes(tView, lView, updateOpCodes, bindingsStartIndex, changeMask);\n  }\n  // Reset changeMask & maskBit to default for the next update cycle\n  changeMask = 0b0;\n  changeMaskCounter = 0;\n}\n\n\n/**\n * Apply `I18nCreateOpCodes` op-codes as stored in `TI18n.create`.\n *\n * Creates text (and comment) nodes which are internationalized.\n *\n * @param lView Current lView\n * @param createOpCodes Set of op-codes to apply\n * @param parentRNode Parent node (so that direct children can be added eagerly) or `null` if it is\n *     a root node.\n * @param insertInFrontOf DOM node that should be used as an anchor.\n */\nexport function applyCreateOpCodes(\n    lView: LView, createOpCodes: I18nCreateOpCodes, parentRNode: RElement|null,\n    insertInFrontOf: RElement|null): void {\n  const renderer = lView[RENDERER];\n  for (let i = 0; i < createOpCodes.length; i++) {\n    const opCode = createOpCodes[i++] as any;\n    const text = createOpCodes[i] as string;\n    const isComment = (opCode & I18nCreateOpCode.COMMENT) === I18nCreateOpCode.COMMENT;\n    const appendNow =\n        (opCode & I18nCreateOpCode.APPEND_EAGERLY) === I18nCreateOpCode.APPEND_EAGERLY;\n    const index = opCode >>> I18nCreateOpCode.SHIFT;\n    let rNode = lView[index];\n    if (rNode === null) {\n      // We only create new DOM nodes if they don't already exist: If ICU switches case back to a\n      // case which was already instantiated, no need to create new DOM nodes.\n      rNode = lView[index] =\n          isComment ? renderer.createComment(text) : createTextNode(renderer, text);\n    }\n    if (appendNow && parentRNode !== null) {\n      nativeInsertBefore(renderer, parentRNode, rNode, insertInFrontOf, false);\n    }\n  }\n}\n\n/**\n * Apply `I18nMutateOpCodes` OpCodes.\n *\n * @param tView Current `TView`\n * @param mutableOpCodes Mutable OpCodes to process\n * @param lView Current `LView`\n * @param anchorRNode place where the i18n node should be inserted.\n */\nexport function applyMutableOpCodes(\n    tView: TView, mutableOpCodes: IcuCreateOpCodes, lView: LView, anchorRNode: RNode): void {\n  ngDevMode && assertDomNode(anchorRNode);\n  const renderer = lView[RENDERER];\n  // `rootIdx` represents the node into which all inserts happen.\n  let rootIdx: number|null = null;\n  // `rootRNode` represents the real node into which we insert. This can be different from\n  // `lView[rootIdx]` if we have projection.\n  //  - null we don't have a parent (as can be the case in when we are inserting into a root of\n  //    LView which has no parent.)\n  //  - `RElement` The element representing the root after taking projection into account.\n  let rootRNode!: RElement|null;\n  for (let i = 0; i < mutableOpCodes.length; i++) {\n    const opCode = mutableOpCodes[i];\n    if (typeof opCode == 'string') {\n      const textNodeIndex = mutableOpCodes[++i] as number;\n      if (lView[textNodeIndex] === null) {\n        ngDevMode && ngDevMode.rendererCreateTextNode++;\n        ngDevMode && assertIndexInRange(lView, textNodeIndex);\n        lView[textNodeIndex] = createTextNode(renderer, opCode);\n      }\n    } else if (typeof opCode == 'number') {\n      switch (opCode & IcuCreateOpCode.MASK_INSTRUCTION) {\n        case IcuCreateOpCode.AppendChild:\n          const parentIdx = getParentFromIcuCreateOpCode(opCode);\n          if (rootIdx === null) {\n            // The first operation should save the `rootIdx` because the first operation\n            // must insert into the root. (Only subsequent operations can insert into a dynamic\n            // parent)\n            rootIdx = parentIdx;\n            rootRNode = nativeParentNode(renderer, anchorRNode);\n          }\n          let insertInFrontOf: RNode|null;\n          let parentRNode: RElement|null;\n          if (parentIdx === rootIdx) {\n            insertInFrontOf = anchorRNode;\n            parentRNode = rootRNode;\n          } else {\n            insertInFrontOf = null;\n            parentRNode = unwrapRNode(lView[parentIdx]) as RElement;\n          }\n          // FIXME(misko): Refactor with `processI18nText`\n          if (parentRNode !== null) {\n            // This can happen if the `LView` we are adding to is not attached to a parent `LView`.\n            // In such a case there is no \"root\" we can attach to. This is fine, as we still need to\n            // create the elements. When the `LView` gets later added to a parent these \"root\" nodes\n            // get picked up and added.\n            ngDevMode && assertDomNode(parentRNode);\n            const refIdx = getRefFromIcuCreateOpCode(opCode);\n            ngDevMode && assertGreaterThan(refIdx, HEADER_OFFSET, 'Missing ref');\n            // `unwrapRNode` is not needed here as all of these point to RNodes as part of the i18n\n            // which can't have components.\n            const child = lView[refIdx] as RElement;\n            ngDevMode && assertDomNode(child);\n            nativeInsertBefore(renderer, parentRNode, child, insertInFrontOf, false);\n            const tIcu = getTIcu(tView, refIdx);\n            if (tIcu !== null && typeof tIcu === 'object') {\n              // If we just added a comment node which has ICU then that ICU may have already been\n              // rendered and therefore we need to re-add it here.\n              ngDevMode && assertTIcu(tIcu);\n              const caseIndex = getCurrentICUCaseIndex(tIcu, lView);\n              if (caseIndex !== null) {\n                applyMutableOpCodes(tView, tIcu.create[caseIndex], lView, lView[tIcu.anchorIdx]);\n              }\n            }\n          }\n          break;\n        case IcuCreateOpCode.Attr:\n          const elementNodeIndex = opCode >>> IcuCreateOpCode.SHIFT_REF;\n          const attrName = mutableOpCodes[++i] as string;\n          const attrValue = mutableOpCodes[++i] as string;\n          // This code is used for ICU expressions only, since we don't support\n          // directives/components in ICUs, we don't need to worry about inputs here\n          setElementAttribute(\n              renderer, getNativeByIndex(elementNodeIndex, lView) as RElement, null, null, attrName,\n              attrValue, null);\n          break;\n        default:\n          if (ngDevMode) {\n            throw new RuntimeError(\n                RuntimeErrorCode.INVALID_I18N_STRUCTURE,\n                `Unable to determine the type of mutate operation for \"${opCode}\"`);\n          }\n      }\n    } else {\n      switch (opCode) {\n        case ICU_MARKER:\n          const commentValue = mutableOpCodes[++i] as string;\n          const commentNodeIndex = mutableOpCodes[++i] as number;\n          if (lView[commentNodeIndex] === null) {\n            ngDevMode &&\n                assertEqual(\n                    typeof commentValue, 'string',\n                    `Expected \"${commentValue}\" to be a comment node value`);\n            ngDevMode && ngDevMode.rendererCreateComment++;\n            ngDevMode && assertIndexInExpandoRange(lView, commentNodeIndex);\n            const commentRNode = lView[commentNodeIndex] =\n                createCommentNode(renderer, commentValue);\n            // FIXME(misko): Attaching patch data is only needed for the root (Also add tests)\n            attachPatchData(commentRNode, lView);\n          }\n          break;\n        case ELEMENT_MARKER:\n          const tagName = mutableOpCodes[++i] as string;\n          const elementNodeIndex = mutableOpCodes[++i] as number;\n          if (lView[elementNodeIndex] === null) {\n            ngDevMode &&\n                assertEqual(\n                    typeof tagName, 'string',\n                    `Expected \"${tagName}\" to be an element node tag name`);\n\n            ngDevMode && ngDevMode.rendererCreateElement++;\n            ngDevMode && assertIndexInExpandoRange(lView, elementNodeIndex);\n            const elementRNode = lView[elementNodeIndex] =\n                createElementNode(renderer, tagName, null);\n            // FIXME(misko): Attaching patch data is only needed for the root (Also add tests)\n            attachPatchData(elementRNode, lView);\n          }\n          break;\n        default:\n          ngDevMode &&\n              throwError(`Unable to determine the type of mutate operation for \"${opCode}\"`);\n      }\n    }\n  }\n}\n\n\n/**\n * Apply `I18nUpdateOpCodes` OpCodes\n *\n * @param tView Current `TView`\n * @param lView Current `LView`\n * @param updateOpCodes OpCodes to process\n * @param bindingsStartIndex Location of the first `i18nApply`\n * @param changeMask Each bit corresponds to a `i18nExp` (Counting backwards from\n *     `bindingsStartIndex`)\n */\nexport function applyUpdateOpCodes(\n    tView: TView, lView: LView, updateOpCodes: I18nUpdateOpCodes, bindingsStartIndex: number,\n    changeMask: number) {\n  for (let i = 0; i < updateOpCodes.length; i++) {\n    // bit code to check if we should apply the next update\n    const checkBit = updateOpCodes[i] as number;\n    // Number of opCodes to skip until next set of update codes\n    const skipCodes = updateOpCodes[++i] as number;\n    if (checkBit & changeMask) {\n      // The value has been updated since last checked\n      let value = '';\n      for (let j = i + 1; j <= (i + skipCodes); j++) {\n        const opCode = updateOpCodes[j];\n        if (typeof opCode == 'string') {\n          value += opCode;\n        } else if (typeof opCode == 'number') {\n          if (opCode < 0) {\n            // Negative opCode represent `i18nExp` values offset.\n            value += renderStringify(lView[bindingsStartIndex - opCode]);\n          } else {\n            const nodeIndex = (opCode >>> I18nUpdateOpCode.SHIFT_REF);\n            switch (opCode & I18nUpdateOpCode.MASK_OPCODE) {\n              case I18nUpdateOpCode.Attr:\n                const propName = updateOpCodes[++j] as string;\n                const sanitizeFn = updateOpCodes[++j] as SanitizerFn | null;\n                const tNodeOrTagName = tView.data[nodeIndex] as TNode | string;\n                ngDevMode && assertDefined(tNodeOrTagName, 'Experting TNode or string');\n                if (typeof tNodeOrTagName === 'string') {\n                  // IF we don't have a `TNode`, then we are an element in ICU (as ICU content does\n                  // not have TNode), in which case we know that there are no directives, and hence\n                  // we use attribute setting.\n                  setElementAttribute(\n                      lView[RENDERER], lView[nodeIndex], null, tNodeOrTagName, propName, value,\n                      sanitizeFn);\n                } else {\n                  elementPropertyInternal(\n                      tView, tNodeOrTagName, lView, propName, value, lView[RENDERER], sanitizeFn,\n                      false);\n                }\n                break;\n              case I18nUpdateOpCode.Text:\n                const rText = lView[nodeIndex] as RText | null;\n                rText !== null && updateTextNode(lView[RENDERER], rText, value);\n                break;\n              case I18nUpdateOpCode.IcuSwitch:\n                applyIcuSwitchCase(tView, getTIcu(tView, nodeIndex)!, lView, value);\n                break;\n              case I18nUpdateOpCode.IcuUpdate:\n                applyIcuUpdateCase(tView, getTIcu(tView, nodeIndex)!, bindingsStartIndex, lView);\n                break;\n            }\n          }\n        }\n      }\n    } else {\n      const opCode = updateOpCodes[i + 1] as number;\n      if (opCode > 0 && (opCode & I18nUpdateOpCode.MASK_OPCODE) === I18nUpdateOpCode.IcuUpdate) {\n        // Special case for the `icuUpdateCase`. It could be that the mask did not match, but\n        // we still need to execute `icuUpdateCase` because the case has changed recently due to\n        // previous `icuSwitchCase` instruction. (`icuSwitchCase` and `icuUpdateCase` always come in\n        // pairs.)\n        const nodeIndex = (opCode >>> I18nUpdateOpCode.SHIFT_REF);\n        const tIcu = getTIcu(tView, nodeIndex)!;\n        const currentIndex = lView[tIcu.currentCaseLViewIndex];\n        if (currentIndex < 0) {\n          applyIcuUpdateCase(tView, tIcu, bindingsStartIndex, lView);\n        }\n      }\n    }\n    i += skipCodes;\n  }\n}\n\n/**\n * Apply OpCodes associated with updating an existing ICU.\n *\n * @param tView Current `TView`\n * @param tIcu Current `TIcu`\n * @param bindingsStartIndex Location of the first `i18nApply`\n * @param lView Current `LView`\n */\nfunction applyIcuUpdateCase(tView: TView, tIcu: TIcu, bindingsStartIndex: number, lView: LView) {\n  ngDevMode && assertIndexInRange(lView, tIcu.currentCaseLViewIndex);\n  let activeCaseIndex = lView[tIcu.currentCaseLViewIndex];\n  if (activeCaseIndex !== null) {\n    let mask = changeMask;\n    if (activeCaseIndex < 0) {\n      // Clear the flag.\n      // Negative number means that the ICU was freshly created and we need to force the update.\n      activeCaseIndex = lView[tIcu.currentCaseLViewIndex] = ~activeCaseIndex;\n      // -1 is same as all bits on, which simulates creation since it marks all bits dirty\n      mask = -1;\n    }\n    applyUpdateOpCodes(tView, lView, tIcu.update[activeCaseIndex], bindingsStartIndex, mask);\n  }\n}\n\n/**\n * Apply OpCodes associated with switching a case on ICU.\n *\n * This involves tearing down existing case and than building up a new case.\n *\n * @param tView Current `TView`\n * @param tIcu Current `TIcu`\n * @param lView Current `LView`\n * @param value Value of the case to update to.\n */\nfunction applyIcuSwitchCase(tView: TView, tIcu: TIcu, lView: LView, value: string) {\n  // Rebuild a new case for this ICU\n  const caseIndex = getCaseIndex(tIcu, value);\n  let activeCaseIndex = getCurrentICUCaseIndex(tIcu, lView);\n  if (activeCaseIndex !== caseIndex) {\n    applyIcuSwitchCaseRemove(tView, tIcu, lView);\n    lView[tIcu.currentCaseLViewIndex] = caseIndex === null ? null : ~caseIndex;\n    if (caseIndex !== null) {\n      // Add the nodes for the new case\n      const anchorRNode = lView[tIcu.anchorIdx];\n      if (anchorRNode) {\n        ngDevMode && assertDomNode(anchorRNode);\n        applyMutableOpCodes(tView, tIcu.create[caseIndex], lView, anchorRNode);\n      }\n    }\n  }\n}\n\n/**\n * Apply OpCodes associated with tearing ICU case.\n *\n * This involves tearing down existing case and than building up a new case.\n *\n * @param tView Current `TView`\n * @param tIcu Current `TIcu`\n * @param lView Current `LView`\n */\nfunction applyIcuSwitchCaseRemove(tView: TView, tIcu: TIcu, lView: LView) {\n  let activeCaseIndex = getCurrentICUCaseIndex(tIcu, lView);\n  if (activeCaseIndex !== null) {\n    const removeCodes = tIcu.remove[activeCaseIndex];\n    for (let i = 0; i < removeCodes.length; i++) {\n      const nodeOrIcuIndex = removeCodes[i] as number;\n      if (nodeOrIcuIndex > 0) {\n        // Positive numbers are `RNode`s.\n        const rNode = getNativeByIndex(nodeOrIcuIndex, lView);\n        rNode !== null && nativeRemoveNode(lView[RENDERER], rNode);\n      } else {\n        // Negative numbers are ICUs\n        applyIcuSwitchCaseRemove(tView, getTIcu(tView, ~nodeOrIcuIndex)!, lView);\n      }\n    }\n  }\n}\n\n\n/**\n * Returns the index of the current case of an ICU expression depending on the main binding value\n *\n * @param icuExpression\n * @param bindingValue The value of the main binding used by this ICU expression\n */\nfunction getCaseIndex(icuExpression: TIcu, bindingValue: string): number|null {\n  let index = icuExpression.cases.indexOf(bindingValue);\n  if (index === -1) {\n    switch (icuExpression.type) {\n      case IcuType.plural: {\n        const resolvedCase = getPluralCase(bindingValue, getLocaleId());\n        index = icuExpression.cases.indexOf(resolvedCase);\n        if (index === -1 && resolvedCase !== 'other') {\n          index = icuExpression.cases.indexOf('other');\n        }\n        break;\n      }\n      case IcuType.select: {\n        index = icuExpression.cases.indexOf('other');\n        break;\n      }\n    }\n  }\n  return index === -1 ? null : index;\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {assertDomNode, assertNumber, assertNumberInRange} from '../../util/assert';\nimport {EMPTY_ARRAY} from '../../util/empty';\nimport {assertTIcu, assertTNodeForLView} from '../assert';\nimport {getCurrentICUCaseIndex} from '../i18n/i18n_util';\nimport {I18nRemoveOpCodes, TIcu} from '../interfaces/i18n';\nimport {TIcuContainerNode} from '../interfaces/node';\nimport {RNode} from '../interfaces/renderer_dom';\nimport {LView, TVIEW} from '../interfaces/view';\n\nexport function loadIcuContainerVisitor() {\n  const _stack: any[] = [];\n  let _index: number = -1;\n  let _lView: LView;\n  let _removes: I18nRemoveOpCodes;\n\n  /**\n   * Retrieves a set of root nodes from `TIcu.remove`. Used by `TNodeType.ICUContainer`\n   * to determine which root belong to the ICU.\n   *\n   * Example of usage.\n   * ```\n   * const nextRNode = icuContainerIteratorStart(tIcuContainerNode, lView);\n   * let rNode: RNode|null;\n   * while(rNode = nextRNode()) {\n   *   console.log(rNode);\n   * }\n   * ```\n   *\n   * @param tIcuContainerNode Current `TIcuContainerNode`\n   * @param lView `LView` where the `RNode`s should be looked up.\n   */\n  function icuContainerIteratorStart(tIcuContainerNode: TIcuContainerNode, lView: LView): () =>\n      RNode | null {\n    _lView = lView;\n    while (_stack.length) _stack.pop();\n    ngDevMode && assertTNodeForLView(tIcuContainerNode, lView);\n    enterIcu(tIcuContainerNode.value, lView);\n    return icuContainerIteratorNext;\n  }\n\n  function enterIcu(tIcu: TIcu, lView: LView) {\n    _index = 0;\n    const currentCase = getCurrentICUCaseIndex(tIcu, lView);\n    if (currentCase !== null) {\n      ngDevMode && assertNumberInRange(currentCase, 0, tIcu.cases.length - 1);\n      _removes = tIcu.remove[currentCase];\n    } else {\n      _removes = EMPTY_ARRAY as any;\n    }\n  }\n\n\n  function icuContainerIteratorNext(): RNode|null {\n    if (_index < _removes.length) {\n      const removeOpCode = _removes[_index++] as number;\n      ngDevMode && assertNumber(removeOpCode, 'Expecting OpCode number');\n      if (removeOpCode > 0) {\n        const rNode = _lView[removeOpCode];\n        ngDevMode && assertDomNode(rNode);\n        return rNode;\n      } else {\n        _stack.push(_index, _removes);\n        // ICUs are represented by negative indices\n        const tIcuIndex = ~removeOpCode;\n        const tIcu = _lView[TVIEW].data[tIcuIndex] as TIcu;\n        ngDevMode && assertTIcu(tIcu);\n        enterIcu(tIcu, _lView);\n        return icuContainerIteratorNext();\n      }\n    } else {\n      if (_stack.length === 0) {\n        return null;\n      } else {\n        _removes = _stack.pop();\n        _index = _stack.pop();\n        return icuContainerIteratorNext();\n      }\n    }\n  }\n\n  return icuContainerIteratorStart;\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport '../../util/ng_dev_mode';\nimport '../../util/ng_i18n_closure_mode';\n\nimport {XSS_SECURITY_URL} from '../../error_details_base_url';\nimport {getTemplateContent, URI_ATTRS, VALID_ATTRS, VALID_ELEMENTS} from '../../sanitization/html_sanitizer';\nimport {getInertBodyHelper} from '../../sanitization/inert_body';\nimport {_sanitizeUrl} from '../../sanitization/url_sanitizer';\nimport {assertDefined, assertEqual, assertGreaterThanOrEqual, assertOneOf, assertString} from '../../util/assert';\nimport {CharCode} from '../../util/char_code';\nimport {loadIcuContainerVisitor} from '../instructions/i18n_icu_container_visitor';\nimport {allocExpando, createTNodeAtIndex} from '../instructions/shared';\nimport {getDocument} from '../interfaces/document';\nimport {ELEMENT_MARKER, I18nCreateOpCode, I18nCreateOpCodes, I18nRemoveOpCodes, I18nUpdateOpCode, I18nUpdateOpCodes, ICU_MARKER, IcuCreateOpCode, IcuCreateOpCodes, IcuExpression, IcuType, TI18n, TIcu} from '../interfaces/i18n';\nimport {TNode, TNodeType} from '../interfaces/node';\nimport {SanitizerFn} from '../interfaces/sanitization';\nimport {HEADER_OFFSET, LView, TView} from '../interfaces/view';\nimport {getCurrentParentTNode, getCurrentTNode, setCurrentTNode} from '../state';\n\nimport {i18nCreateOpCodesToString, i18nRemoveOpCodesToString, i18nUpdateOpCodesToString, icuCreateOpCodesToString} from './i18n_debug';\nimport {addTNodeAndUpdateInsertBeforeIndex} from './i18n_insert_before_index';\nimport {ensureIcuContainerVisitorLoaded} from './i18n_tree_shaking';\nimport {createTNodePlaceholder, icuCreateOpCode, setTIcu, setTNodeInsertBeforeIndex} from './i18n_util';\n\n\n\nconst BINDING_REGEXP = /(\\d+):?\\d*/gi;\nconst ICU_REGEXP = /({\\s*\\d+:?\\d*\\s*,\\s*\\S{6}\\s*,[\\s\\S]*})/gi;\nconst NESTED_ICU = /(\\d+)/;\nconst ICU_BLOCK_REGEXP = /^\\s*(\\d+:?\\d*)\\s*,\\s*(select|plural)\\s*,/;\n\nconst MARKER = ``;\nconst SUBTEMPLATE_REGEXP = /\\/?\\*(\\d+:\\d+)/gi;\nconst PH_REGEXP = /(\\/?[#*]\\d+):?\\d*/gi;\n\n/**\n * Angular Dart introduced &ngsp; as a placeholder for non-removable space, see:\n * https://github.com/dart-lang/angular/blob/0bb611387d29d65b5af7f9d2515ab571fd3fbee4/_tests/test/compiler/preserve_whitespace_test.dart#L25-L32\n * In Angular Dart &ngsp; is converted to the 0xE500 PUA (Private Use Areas) unicode character\n * and later on replaced by a space. We are re-implementing the same idea here, since translations\n * might contain this special character.\n */\nconst NGSP_UNICODE_REGEXP = /\\uE500/g;\nfunction replaceNgsp(value: string): string {\n  return value.replace(NGSP_UNICODE_REGEXP, ' ');\n}\n\n/**\n * Patch a `debug` property getter on top of the existing object.\n *\n * NOTE: always call this method with `ngDevMode && attachDebugObject(...)`\n *\n * @param obj Object to patch\n * @param debugGetter Getter returning a value to patch\n */\nfunction attachDebugGetter<T>(obj: T, debugGetter: (this: T) => any): void {\n  if (ngDevMode) {\n    Object.defineProperty(obj, 'debug', {get: debugGetter, enumerable: false});\n  } else {\n    throw new Error(\n        'This method should be guarded with `ngDevMode` so that it can be tree shaken in production!');\n  }\n}\n\n/**\n * Create dynamic nodes from i18n translation block.\n *\n * - Text nodes are created synchronously\n * - TNodes are linked into tree lazily\n *\n * @param tView Current `TView`\n * @parentTNodeIndex index to the parent TNode of this i18n block\n * @param lView Current `LView`\n * @param index Index of `i18nStart` instruction.\n * @param message Message to translate.\n * @param subTemplateIndex Index into the sub template of message translation. (ie in case of\n *     `ngIf`) (-1 otherwise)\n */\nexport function i18nStartFirstCreatePass(\n    tView: TView, parentTNodeIndex: number, lView: LView, index: number, message: string,\n    subTemplateIndex: number) {\n  const rootTNode = getCurrentParentTNode();\n  const createOpCodes: I18nCreateOpCodes = [] as any;\n  const updateOpCodes: I18nUpdateOpCodes = [] as any;\n  const existingTNodeStack: TNode[][] = [[]];\n  if (ngDevMode) {\n    attachDebugGetter(createOpCodes, i18nCreateOpCodesToString);\n    attachDebugGetter(updateOpCodes, i18nUpdateOpCodesToString);\n  }\n\n  message = getTranslationForTemplate(message, subTemplateIndex);\n  const msgParts = replaceNgsp(message).split(PH_REGEXP);\n  for (let i = 0; i < msgParts.length; i++) {\n    let value = msgParts[i];\n    if ((i & 1) === 0) {\n      // Even indexes are text (including bindings & ICU expressions)\n      const parts = i18nParseTextIntoPartsAndICU(value);\n      for (let j = 0; j < parts.length; j++) {\n        let part = parts[j];\n        if ((j & 1) === 0) {\n          // `j` is odd therefore `part` is string\n          const text = part as string;\n          ngDevMode && assertString(text, 'Parsed ICU part should be string');\n          if (text !== '') {\n            i18nStartFirstCreatePassProcessTextNode(\n                tView, rootTNode, existingTNodeStack[0], createOpCodes, updateOpCodes, lView, text);\n          }\n        } else {\n          // `j` is Even therefor `part` is an `ICUExpression`\n          const icuExpression: IcuExpression = part as IcuExpression;\n          // Verify that ICU expression has the right shape. Translations might contain invalid\n          // constructions (while original messages were correct), so ICU parsing at runtime may\n          // not succeed (thus `icuExpression` remains a string).\n          // Note: we intentionally retain the error here by not using `ngDevMode`, because\n          // the value can change based on the locale and users aren't guaranteed to hit\n          // an invalid string while they're developing.\n          if (typeof icuExpression !== 'object') {\n            throw new Error(`Unable to parse ICU expression in \"${message}\" message.`);\n          }\n          const icuContainerTNode = createTNodeAndAddOpCode(\n              tView, rootTNode, existingTNodeStack[0], lView, createOpCodes,\n              ngDevMode ? `ICU ${index}:${icuExpression.mainBinding}` : '', true);\n          const icuNodeIndex = icuContainerTNode.index;\n          ngDevMode &&\n              assertGreaterThanOrEqual(\n                  icuNodeIndex, HEADER_OFFSET, 'Index must be in absolute LView offset');\n          icuStart(tView, lView, updateOpCodes, parentTNodeIndex, icuExpression, icuNodeIndex);\n        }\n      }\n    } else {\n      // Odd indexes are placeholders (elements and sub-templates)\n      // At this point value is something like: '/#1:2' (originally coming from '/#1:2')\n      const isClosing = value.charCodeAt(0) === CharCode.SLASH;\n      const type = value.charCodeAt(isClosing ? 1 : 0);\n      ngDevMode && assertOneOf(type, CharCode.STAR, CharCode.HASH);\n      const index = HEADER_OFFSET + Number.parseInt(value.substring((isClosing ? 2 : 1)));\n      if (isClosing) {\n        existingTNodeStack.shift();\n        setCurrentTNode(getCurrentParentTNode()!, false);\n      } else {\n        const tNode = createTNodePlaceholder(tView, existingTNodeStack[0], index);\n        existingTNodeStack.unshift([]);\n        setCurrentTNode(tNode, true);\n      }\n    }\n  }\n\n  tView.data[index] = <TI18n>{\n    create: createOpCodes,\n    update: updateOpCodes,\n  };\n}\n\n/**\n * Allocate space in i18n Range add create OpCode instruction to create a text or comment node.\n *\n * @param tView Current `TView` needed to allocate space in i18n range.\n * @param rootTNode Root `TNode` of the i18n block. This node determines if the new TNode will be\n *     added as part of the `i18nStart` instruction or as part of the `TNode.insertBeforeIndex`.\n * @param existingTNodes internal state for `addTNodeAndUpdateInsertBeforeIndex`.\n * @param lView Current `LView` needed to allocate space in i18n range.\n * @param createOpCodes Array storing `I18nCreateOpCodes` where new opCodes will be added.\n * @param text Text to be added when the `Text` or `Comment` node will be created.\n * @param isICU true if a `Comment` node for ICU (instead of `Text`) node should be created.\n */\nfunction createTNodeAndAddOpCode(\n    tView: TView, rootTNode: TNode|null, existingTNodes: TNode[], lView: LView,\n    createOpCodes: I18nCreateOpCodes, text: string|null, isICU: boolean): TNode {\n  const i18nNodeIdx = allocExpando(tView, lView, 1, null);\n  let opCode = i18nNodeIdx << I18nCreateOpCode.SHIFT;\n  let parentTNode = getCurrentParentTNode();\n\n  if (rootTNode === parentTNode) {\n    // FIXME(misko): A null `parentTNode` should represent when we fall of the `LView` boundary.\n    // (there is no parent), but in some circumstances (because we are inconsistent about how we set\n    // `previousOrParentTNode`) it could point to `rootTNode` So this is a work around.\n    parentTNode = null;\n  }\n  if (parentTNode === null) {\n    // If we don't have a parent that means that we can eagerly add nodes.\n    // If we have a parent than these nodes can't be added now (as the parent has not been created\n    // yet) and instead the `parentTNode` is responsible for adding it. See\n    // `TNode.insertBeforeIndex`\n    opCode |= I18nCreateOpCode.APPEND_EAGERLY;\n  }\n  if (isICU) {\n    opCode |= I18nCreateOpCode.COMMENT;\n    ensureIcuContainerVisitorLoaded(loadIcuContainerVisitor);\n  }\n  createOpCodes.push(opCode, text === null ? '' : text);\n  // We store `{{?}}` so that when looking at debug `TNodeType.template` we can see where the\n  // bindings are.\n  const tNode = createTNodeAtIndex(\n      tView, i18nNodeIdx, isICU ? TNodeType.Icu : TNodeType.Text,\n      text === null ? (ngDevMode ? '{{?}}' : '') : text, null);\n  addTNodeAndUpdateInsertBeforeIndex(existingTNodes, tNode);\n  const tNodeIdx = tNode.index;\n  setCurrentTNode(tNode, false /* Text nodes are self closing */);\n  if (parentTNode !== null && rootTNode !== parentTNode) {\n    // We are a child of deeper node (rather than a direct child of `i18nStart` instruction.)\n    // We have to make sure to add ourselves to the parent.\n    setTNodeInsertBeforeIndex(parentTNode, tNodeIdx);\n  }\n  return tNode;\n}\n\n/**\n * Processes text node in i18n block.\n *\n * Text nodes can have:\n * - Create instruction in `createOpCodes` for creating the text node.\n * - Allocate spec for text node in i18n range of `LView`\n * - If contains binding:\n *    - bindings => allocate space in i18n range of `LView` to store the binding value.\n *    - populate `updateOpCodes` with update instructions.\n *\n * @param tView Current `TView`\n * @param rootTNode Root `TNode` of the i18n block. This node determines if the new TNode will\n *     be added as part of the `i18nStart` instruction or as part of the\n *     `TNode.insertBeforeIndex`.\n * @param existingTNodes internal state for `addTNodeAndUpdateInsertBeforeIndex`.\n * @param createOpCodes Location where the creation OpCodes will be stored.\n * @param lView Current `LView`\n * @param text The translated text (which may contain binding)\n */\nfunction i18nStartFirstCreatePassProcessTextNode(\n    tView: TView, rootTNode: TNode|null, existingTNodes: TNode[], createOpCodes: I18nCreateOpCodes,\n    updateOpCodes: I18nUpdateOpCodes, lView: LView, text: string): void {\n  const hasBinding = text.match(BINDING_REGEXP);\n  const tNode = createTNodeAndAddOpCode(\n      tView, rootTNode, existingTNodes, lView, createOpCodes, hasBinding ? null : text, false);\n  if (hasBinding) {\n    generateBindingUpdateOpCodes(updateOpCodes, text, tNode.index, null, 0, null);\n  }\n}\n\n/**\n * See `i18nAttributes` above.\n */\nexport function i18nAttributesFirstPass(tView: TView, index: number, values: string[]) {\n  const previousElement = getCurrentTNode()!;\n  const previousElementIndex = previousElement.index;\n  const updateOpCodes: I18nUpdateOpCodes = [] as any;\n  if (ngDevMode) {\n    attachDebugGetter(updateOpCodes, i18nUpdateOpCodesToString);\n  }\n  if (tView.firstCreatePass && tView.data[index] === null) {\n    for (let i = 0; i < values.length; i += 2) {\n      const attrName = values[i];\n      const message = values[i + 1];\n\n      if (message !== '') {\n        // Check if attribute value contains an ICU and throw an error if that's the case.\n        // ICUs in element attributes are not supported.\n        // Note: we intentionally retain the error here by not using `ngDevMode`, because\n        // the `value` can change based on the locale and users aren't guaranteed to hit\n        // an invalid string while they're developing.\n        if (ICU_REGEXP.test(message)) {\n          throw new Error(\n              `ICU expressions are not supported in attributes. Message: \"${message}\".`);\n        }\n\n        // i18n attributes that hit this code path are guaranteed to have bindings, because\n        // the compiler treats static i18n attributes as regular attribute bindings.\n        // Since this may not be the first i18n attribute on this element we need to pass in how\n        // many previous bindings there have already been.\n        generateBindingUpdateOpCodes(\n            updateOpCodes, message, previousElementIndex, attrName, countBindings(updateOpCodes),\n            null);\n      }\n    }\n    tView.data[index] = updateOpCodes;\n  }\n}\n\n\n/**\n * Generate the OpCodes to update the bindings of a string.\n *\n * @param updateOpCodes Place where the update opcodes will be stored.\n * @param str The string containing the bindings.\n * @param destinationNode Index of the destination node which will receive the binding.\n * @param attrName Name of the attribute, if the string belongs to an attribute.\n * @param sanitizeFn Sanitization function used to sanitize the string after update, if necessary.\n * @param bindingStart The lView index of the next expression that can be bound via an opCode.\n * @returns The mask value for these bindings\n */\nfunction generateBindingUpdateOpCodes(\n    updateOpCodes: I18nUpdateOpCodes, str: string, destinationNode: number, attrName: string|null,\n    bindingStart: number, sanitizeFn: SanitizerFn|null): number {\n  ngDevMode &&\n      assertGreaterThanOrEqual(\n          destinationNode, HEADER_OFFSET, 'Index must be in absolute LView offset');\n  const maskIndex = updateOpCodes.length;  // Location of mask\n  const sizeIndex = maskIndex + 1;         // location of size for skipping\n  updateOpCodes.push(null, null);          // Alloc space for mask and size\n  const startIndex = maskIndex + 2;        // location of first allocation.\n  if (ngDevMode) {\n    attachDebugGetter(updateOpCodes, i18nUpdateOpCodesToString);\n  }\n  const textParts = str.split(BINDING_REGEXP);\n  let mask = 0;\n\n  for (let j = 0; j < textParts.length; j++) {\n    const textValue = textParts[j];\n\n    if (j & 1) {\n      // Odd indexes are bindings\n      const bindingIndex = bindingStart + parseInt(textValue, 10);\n      updateOpCodes.push(-1 - bindingIndex);\n      mask = mask | toMaskBit(bindingIndex);\n    } else if (textValue !== '') {\n      // Even indexes are text\n      updateOpCodes.push(textValue);\n    }\n  }\n\n  updateOpCodes.push(\n      destinationNode << I18nUpdateOpCode.SHIFT_REF |\n      (attrName ? I18nUpdateOpCode.Attr : I18nUpdateOpCode.Text));\n  if (attrName) {\n    updateOpCodes.push(attrName, sanitizeFn);\n  }\n  updateOpCodes[maskIndex] = mask;\n  updateOpCodes[sizeIndex] = updateOpCodes.length - startIndex;\n  return mask;\n}\n\n/**\n * Count the number of bindings in the given `opCodes`.\n *\n * It could be possible to speed this up, by passing the number of bindings found back from\n * `generateBindingUpdateOpCodes()` to `i18nAttributesFirstPass()` but this would then require more\n * complexity in the code and/or transient objects to be created.\n *\n * Since this function is only called once when the template is instantiated, is trivial in the\n * first instance (since `opCodes` will be an empty array), and it is not common for elements to\n * contain multiple i18n bound attributes, it seems like this is a reasonable compromise.\n */\nfunction countBindings(opCodes: I18nUpdateOpCodes): number {\n  let count = 0;\n  for (let i = 0; i < opCodes.length; i++) {\n    const opCode = opCodes[i];\n    // Bindings are negative numbers.\n    if (typeof opCode === 'number' && opCode < 0) {\n      count++;\n    }\n  }\n  return count;\n}\n\n/**\n * Convert binding index to mask bit.\n *\n * Each index represents a single bit on the bit-mask. Because bit-mask only has 32 bits, we make\n * the 32nd bit share all masks for all bindings higher than 32. Since it is extremely rare to\n * have more than 32 bindings this will be hit very rarely. The downside of hitting this corner\n * case is that we will execute binding code more often than necessary. (penalty of performance)\n */\nfunction toMaskBit(bindingIndex: number): number {\n  return 1 << Math.min(bindingIndex, 31);\n}\n\nexport function isRootTemplateMessage(subTemplateIndex: number): subTemplateIndex is - 1 {\n  return subTemplateIndex === -1;\n}\n\n\n/**\n * Removes everything inside the sub-templates of a message.\n */\nfunction removeInnerTemplateTranslation(message: string): string {\n  let match;\n  let res = '';\n  let index = 0;\n  let inTemplate = false;\n  let tagMatched;\n\n  while ((match = SUBTEMPLATE_REGEXP.exec(message)) !== null) {\n    if (!inTemplate) {\n      res += message.substring(index, match.index + match[0].length);\n      tagMatched = match[1];\n      inTemplate = true;\n    } else {\n      if (match[0] === `${MARKER}/*${tagMatched}${MARKER}`) {\n        index = match.index;\n        inTemplate = false;\n      }\n    }\n  }\n\n  ngDevMode &&\n      assertEqual(\n          inTemplate, false,\n          `Tag mismatch: unable to find the end of the sub-template in the translation \"${\n              message}\"`);\n\n  res += message.slice(index);\n  return res;\n}\n\n\n/**\n * Extracts a part of a message and removes the rest.\n *\n * This method is used for extracting a part of the message associated with a template. A\n * translated message can span multiple templates.\n *\n * Example:\n * ```\n * <div i18n>Translate <span *ngIf>me</span>!</div>\n * ```\n *\n * @param message The message to crop\n * @param subTemplateIndex Index of the sub-template to extract. If undefined it returns the\n * external template and removes all sub-templates.\n */\nexport function getTranslationForTemplate(message: string, subTemplateIndex: number) {\n  if (isRootTemplateMessage(subTemplateIndex)) {\n    // We want the root template message, ignore all sub-templates\n    return removeInnerTemplateTranslation(message);\n  } else {\n    // We want a specific sub-template\n    const start =\n        message.indexOf(`:${subTemplateIndex}${MARKER}`) + 2 + subTemplateIndex.toString().length;\n    const end = message.search(new RegExp(`${MARKER}\\\\/\\\\*\\\\d+:${subTemplateIndex}${MARKER}`));\n    return removeInnerTemplateTranslation(message.substring(start, end));\n  }\n}\n\n/**\n * Generate the OpCodes for ICU expressions.\n *\n * @param icuExpression\n * @param index Index where the anchor is stored and an optional `TIcuContainerNode`\n *   - `lView[anchorIdx]` points to a `Comment` node representing the anchor for the ICU.\n *   - `tView.data[anchorIdx]` points to the `TIcuContainerNode` if ICU is root (`null` otherwise)\n */\nexport function icuStart(\n    tView: TView, lView: LView, updateOpCodes: I18nUpdateOpCodes, parentIdx: number,\n    icuExpression: IcuExpression, anchorIdx: number) {\n  ngDevMode && assertDefined(icuExpression, 'ICU expression must be defined');\n  let bindingMask = 0;\n  const tIcu: TIcu = {\n    type: icuExpression.type,\n    currentCaseLViewIndex: allocExpando(tView, lView, 1, null),\n    anchorIdx,\n    cases: [],\n    create: [],\n    remove: [],\n    update: []\n  };\n  addUpdateIcuSwitch(updateOpCodes, icuExpression, anchorIdx);\n  setTIcu(tView, anchorIdx, tIcu);\n  const values = icuExpression.values;\n  for (let i = 0; i < values.length; i++) {\n    // Each value is an array of strings & other ICU expressions\n    const valueArr = values[i];\n    const nestedIcus: IcuExpression[] = [];\n    for (let j = 0; j < valueArr.length; j++) {\n      const value = valueArr[j];\n      if (typeof value !== 'string') {\n        // It is an nested ICU expression\n        const icuIndex = nestedIcus.push(value as IcuExpression) - 1;\n        // Replace nested ICU expression by a comment node\n        valueArr[j] = `<!--${icuIndex}-->`;\n      }\n    }\n    bindingMask = parseIcuCase(\n                      tView, tIcu, lView, updateOpCodes, parentIdx, icuExpression.cases[i],\n                      valueArr.join(''), nestedIcus) |\n        bindingMask;\n  }\n  if (bindingMask) {\n    addUpdateIcuUpdate(updateOpCodes, bindingMask, anchorIdx);\n  }\n}\n\n/**\n * Parses text containing an ICU expression and produces a JSON object for it.\n * Original code from closure library, modified for Angular.\n *\n * @param pattern Text containing an ICU expression that needs to be parsed.\n *\n */\nexport function parseICUBlock(pattern: string): IcuExpression {\n  const cases = [];\n  const values: (string|IcuExpression)[][] = [];\n  let icuType = IcuType.plural;\n  let mainBinding = 0;\n  pattern = pattern.replace(ICU_BLOCK_REGEXP, function(str: string, binding: string, type: string) {\n    if (type === 'select') {\n      icuType = IcuType.select;\n    } else {\n      icuType = IcuType.plural;\n    }\n    mainBinding = parseInt(binding.slice(1), 10);\n    return '';\n  });\n\n  const parts = i18nParseTextIntoPartsAndICU(pattern) as string[];\n  // Looking for (key block)+ sequence. One of the keys has to be \"other\".\n  for (let pos = 0; pos < parts.length;) {\n    let key = parts[pos++].trim();\n    if (icuType === IcuType.plural) {\n      // Key can be \"=x\", we just want \"x\"\n      key = key.replace(/\\s*(?:=)?(\\w+)\\s*/, '$1');\n    }\n    if (key.length) {\n      cases.push(key);\n    }\n\n    const blocks = i18nParseTextIntoPartsAndICU(parts[pos++]) as string[];\n    if (cases.length > values.length) {\n      values.push(blocks);\n    }\n  }\n\n  // TODO(ocombe): support ICU expressions in attributes, see #21615\n  return {type: icuType, mainBinding: mainBinding, cases, values};\n}\n\n\n/**\n * Breaks pattern into strings and top level {...} blocks.\n * Can be used to break a message into text and ICU expressions, or to break an ICU expression\n * into keys and cases. Original code from closure library, modified for Angular.\n *\n * @param pattern (sub)Pattern to be broken.\n * @returns An `Array<string|IcuExpression>` where:\n *   - odd positions: `string` => text between ICU expressions\n *   - even positions: `ICUExpression` => ICU expression parsed into `ICUExpression` record.\n */\nexport function i18nParseTextIntoPartsAndICU(pattern: string): (string|IcuExpression)[] {\n  if (!pattern) {\n    return [];\n  }\n\n  let prevPos = 0;\n  const braceStack = [];\n  const results: (string|IcuExpression)[] = [];\n  const braces = /[{}]/g;\n  // lastIndex doesn't get set to 0 so we have to.\n  braces.lastIndex = 0;\n\n  let match;\n  while (match = braces.exec(pattern)) {\n    const pos = match.index;\n    if (match[0] == '}') {\n      braceStack.pop();\n\n      if (braceStack.length == 0) {\n        // End of the block.\n        const block = pattern.substring(prevPos, pos);\n        if (ICU_BLOCK_REGEXP.test(block)) {\n          results.push(parseICUBlock(block));\n        } else {\n          results.push(block);\n        }\n\n        prevPos = pos + 1;\n      }\n    } else {\n      if (braceStack.length == 0) {\n        const substring = pattern.substring(prevPos, pos);\n        results.push(substring);\n        prevPos = pos + 1;\n      }\n      braceStack.push('{');\n    }\n  }\n\n  const substring = pattern.substring(prevPos);\n  results.push(substring);\n  return results;\n}\n\n\n/**\n * Parses a node, its children and its siblings, and generates the mutate & update OpCodes.\n *\n */\nexport function parseIcuCase(\n    tView: TView, tIcu: TIcu, lView: LView, updateOpCodes: I18nUpdateOpCodes, parentIdx: number,\n    caseName: string, unsafeCaseHtml: string, nestedIcus: IcuExpression[]): number {\n  const create: IcuCreateOpCodes = [] as any;\n  const remove: I18nRemoveOpCodes = [] as any;\n  const update: I18nUpdateOpCodes = [] as any;\n  if (ngDevMode) {\n    attachDebugGetter(create, icuCreateOpCodesToString);\n    attachDebugGetter(remove, i18nRemoveOpCodesToString);\n    attachDebugGetter(update, i18nUpdateOpCodesToString);\n  }\n  tIcu.cases.push(caseName);\n  tIcu.create.push(create);\n  tIcu.remove.push(remove);\n  tIcu.update.push(update);\n\n  const inertBodyHelper = getInertBodyHelper(getDocument());\n  const inertBodyElement = inertBodyHelper.getInertBodyElement(unsafeCaseHtml);\n  ngDevMode && assertDefined(inertBodyElement, 'Unable to generate inert body element');\n  const inertRootNode = getTemplateContent(inertBodyElement!) as Element || inertBodyElement;\n  if (inertRootNode) {\n    return walkIcuTree(\n        tView, tIcu, lView, updateOpCodes, create, remove, update, inertRootNode, parentIdx,\n        nestedIcus, 0);\n  } else {\n    return 0;\n  }\n}\n\nfunction walkIcuTree(\n    tView: TView, tIcu: TIcu, lView: LView, sharedUpdateOpCodes: I18nUpdateOpCodes,\n    create: IcuCreateOpCodes, remove: I18nRemoveOpCodes, update: I18nUpdateOpCodes,\n    parentNode: Element, parentIdx: number, nestedIcus: IcuExpression[], depth: number): number {\n  let bindingMask = 0;\n  let currentNode = parentNode.firstChild;\n  while (currentNode) {\n    const newIndex = allocExpando(tView, lView, 1, null);\n    switch (currentNode.nodeType) {\n      case Node.ELEMENT_NODE:\n        const element = currentNode as Element;\n        const tagName = element.tagName.toLowerCase();\n        if (VALID_ELEMENTS.hasOwnProperty(tagName)) {\n          addCreateNodeAndAppend(create, ELEMENT_MARKER, tagName, parentIdx, newIndex);\n          tView.data[newIndex] = tagName;\n          const elAttrs = element.attributes;\n          for (let i = 0; i < elAttrs.length; i++) {\n            const attr = elAttrs.item(i)!;\n            const lowerAttrName = attr.name.toLowerCase();\n            const hasBinding = !!attr.value.match(BINDING_REGEXP);\n            // we assume the input string is safe, unless it's using a binding\n            if (hasBinding) {\n              if (VALID_ATTRS.hasOwnProperty(lowerAttrName)) {\n                if (URI_ATTRS[lowerAttrName]) {\n                  generateBindingUpdateOpCodes(\n                      update, attr.value, newIndex, attr.name, 0, _sanitizeUrl);\n                } else {\n                  generateBindingUpdateOpCodes(update, attr.value, newIndex, attr.name, 0, null);\n                }\n              } else {\n                ngDevMode &&\n                    console.warn(\n                        `WARNING: ignoring unsafe attribute value ` +\n                        `${lowerAttrName} on element ${tagName} ` +\n                        `(see ${XSS_SECURITY_URL})`);\n              }\n            } else {\n              addCreateAttribute(create, newIndex, attr);\n            }\n          }\n          // Parse the children of this node (if any)\n          bindingMask = walkIcuTree(\n                            tView, tIcu, lView, sharedUpdateOpCodes, create, remove, update,\n                            currentNode as Element, newIndex, nestedIcus, depth + 1) |\n              bindingMask;\n          addRemoveNode(remove, newIndex, depth);\n        }\n        break;\n      case Node.TEXT_NODE:\n        const value = currentNode.textContent || '';\n        const hasBinding = value.match(BINDING_REGEXP);\n        addCreateNodeAndAppend(create, null, hasBinding ? '' : value, parentIdx, newIndex);\n        addRemoveNode(remove, newIndex, depth);\n        if (hasBinding) {\n          bindingMask =\n              generateBindingUpdateOpCodes(update, value, newIndex, null, 0, null) | bindingMask;\n        }\n        break;\n      case Node.COMMENT_NODE:\n        // Check if the comment node is a placeholder for a nested ICU\n        const isNestedIcu = NESTED_ICU.exec(currentNode.textContent || '');\n        if (isNestedIcu) {\n          const nestedIcuIndex = parseInt(isNestedIcu[1], 10);\n          const icuExpression: IcuExpression = nestedIcus[nestedIcuIndex];\n          // Create the comment node that will anchor the ICU expression\n          addCreateNodeAndAppend(\n              create, ICU_MARKER, ngDevMode ? `nested ICU ${nestedIcuIndex}` : '', parentIdx,\n              newIndex);\n          icuStart(tView, lView, sharedUpdateOpCodes, parentIdx, icuExpression, newIndex);\n          addRemoveNestedIcu(remove, newIndex, depth);\n        }\n        break;\n    }\n    currentNode = currentNode.nextSibling;\n  }\n  return bindingMask;\n}\n\nfunction addRemoveNode(remove: I18nRemoveOpCodes, index: number, depth: number) {\n  if (depth === 0) {\n    remove.push(index);\n  }\n}\n\nfunction addRemoveNestedIcu(remove: I18nRemoveOpCodes, index: number, depth: number) {\n  if (depth === 0) {\n    remove.push(~index);  // remove ICU at `index`\n    remove.push(index);   // remove ICU comment at `index`\n  }\n}\n\nfunction addUpdateIcuSwitch(\n    update: I18nUpdateOpCodes, icuExpression: IcuExpression, index: number) {\n  update.push(\n      toMaskBit(icuExpression.mainBinding), 2, -1 - icuExpression.mainBinding,\n      index << I18nUpdateOpCode.SHIFT_REF | I18nUpdateOpCode.IcuSwitch);\n}\n\nfunction addUpdateIcuUpdate(update: I18nUpdateOpCodes, bindingMask: number, index: number) {\n  update.push(bindingMask, 1, index << I18nUpdateOpCode.SHIFT_REF | I18nUpdateOpCode.IcuUpdate);\n}\n\nfunction addCreateNodeAndAppend(\n    create: IcuCreateOpCodes, marker: null|ICU_MARKER|ELEMENT_MARKER, text: string,\n    appendToParentIdx: number, createAtIdx: number) {\n  if (marker !== null) {\n    create.push(marker);\n  }\n  create.push(\n      text, createAtIdx,\n      icuCreateOpCode(IcuCreateOpCode.AppendChild, appendToParentIdx, createAtIdx));\n}\n\nfunction addCreateAttribute(create: IcuCreateOpCodes, newIndex: number, attr: Attr) {\n  create.push(newIndex << IcuCreateOpCode.SHIFT_REF | IcuCreateOpCode.Attr, attr.name, attr.value);\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n// i18nPostprocess consts\nconst ROOT_TEMPLATE_ID = 0;\nconst PP_MULTI_VALUE_PLACEHOLDERS_REGEXP = /\\[(.+??)\\]/;\nconst PP_PLACEHOLDERS_REGEXP = /\\[(.+??)\\]|(\\/?\\*\\d+:\\d+)/g;\nconst PP_ICU_VARS_REGEXP = /({\\s*)(VAR_(PLURAL|SELECT)(_\\d+)?)(\\s*,)/g;\nconst PP_ICU_PLACEHOLDERS_REGEXP = /{([A-Z0-9_]+)}/g;\nconst PP_ICUS_REGEXP = /I18N_EXP_(ICU(_\\d+)?)/g;\nconst PP_CLOSE_TEMPLATE_REGEXP = /\\/\\*/;\nconst PP_TEMPLATE_ID_REGEXP = /\\d+\\:(\\d+)/;\n\n// Parsed placeholder structure used in postprocessing (within `i18nPostprocess` function)\n// Contains the following fields: [templateId, isCloseTemplateTag, placeholder]\ntype PostprocessPlaceholder = [number, boolean, string];\n\n\n/**\n * Handles message string post-processing for internationalization.\n *\n * Handles message string post-processing by transforming it from intermediate\n * format (that might contain some markers that we need to replace) to the final\n * form, consumable by i18nStart instruction. Post processing steps include:\n *\n * 1. Resolve all multi-value cases (like [*1:1#2:1|#4:1|5])\n * 2. Replace all ICU vars (like \"VAR_PLURAL\")\n * 3. Replace all placeholders used inside ICUs in a form of {PLACEHOLDER}\n * 4. Replace all ICU references with corresponding values (like ICU_EXP_ICU_1)\n *    in case multiple ICUs have the same placeholder name\n *\n * @param message Raw translation string for post processing\n * @param replacements Set of replacements that should be applied\n *\n * @returns Transformed string that can be consumed by i18nStart instruction\n *\n * @codeGenApi\n */\nexport function i18nPostprocess(\n    message: string, replacements: {[key: string]: (string|string[])} = {}): string {\n  /**\n   * Step 1: resolve all multi-value placeholders like [#5|*1:1#2:1|#4:1]\n   *\n   * Note: due to the way we process nested templates (BFS), multi-value placeholders are typically\n   * grouped by templates, for example: [#5|#6|#1:1|#3:2] where #5 and #6 belong to root\n   * template, #1:1 belong to nested template with index 1 and #1:2 - nested template with index\n   * 3. However in real templates the order might be different: i.e. #1:1 and/or #3:2 may go in\n   * front of #6. The post processing step restores the right order by keeping track of the\n   * template id stack and looks for placeholders that belong to the currently active template.\n   */\n  let result: string = message;\n  if (PP_MULTI_VALUE_PLACEHOLDERS_REGEXP.test(message)) {\n    const matches: {[key: string]: PostprocessPlaceholder[]} = {};\n    const templateIdsStack: number[] = [ROOT_TEMPLATE_ID];\n    result = result.replace(PP_PLACEHOLDERS_REGEXP, (m: any, phs: string, tmpl: string): string => {\n      const content = phs || tmpl;\n      const placeholders: PostprocessPlaceholder[] = matches[content] || [];\n      if (!placeholders.length) {\n        content.split('|').forEach((placeholder: string) => {\n          const match = placeholder.match(PP_TEMPLATE_ID_REGEXP);\n          const templateId = match ? parseInt(match[1], 10) : ROOT_TEMPLATE_ID;\n          const isCloseTemplateTag = PP_CLOSE_TEMPLATE_REGEXP.test(placeholder);\n          placeholders.push([templateId, isCloseTemplateTag, placeholder]);\n        });\n        matches[content] = placeholders;\n      }\n\n      if (!placeholders.length) {\n        throw new Error(`i18n postprocess: unmatched placeholder - ${content}`);\n      }\n\n      const currentTemplateId = templateIdsStack[templateIdsStack.length - 1];\n      let idx = 0;\n      // find placeholder index that matches current template id\n      for (let i = 0; i < placeholders.length; i++) {\n        if (placeholders[i][0] === currentTemplateId) {\n          idx = i;\n          break;\n        }\n      }\n      // update template id stack based on the current tag extracted\n      const [templateId, isCloseTemplateTag, placeholder] = placeholders[idx];\n      if (isCloseTemplateTag) {\n        templateIdsStack.pop();\n      } else if (currentTemplateId !== templateId) {\n        templateIdsStack.push(templateId);\n      }\n      // remove processed tag from the list\n      placeholders.splice(idx, 1);\n      return placeholder;\n    });\n  }\n\n  // return current result if no replacements specified\n  if (!Object.keys(replacements).length) {\n    return result;\n  }\n\n  /**\n   * Step 2: replace all ICU vars (like \"VAR_PLURAL\")\n   */\n  result = result.replace(PP_ICU_VARS_REGEXP, (match, start, key, _type, _idx, end): string => {\n    return replacements.hasOwnProperty(key) ? `${start}${replacements[key]}${end}` : match;\n  });\n\n  /**\n   * Step 3: replace all placeholders used inside ICUs in a form of {PLACEHOLDER}\n   */\n  result = result.replace(PP_ICU_PLACEHOLDERS_REGEXP, (match, key): string => {\n    return replacements.hasOwnProperty(key) ? replacements[key] as string : match;\n  });\n\n  /**\n   * Step 4: replace all ICU references with corresponding values (like ICU_EXP_ICU_1) in case\n   * multiple ICUs have the same placeholder name\n   */\n  result = result.replace(PP_ICUS_REGEXP, (match, key): string => {\n    if (replacements.hasOwnProperty(key)) {\n      const list = replacements[key] as string[];\n      if (!list.length) {\n        throw new Error(`i18n postprocess: unmatched ICU - ${match} with key: ${key}`);\n      }\n      return list.shift()!;\n    }\n    return match;\n  });\n\n  return result;\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport '../../util/ng_dev_mode';\nimport '../../util/ng_i18n_closure_mode';\n\nimport {assertDefined} from '../../util/assert';\nimport {bindingUpdated} from '../bindings';\nimport {applyCreateOpCodes, applyI18n, setMaskBit} from '../i18n/i18n_apply';\nimport {i18nAttributesFirstPass, i18nStartFirstCreatePass} from '../i18n/i18n_parse';\nimport {i18nPostprocess} from '../i18n/i18n_postprocess';\nimport {TI18n} from '../interfaces/i18n';\nimport {TElementNode, TNodeType} from '../interfaces/node';\nimport {HEADER_OFFSET, T_HOST} from '../interfaces/view';\nimport {getClosestRElement} from '../node_manipulation';\nimport {getCurrentParentTNode, getLView, getTView, nextBindingIndex, setInI18nBlock} from '../state';\nimport {getConstant} from '../util/view_utils';\n\n/**\n * Marks a block of text as translatable.\n *\n * The instructions `i18nStart` and `i18nEnd` mark the translation block in the template.\n * The translation `message` is the value which is locale specific. The translation string may\n * contain placeholders which associate inner elements and sub-templates within the translation.\n *\n * The translation `message` placeholders are:\n * - `{index}(:{block})`: *Binding Placeholder*: Marks a location where an expression will be\n *   interpolated into. The placeholder `index` points to the expression binding index. An optional\n *   `block` that matches the sub-template in which it was declared.\n * - `#{index}(:{block})`/`/#{index}(:{block})`: *Element Placeholder*:  Marks the beginning\n *   and end of DOM element that were embedded in the original translation block. The placeholder\n *   `index` points to the element index in the template instructions set. An optional `block` that\n *   matches the sub-template in which it was declared.\n * - `*{index}:{block}`/`/*{index}:{block}`: *Sub-template Placeholder*: Sub-templates must be\n *   split up and translated separately in each angular template function. The `index` points to the\n *   `template` instruction index. A `block` that matches the sub-template in which it was declared.\n *\n * @param index A unique index of the translation in the static block.\n * @param messageIndex An index of the translation message from the `def.consts` array.\n * @param subTemplateIndex Optional sub-template index in the `message`.\n *\n * @codeGenApi\n */\nexport function i18nStart(\n    index: number, messageIndex: number, subTemplateIndex: number = -1): void {\n  const tView = getTView();\n  const lView = getLView();\n  const adjustedIndex = HEADER_OFFSET + index;\n  ngDevMode && assertDefined(tView, `tView should be defined`);\n  const message = getConstant<string>(tView.consts, messageIndex)!;\n  const parentTNode = getCurrentParentTNode() as TElementNode | null;\n  if (tView.firstCreatePass) {\n    i18nStartFirstCreatePass(\n        tView, parentTNode === null ? 0 : parentTNode.index, lView, adjustedIndex, message,\n        subTemplateIndex);\n  }\n  const tI18n = tView.data[adjustedIndex] as TI18n;\n  const sameViewParentTNode = parentTNode === lView[T_HOST] ? null : parentTNode;\n  const parentRNode = getClosestRElement(tView, sameViewParentTNode, lView);\n  // If `parentTNode` is an `ElementContainer` than it has `<!--ng-container--->`.\n  // When we do inserts we have to make sure to insert in front of `<!--ng-container--->`.\n  const insertInFrontOf = parentTNode && (parentTNode.type & TNodeType.ElementContainer) ?\n      lView[parentTNode.index] :\n      null;\n  applyCreateOpCodes(lView, tI18n.create, parentRNode, insertInFrontOf);\n  setInI18nBlock(true);\n}\n\n\n\n/**\n * Translates a translation block marked by `i18nStart` and `i18nEnd`. It inserts the text/ICU nodes\n * into the render tree, moves the placeholder nodes and removes the deleted nodes.\n *\n * @codeGenApi\n */\nexport function i18nEnd(): void {\n  setInI18nBlock(false);\n}\n\n/**\n *\n * Use this instruction to create a translation block that doesn't contain any placeholder.\n * It calls both {@link i18nStart} and {@link i18nEnd} in one instruction.\n *\n * The translation `message` is the value which is locale specific. The translation string may\n * contain placeholders which associate inner elements and sub-templates within the translation.\n *\n * The translation `message` placeholders are:\n * - `{index}(:{block})`: *Binding Placeholder*: Marks a location where an expression will be\n *   interpolated into. The placeholder `index` points to the expression binding index. An optional\n *   `block` that matches the sub-template in which it was declared.\n * - `#{index}(:{block})`/`/#{index}(:{block})`: *Element Placeholder*:  Marks the beginning\n *   and end of DOM element that were embedded in the original translation block. The placeholder\n *   `index` points to the element index in the template instructions set. An optional `block` that\n *   matches the sub-template in which it was declared.\n * - `*{index}:{block}`/`/*{index}:{block}`: *Sub-template Placeholder*: Sub-templates must be\n *   split up and translated separately in each angular template function. The `index` points to the\n *   `template` instruction index. A `block` that matches the sub-template in which it was declared.\n *\n * @param index A unique index of the translation in the static block.\n * @param messageIndex An index of the translation message from the `def.consts` array.\n * @param subTemplateIndex Optional sub-template index in the `message`.\n *\n * @codeGenApi\n */\nexport function i18n(index: number, messageIndex: number, subTemplateIndex?: number): void {\n  i18nStart(index, messageIndex, subTemplateIndex);\n  i18nEnd();\n}\n\n/**\n * Marks a list of attributes as translatable.\n *\n * @param index A unique index in the static block\n * @param values\n *\n * @codeGenApi\n */\nexport function i18nAttributes(index: number, attrsIndex: number): void {\n  const tView = getTView();\n  ngDevMode && assertDefined(tView, `tView should be defined`);\n  const attrs = getConstant<string[]>(tView.consts, attrsIndex)!;\n  i18nAttributesFirstPass(tView, index + HEADER_OFFSET, attrs);\n}\n\n\n/**\n * Stores the values of the bindings during each update cycle in order to determine if we need to\n * update the translated nodes.\n *\n * @param value The binding's value\n * @returns This function returns itself so that it may be chained\n * (e.g. `i18nExp(ctx.name)(ctx.title)`)\n *\n * @codeGenApi\n */\nexport function i18nExp<T>(value: T): typeof i18nExp {\n  const lView = getLView();\n  setMaskBit(bindingUpdated(lView, nextBindingIndex(), value));\n  return i18nExp;\n}\n\n/**\n * Updates a translation block or an i18n attribute when the bindings have changed.\n *\n * @param index Index of either {@link i18nStart} (translation block) or {@link i18nAttributes}\n * (i18n attribute) on which it should update the content.\n *\n * @codeGenApi\n */\nexport function i18nApply(index: number) {\n  applyI18n(getTView(), getLView(), index + HEADER_OFFSET);\n}\n\n/**\n * Handles message string post-processing for internationalization.\n *\n * Handles message string post-processing by transforming it from intermediate\n * format (that might contain some markers that we need to replace) to the final\n * form, consumable by i18nStart instruction. Post processing steps include:\n *\n * 1. Resolve all multi-value cases (like [*1:1#2:1|#4:1|5])\n * 2. Replace all ICU vars (like \"VAR_PLURAL\")\n * 3. Replace all placeholders used inside ICUs in a form of {PLACEHOLDER}\n * 4. Replace all ICU references with corresponding values (like ICU_EXP_ICU_1)\n *    in case multiple ICUs have the same placeholder name\n *\n * @param message Raw translation string for post processing\n * @param replacements Set of replacements that should be applied\n *\n * @returns Transformed string that can be consumed by i18nStart instruction\n *\n * @codeGenApi\n */\nexport function i18nPostprocess(\n    message: string, replacements: {[key: string]: (string|string[])} = {}): string {\n  return i18nPostprocess(message, replacements);\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {forwardRef, resolveForwardRef} from '../../di/forward_ref';\nimport {inject, invalidFactoryDep} from '../../di/injector_compatibility';\nimport {defineInjectable, defineInjector} from '../../di/interface/defs';\nimport {registerNgModuleType} from '../../linker/ng_module_registration';\nimport * as iframe_attrs_validation from '../../sanitization/iframe_attrs_validation';\nimport * as sanitization from '../../sanitization/sanitization';\nimport * as r3 from '../index';\n\n\n/**\n * A mapping of the @angular/core API surface used in generated expressions to the actual symbols.\n *\n * This should be kept up to date with the public exports of @angular/core.\n */\nexport const angularCoreEnv: {[name: string]: Function} =\n    (() => ({\n       'attribute': r3.attribute,\n       'attributeInterpolate1': r3.attributeInterpolate1,\n       'attributeInterpolate2': r3.attributeInterpolate2,\n       'attributeInterpolate3': r3.attributeInterpolate3,\n       'attributeInterpolate4': r3.attributeInterpolate4,\n       'attributeInterpolate5': r3.attributeInterpolate5,\n       'attributeInterpolate6': r3.attributeInterpolate6,\n       'attributeInterpolate7': r3.attributeInterpolate7,\n       'attributeInterpolate8': r3.attributeInterpolate8,\n       'attributeInterpolateV': r3.attributeInterpolateV,\n       'defineComponent': r3.defineComponent,\n       'defineDirective': r3.defineDirective,\n       'defineInjectable': defineInjectable,\n       'defineInjector': defineInjector,\n       'defineNgModule': r3.defineNgModule,\n       'definePipe': r3.definePipe,\n       'directiveInject': r3.directiveInject,\n       'getInheritedFactory': r3.getInheritedFactory,\n       'inject': inject,\n       'injectAttribute': r3.injectAttribute,\n       'invalidFactory': r3.invalidFactory,\n       'invalidFactoryDep': invalidFactoryDep,\n       'templateRefExtractor': r3.templateRefExtractor,\n       'resetView': r3.resetView,\n       'HostDirectivesFeature': r3.HostDirectivesFeature,\n       'NgOnChangesFeature': r3.NgOnChangesFeature,\n       'ProvidersFeature': r3.ProvidersFeature,\n       'CopyDefinitionFeature': r3.CopyDefinitionFeature,\n       'InheritDefinitionFeature': r3.InheritDefinitionFeature,\n       'StandaloneFeature': r3.StandaloneFeature,\n       'nextContext': r3.nextContext,\n       'namespaceHTML': r3.namespaceHTML,\n       'namespaceMathML': r3.namespaceMathML,\n       'namespaceSVG': r3.namespaceSVG,\n       'enableBindings': r3.enableBindings,\n       'disableBindings': r3.disableBindings,\n       'elementStart': r3.elementStart,\n       'elementEnd': r3.elementEnd,\n       'element': r3.element,\n       'elementContainerStart': r3.elementContainerStart,\n       'elementContainerEnd': r3.elementContainerEnd,\n       'elementContainer': r3.elementContainer,\n       'pureFunction0': r3.pureFunction0,\n       'pureFunction1': r3.pureFunction1,\n       'pureFunction2': r3.pureFunction2,\n       'pureFunction3': r3.pureFunction3,\n       'pureFunction4': r3.pureFunction4,\n       'pureFunction5': r3.pureFunction5,\n       'pureFunction6': r3.pureFunction6,\n       'pureFunction7': r3.pureFunction7,\n       'pureFunction8': r3.pureFunction8,\n       'pureFunctionV': r3.pureFunctionV,\n       'getCurrentView': r3.getCurrentView,\n       'restoreView': r3.restoreView,\n       'listener': r3.listener,\n       'projection': r3.projection,\n       'syntheticHostProperty': r3.syntheticHostProperty,\n       'syntheticHostListener': r3.syntheticHostListener,\n       'pipeBind1': r3.pipeBind1,\n       'pipeBind2': r3.pipeBind2,\n       'pipeBind3': r3.pipeBind3,\n       'pipeBind4': r3.pipeBind4,\n       'pipeBindV': r3.pipeBindV,\n       'projectionDef': r3.projectionDef,\n       'hostProperty': r3.hostProperty,\n       'property': r3.property,\n       'propertyInterpolate': r3.propertyInterpolate,\n       'propertyInterpolate1': r3.propertyInterpolate1,\n       'propertyInterpolate2': r3.propertyInterpolate2,\n       'propertyInterpolate3': r3.propertyInterpolate3,\n       'propertyInterpolate4': r3.propertyInterpolate4,\n       'propertyInterpolate5': r3.propertyInterpolate5,\n       'propertyInterpolate6': r3.propertyInterpolate6,\n       'propertyInterpolate7': r3.propertyInterpolate7,\n       'propertyInterpolate8': r3.propertyInterpolate8,\n       'propertyInterpolateV': r3.propertyInterpolateV,\n       'pipe': r3.pipe,\n       'queryRefresh': r3.queryRefresh,\n       'viewQuery': r3.viewQuery,\n       'loadQuery': r3.loadQuery,\n       'contentQuery': r3.contentQuery,\n       'reference': r3.reference,\n       'classMap': r3.classMap,\n       'classMapInterpolate1': r3.classMapInterpolate1,\n       'classMapInterpolate2': r3.classMapInterpolate2,\n       'classMapInterpolate3': r3.classMapInterpolate3,\n       'classMapInterpolate4': r3.classMapInterpolate4,\n       'classMapInterpolate5': r3.classMapInterpolate5,\n       'classMapInterpolate6': r3.classMapInterpolate6,\n       'classMapInterpolate7': r3.classMapInterpolate7,\n       'classMapInterpolate8': r3.classMapInterpolate8,\n       'classMapInterpolateV': r3.classMapInterpolateV,\n       'styleMap': r3.styleMap,\n       'styleMapInterpolate1': r3.styleMapInterpolate1,\n       'styleMapInterpolate2': r3.styleMapInterpolate2,\n       'styleMapInterpolate3': r3.styleMapInterpolate3,\n       'styleMapInterpolate4': r3.styleMapInterpolate4,\n       'styleMapInterpolate5': r3.styleMapInterpolate5,\n       'styleMapInterpolate6': r3.styleMapInterpolate6,\n       'styleMapInterpolate7': r3.styleMapInterpolate7,\n       'styleMapInterpolate8': r3.styleMapInterpolate8,\n       'styleMapInterpolateV': r3.styleMapInterpolateV,\n       'styleProp': r3.styleProp,\n       'stylePropInterpolate1': r3.stylePropInterpolate1,\n       'stylePropInterpolate2': r3.stylePropInterpolate2,\n       'stylePropInterpolate3': r3.stylePropInterpolate3,\n       'stylePropInterpolate4': r3.stylePropInterpolate4,\n       'stylePropInterpolate5': r3.stylePropInterpolate5,\n       'stylePropInterpolate6': r3.stylePropInterpolate6,\n       'stylePropInterpolate7': r3.stylePropInterpolate7,\n       'stylePropInterpolate8': r3.stylePropInterpolate8,\n       'stylePropInterpolateV': r3.stylePropInterpolateV,\n       'classProp': r3.classProp,\n       'advance': r3.advance,\n       'template': r3.template,\n       'text': r3.text,\n       'textInterpolate': r3.textInterpolate,\n       'textInterpolate1': r3.textInterpolate1,\n       'textInterpolate2': r3.textInterpolate2,\n       'textInterpolate3': r3.textInterpolate3,\n       'textInterpolate4': r3.textInterpolate4,\n       'textInterpolate5': r3.textInterpolate5,\n       'textInterpolate6': r3.textInterpolate6,\n       'textInterpolate7': r3.textInterpolate7,\n       'textInterpolate8': r3.textInterpolate8,\n       'textInterpolateV': r3.textInterpolateV,\n       'i18n': r3.i18n,\n       'i18nAttributes': r3.i18nAttributes,\n       'i18nExp': r3.i18nExp,\n       'i18nStart': r3.i18nStart,\n       'i18nEnd': r3.i18nEnd,\n       'i18nApply': r3.i18nApply,\n       'i18nPostprocess': r3.i18nPostprocess,\n       'resolveWindow': r3.resolveWindow,\n       'resolveDocument': r3.resolveDocument,\n       'resolveBody': r3.resolveBody,\n       'setComponentScope': r3.setComponentScope,\n       'setNgModuleScope': r3.setNgModuleScope,\n       'registerNgModuleType': registerNgModuleType,\n\n       'sanitizeHtml': sanitization.sanitizeHtml,\n       'sanitizeStyle': sanitization.sanitizeStyle,\n       'sanitizeResourceUrl': sanitization.sanitizeResourceUrl,\n       'sanitizeScript': sanitization.sanitizeScript,\n       'sanitizeUrl': sanitization.sanitizeUrl,\n       'sanitizeUrlOrResourceUrl': sanitization.sanitizeUrlOrResourceUrl,\n       'trustConstantHtml': sanitization.trustConstantHtml,\n       'trustConstantResourceUrl': sanitization.trustConstantResourceUrl,\n       'validateIframeAttribute': iframe_attrs_validation.validateIframeAttribute,\n\n       'forwardRef': forwardRef,\n       'resolveForwardRef': resolveForwardRef,\n     }))();\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport {SanitizerFn} from '../interfaces/sanitization';\nimport {getBindingIndex, getLView, getSelectedTNode, getTView} from '../state';\nimport {NO_CHANGE} from '../tokens';\nimport {interpolation1, interpolation2, interpolation3, interpolation4, interpolation5, interpolation6, interpolation7, interpolation8, interpolationV} from './interpolation';\nimport {elementAttributeInternal, storePropertyBindingMetadata} from './shared';\n\n\n\n/**\n *\n * Update an interpolated attribute on an element with single bound value surrounded by text.\n *\n * Used when the value passed to a property has 1 interpolated value in it:\n *\n * ```html\n * <div attr.title=\"prefix{{v0}}suffix\"></div>\n * ```\n *\n * Its compiled representation is::\n *\n * ```ts\n * attributeInterpolate1('title', 'prefix', v0, 'suffix');\n * ```\n *\n * @param attrName The name of the attribute to update\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @param sanitizer An optional sanitizer function\n * @returns itself, so that it may be chained.\n * @codeGenApi\n */\nexport function attributeInterpolate1(\n    attrName: string, prefix: string, v0: any, suffix: string, sanitizer?: SanitizerFn,\n    namespace?: string): typeof attributeInterpolate1 {\n  const lView = getLView();\n  const interpolatedValue = interpolation1(lView, prefix, v0, suffix);\n  if (interpolatedValue !== NO_CHANGE) {\n    const tNode = getSelectedTNode();\n    elementAttributeInternal(tNode, lView, attrName, interpolatedValue, sanitizer, namespace);\n    ngDevMode &&\n        storePropertyBindingMetadata(\n            getTView().data, tNode, 'attr.' + attrName, getBindingIndex() - 1, prefix, suffix);\n  }\n  return attributeInterpolate1;\n}\n\n/**\n *\n * Update an interpolated attribute on an element with 2 bound values surrounded by text.\n *\n * Used when the value passed to a property has 2 interpolated values in it:\n *\n * ```html\n * <div attr.title=\"prefix{{v0}}-{{v1}}suffix\"></div>\n * ```\n *\n * Its compiled representation is::\n *\n * ```ts\n * attributeInterpolate2('title', 'prefix', v0, '-', v1, 'suffix');\n * ```\n *\n * @param attrName The name of the attribute to update\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @param sanitizer An optional sanitizer function\n * @returns itself, so that it may be chained.\n * @codeGenApi\n */\nexport function attributeInterpolate2(\n    attrName: string, prefix: string, v0: any, i0: string, v1: any, suffix: string,\n    sanitizer?: SanitizerFn, namespace?: string): typeof attributeInterpolate2 {\n  const lView = getLView();\n  const interpolatedValue = interpolation2(lView, prefix, v0, i0, v1, suffix);\n  if (interpolatedValue !== NO_CHANGE) {\n    const tNode = getSelectedTNode();\n    elementAttributeInternal(tNode, lView, attrName, interpolatedValue, sanitizer, namespace);\n    ngDevMode &&\n        storePropertyBindingMetadata(\n            getTView().data, tNode, 'attr.' + attrName, getBindingIndex() - 2, prefix, i0, suffix);\n  }\n  return attributeInterpolate2;\n}\n\n/**\n *\n * Update an interpolated attribute on an element with 3 bound values surrounded by text.\n *\n * Used when the value passed to a property has 3 interpolated values in it:\n *\n * ```html\n * <div attr.title=\"prefix{{v0}}-{{v1}}-{{v2}}suffix\"></div>\n * ```\n *\n * Its compiled representation is::\n *\n * ```ts\n * attributeInterpolate3(\n * 'title', 'prefix', v0, '-', v1, '-', v2, 'suffix');\n * ```\n *\n * @param attrName The name of the attribute to update\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param i1 Static value used for concatenation only.\n * @param v2 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @param sanitizer An optional sanitizer function\n * @returns itself, so that it may be chained.\n * @codeGenApi\n */\nexport function attributeInterpolate3(\n    attrName: string, prefix: string, v0: any, i0: string, v1: any, i1: string, v2: any,\n    suffix: string, sanitizer?: SanitizerFn, namespace?: string): typeof attributeInterpolate3 {\n  const lView = getLView();\n  const interpolatedValue = interpolation3(lView, prefix, v0, i0, v1, i1, v2, suffix);\n  if (interpolatedValue !== NO_CHANGE) {\n    const tNode = getSelectedTNode();\n    elementAttributeInternal(tNode, lView, attrName, interpolatedValue, sanitizer, namespace);\n    ngDevMode &&\n        storePropertyBindingMetadata(\n            getTView().data, tNode, 'attr.' + attrName, getBindingIndex() - 3, prefix, i0, i1,\n            suffix);\n  }\n  return attributeInterpolate3;\n}\n\n/**\n *\n * Update an interpolated attribute on an element with 4 bound values surrounded by text.\n *\n * Used when the value passed to a property has 4 interpolated values in it:\n *\n * ```html\n * <div attr.title=\"prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}suffix\"></div>\n * ```\n *\n * Its compiled representation is::\n *\n * ```ts\n * attributeInterpolate4(\n * 'title', 'prefix', v0, '-', v1, '-', v2, '-', v3, 'suffix');\n * ```\n *\n * @param attrName The name of the attribute to update\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param i1 Static value used for concatenation only.\n * @param v2 Value checked for change.\n * @param i2 Static value used for concatenation only.\n * @param v3 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @param sanitizer An optional sanitizer function\n * @returns itself, so that it may be chained.\n * @codeGenApi\n */\nexport function attributeInterpolate4(\n    attrName: string, prefix: string, v0: any, i0: string, v1: any, i1: string, v2: any, i2: string,\n    v3: any, suffix: string, sanitizer?: SanitizerFn,\n    namespace?: string): typeof attributeInterpolate4 {\n  const lView = getLView();\n  const interpolatedValue = interpolation4(lView, prefix, v0, i0, v1, i1, v2, i2, v3, suffix);\n  if (interpolatedValue !== NO_CHANGE) {\n    const tNode = getSelectedTNode();\n    elementAttributeInternal(tNode, lView, attrName, interpolatedValue, sanitizer, namespace);\n    ngDevMode &&\n        storePropertyBindingMetadata(\n            getTView().data, tNode, 'attr.' + attrName, getBindingIndex() - 4, prefix, i0, i1, i2,\n            suffix);\n  }\n  return attributeInterpolate4;\n}\n\n/**\n *\n * Update an interpolated attribute on an element with 5 bound values surrounded by text.\n *\n * Used when the value passed to a property has 5 interpolated values in it:\n *\n * ```html\n * <div attr.title=\"prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}-{{v4}}suffix\"></div>\n * ```\n *\n * Its compiled representation is::\n *\n * ```ts\n * attributeInterpolate5(\n * 'title', 'prefix', v0, '-', v1, '-', v2, '-', v3, '-', v4, 'suffix');\n * ```\n *\n * @param attrName The name of the attribute to update\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param i1 Static value used for concatenation only.\n * @param v2 Value checked for change.\n * @param i2 Static value used for concatenation only.\n * @param v3 Value checked for change.\n * @param i3 Static value used for concatenation only.\n * @param v4 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @param sanitizer An optional sanitizer function\n * @returns itself, so that it may be chained.\n * @codeGenApi\n */\nexport function attributeInterpolate5(\n    attrName: string, prefix: string, v0: any, i0: string, v1: any, i1: string, v2: any, i2: string,\n    v3: any, i3: string, v4: any, suffix: string, sanitizer?: SanitizerFn,\n    namespace?: string): typeof attributeInterpolate5 {\n  const lView = getLView();\n  const interpolatedValue =\n      interpolation5(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, suffix);\n  if (interpolatedValue !== NO_CHANGE) {\n    const tNode = getSelectedTNode();\n    elementAttributeInternal(tNode, lView, attrName, interpolatedValue, sanitizer, namespace);\n    ngDevMode &&\n        storePropertyBindingMetadata(\n            getTView().data, tNode, 'attr.' + attrName, getBindingIndex() - 5, prefix, i0, i1, i2,\n            i3, suffix);\n  }\n  return attributeInterpolate5;\n}\n\n/**\n *\n * Update an interpolated attribute on an element with 6 bound values surrounded by text.\n *\n * Used when the value passed to a property has 6 interpolated values in it:\n *\n * ```html\n * <div attr.title=\"prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}-{{v4}}-{{v5}}suffix\"></div>\n * ```\n *\n * Its compiled representation is::\n *\n * ```ts\n * attributeInterpolate6(\n *    'title', 'prefix', v0, '-', v1, '-', v2, '-', v3, '-', v4, '-', v5, 'suffix');\n * ```\n *\n * @param attrName The name of the attribute to update\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param i1 Static value used for concatenation only.\n * @param v2 Value checked for change.\n * @param i2 Static value used for concatenation only.\n * @param v3 Value checked for change.\n * @param i3 Static value used for concatenation only.\n * @param v4 Value checked for change.\n * @param i4 Static value used for concatenation only.\n * @param v5 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @param sanitizer An optional sanitizer function\n * @returns itself, so that it may be chained.\n * @codeGenApi\n */\nexport function attributeInterpolate6(\n    attrName: string, prefix: string, v0: any, i0: string, v1: any, i1: string, v2: any, i2: string,\n    v3: any, i3: string, v4: any, i4: string, v5: any, suffix: string, sanitizer?: SanitizerFn,\n    namespace?: string): typeof attributeInterpolate6 {\n  const lView = getLView();\n  const interpolatedValue =\n      interpolation6(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, suffix);\n  if (interpolatedValue !== NO_CHANGE) {\n    const tNode = getSelectedTNode();\n    elementAttributeInternal(tNode, lView, attrName, interpolatedValue, sanitizer, namespace);\n    ngDevMode &&\n        storePropertyBindingMetadata(\n            getTView().data, tNode, 'attr.' + attrName, getBindingIndex() - 6, prefix, i0, i1, i2,\n            i3, i4, suffix);\n  }\n  return attributeInterpolate6;\n}\n\n/**\n *\n * Update an interpolated attribute on an element with 7 bound values surrounded by text.\n *\n * Used when the value passed to a property has 7 interpolated values in it:\n *\n * ```html\n * <div attr.title=\"prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}-{{v4}}-{{v5}}-{{v6}}suffix\"></div>\n * ```\n *\n * Its compiled representation is::\n *\n * ```ts\n * attributeInterpolate7(\n *    'title', 'prefix', v0, '-', v1, '-', v2, '-', v3, '-', v4, '-', v5, '-', v6, 'suffix');\n * ```\n *\n * @param attrName The name of the attribute to update\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param i1 Static value used for concatenation only.\n * @param v2 Value checked for change.\n * @param i2 Static value used for concatenation only.\n * @param v3 Value checked for change.\n * @param i3 Static value used for concatenation only.\n * @param v4 Value checked for change.\n * @param i4 Static value used for concatenation only.\n * @param v5 Value checked for change.\n * @param i5 Static value used for concatenation only.\n * @param v6 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @param sanitizer An optional sanitizer function\n * @returns itself, so that it may be chained.\n * @codeGenApi\n */\nexport function attributeInterpolate7(\n    attrName: string, prefix: string, v0: any, i0: string, v1: any, i1: string, v2: any, i2: string,\n    v3: any, i3: string, v4: any, i4: string, v5: any, i5: string, v6: any, suffix: string,\n    sanitizer?: SanitizerFn, namespace?: string): typeof attributeInterpolate7 {\n  const lView = getLView();\n  const interpolatedValue =\n      interpolation7(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, suffix);\n  if (interpolatedValue !== NO_CHANGE) {\n    const tNode = getSelectedTNode();\n    elementAttributeInternal(tNode, lView, attrName, interpolatedValue, sanitizer, namespace);\n    ngDevMode &&\n        storePropertyBindingMetadata(\n            getTView().data, tNode, 'attr.' + attrName, getBindingIndex() - 7, prefix, i0, i1, i2,\n            i3, i4, i5, suffix);\n  }\n  return attributeInterpolate7;\n}\n\n/**\n *\n * Update an interpolated attribute on an element with 8 bound values surrounded by text.\n *\n * Used when the value passed to a property has 8 interpolated values in it:\n *\n * ```html\n * <div attr.title=\"prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}-{{v4}}-{{v5}}-{{v6}}-{{v7}}suffix\"></div>\n * ```\n *\n * Its compiled representation is::\n *\n * ```ts\n * attributeInterpolate8(\n *  'title', 'prefix', v0, '-', v1, '-', v2, '-', v3, '-', v4, '-', v5, '-', v6, '-', v7, 'suffix');\n * ```\n *\n * @param attrName The name of the attribute to update\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param i1 Static value used for concatenation only.\n * @param v2 Value checked for change.\n * @param i2 Static value used for concatenation only.\n * @param v3 Value checked for change.\n * @param i3 Static value used for concatenation only.\n * @param v4 Value checked for change.\n * @param i4 Static value used for concatenation only.\n * @param v5 Value checked for change.\n * @param i5 Static value used for concatenation only.\n * @param v6 Value checked for change.\n * @param i6 Static value used for concatenation only.\n * @param v7 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @param sanitizer An optional sanitizer function\n * @returns itself, so that it may be chained.\n * @codeGenApi\n */\nexport function attributeInterpolate8(\n    attrName: string, prefix: string, v0: any, i0: string, v1: any, i1: string, v2: any, i2: string,\n    v3: any, i3: string, v4: any, i4: string, v5: any, i5: string, v6: any, i6: string, v7: any,\n    suffix: string, sanitizer?: SanitizerFn, namespace?: string): typeof attributeInterpolate8 {\n  const lView = getLView();\n  const interpolatedValue = interpolation8(\n      lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, i6, v7, suffix);\n  if (interpolatedValue !== NO_CHANGE) {\n    const tNode = getSelectedTNode();\n    elementAttributeInternal(tNode, lView, attrName, interpolatedValue, sanitizer, namespace);\n    ngDevMode &&\n        storePropertyBindingMetadata(\n            getTView().data, tNode, 'attr.' + attrName, getBindingIndex() - 8, prefix, i0, i1, i2,\n            i3, i4, i5, i6, suffix);\n  }\n  return attributeInterpolate8;\n}\n\n/**\n * Update an interpolated attribute on an element with 9 or more bound values surrounded by text.\n *\n * Used when the number of interpolated values exceeds 8.\n *\n * ```html\n * <div\n *  title=\"prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}-{{v4}}-{{v5}}-{{v6}}-{{v7}}-{{v8}}-{{v9}}suffix\"></div>\n * ```\n *\n * Its compiled representation is::\n *\n * ```ts\n * attributeInterpolateV(\n *  'title', ['prefix', v0, '-', v1, '-', v2, '-', v3, '-', v4, '-', v5, '-', v6, '-', v7, '-', v9,\n *  'suffix']);\n * ```\n *\n * @param attrName The name of the attribute to update.\n * @param values The collection of values and the strings in-between those values, beginning with\n * a string prefix and ending with a string suffix.\n * (e.g. `['prefix', value0, '-', value1, '-', value2, ..., value99, 'suffix']`)\n * @param sanitizer An optional sanitizer function\n * @returns itself, so that it may be chained.\n * @codeGenApi\n */\nexport function attributeInterpolateV(\n    attrName: string, values: any[], sanitizer?: SanitizerFn,\n    namespace?: string): typeof attributeInterpolateV {\n  const lView = getLView();\n  const interpolated = interpolationV(lView, values);\n  if (interpolated !== NO_CHANGE) {\n    const tNode = getSelectedTNode();\n    elementAttributeInternal(tNode, lView, attrName, interpolated, sanitizer, namespace);\n    if (ngDevMode) {\n      const interpolationInBetween = [values[0]];  // prefix\n      for (let i = 2; i < values.length; i += 2) {\n        interpolationInBetween.push(values[i]);\n      }\n      storePropertyBindingMetadata(\n          getTView().data, tNode, 'attr.' + attrName,\n          getBindingIndex() - interpolationInBetween.length + 1, ...interpolationInBetween);\n    }\n  }\n  return attributeInterpolateV;\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {getLView} from '../state';\nimport {interpolation1, interpolation2, interpolation3, interpolation4, interpolation5, interpolation6, interpolation7, interpolation8, interpolationV} from './interpolation';\nimport {styleMap} from './styling';\n\n\n/**\n *\n * Update an interpolated style on an element with single bound value surrounded by text.\n *\n * Used when the value passed to a property has 1 interpolated value in it:\n *\n * ```html\n * <div style=\"key: {{v0}}suffix\"></div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * styleMapInterpolate1('key: ', v0, 'suffix');\n * ```\n *\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @codeGenApi\n */\nexport function styleMapInterpolate1(prefix: string, v0: any, suffix: string): void {\n  const lView = getLView();\n  const interpolatedValue = interpolation1(lView, prefix, v0, suffix);\n  styleMap(interpolatedValue);\n}\n\n/**\n *\n * Update an interpolated style on an element with 2 bound values surrounded by text.\n *\n * Used when the value passed to a property has 2 interpolated values in it:\n *\n * ```html\n * <div style=\"key: {{v0}}; key1: {{v1}}suffix\"></div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * styleMapInterpolate2('key: ', v0, '; key1: ', v1, 'suffix');\n * ```\n *\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @codeGenApi\n */\nexport function styleMapInterpolate2(\n    prefix: string, v0: any, i0: string, v1: any, suffix: string): void {\n  const lView = getLView();\n  const interpolatedValue = interpolation2(lView, prefix, v0, i0, v1, suffix);\n  styleMap(interpolatedValue);\n}\n\n/**\n *\n * Update an interpolated style on an element with 3 bound values surrounded by text.\n *\n * Used when the value passed to a property has 3 interpolated values in it:\n *\n * ```html\n * <div style=\"key: {{v0}}; key2: {{v1}}; key2: {{v2}}suffix\"></div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * styleMapInterpolate3(\n *     'key: ', v0, '; key1: ', v1, '; key2: ', v2, 'suffix');\n * ```\n *\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param i1 Static value used for concatenation only.\n * @param v2 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @codeGenApi\n */\nexport function styleMapInterpolate3(\n    prefix: string, v0: any, i0: string, v1: any, i1: string, v2: any, suffix: string): void {\n  const lView = getLView();\n  const interpolatedValue = interpolation3(lView, prefix, v0, i0, v1, i1, v2, suffix);\n  styleMap(interpolatedValue);\n}\n\n/**\n *\n * Update an interpolated style on an element with 4 bound values surrounded by text.\n *\n * Used when the value passed to a property has 4 interpolated values in it:\n *\n * ```html\n * <div style=\"key: {{v0}}; key1: {{v1}}; key2: {{v2}}; key3: {{v3}}suffix\"></div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * styleMapInterpolate4(\n *     'key: ', v0, '; key1: ', v1, '; key2: ', v2, '; key3: ', v3, 'suffix');\n * ```\n *\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param i1 Static value used for concatenation only.\n * @param v2 Value checked for change.\n * @param i2 Static value used for concatenation only.\n * @param v3 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @codeGenApi\n */\nexport function styleMapInterpolate4(\n    prefix: string, v0: any, i0: string, v1: any, i1: string, v2: any, i2: string, v3: any,\n    suffix: string): void {\n  const lView = getLView();\n  const interpolatedValue = interpolation4(lView, prefix, v0, i0, v1, i1, v2, i2, v3, suffix);\n  styleMap(interpolatedValue);\n}\n\n/**\n *\n * Update an interpolated style on an element with 5 bound values surrounded by text.\n *\n * Used when the value passed to a property has 5 interpolated values in it:\n *\n * ```html\n * <div style=\"key: {{v0}}; key1: {{v1}}; key2: {{v2}}; key3: {{v3}}; key4: {{v4}}suffix\"></div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * styleMapInterpolate5(\n *     'key: ', v0, '; key1: ', v1, '; key2: ', v2, '; key3: ', v3, '; key4: ', v4, 'suffix');\n * ```\n *\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param i1 Static value used for concatenation only.\n * @param v2 Value checked for change.\n * @param i2 Static value used for concatenation only.\n * @param v3 Value checked for change.\n * @param i3 Static value used for concatenation only.\n * @param v4 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @codeGenApi\n */\nexport function styleMapInterpolate5(\n    prefix: string, v0: any, i0: string, v1: any, i1: string, v2: any, i2: string, v3: any,\n    i3: string, v4: any, suffix: string): void {\n  const lView = getLView();\n  const interpolatedValue =\n      interpolation5(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, suffix);\n  styleMap(interpolatedValue);\n}\n\n/**\n *\n * Update an interpolated style on an element with 6 bound values surrounded by text.\n *\n * Used when the value passed to a property has 6 interpolated values in it:\n *\n * ```html\n * <div style=\"key: {{v0}}; key1: {{v1}}; key2: {{v2}}; key3: {{v3}}; key4: {{v4}};\n *             key5: {{v5}}suffix\"></div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * styleMapInterpolate6(\n *    'key: ', v0, '; key1: ', v1, '; key2: ', v2, '; key3: ', v3, '; key4: ', v4, '; key5: ', v5,\n *    'suffix');\n * ```\n *\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param i1 Static value used for concatenation only.\n * @param v2 Value checked for change.\n * @param i2 Static value used for concatenation only.\n * @param v3 Value checked for change.\n * @param i3 Static value used for concatenation only.\n * @param v4 Value checked for change.\n * @param i4 Static value used for concatenation only.\n * @param v5 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @codeGenApi\n */\nexport function styleMapInterpolate6(\n    prefix: string, v0: any, i0: string, v1: any, i1: string, v2: any, i2: string, v3: any,\n    i3: string, v4: any, i4: string, v5: any, suffix: string): void {\n  const lView = getLView();\n  const interpolatedValue =\n      interpolation6(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, suffix);\n  styleMap(interpolatedValue);\n}\n\n/**\n *\n * Update an interpolated style on an element with 7 bound values surrounded by text.\n *\n * Used when the value passed to a property has 7 interpolated values in it:\n *\n * ```html\n * <div style=\"key: {{v0}}; key1: {{v1}}; key2: {{v2}}; key3: {{v3}}; key4: {{v4}}; key5: {{v5}};\n *             key6: {{v6}}suffix\"></div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * styleMapInterpolate7(\n *    'key: ', v0, '; key1: ', v1, '; key2: ', v2, '; key3: ', v3, '; key4: ', v4, '; key5: ', v5,\n *    '; key6: ', v6, 'suffix');\n * ```\n *\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param i1 Static value used for concatenation only.\n * @param v2 Value checked for change.\n * @param i2 Static value used for concatenation only.\n * @param v3 Value checked for change.\n * @param i3 Static value used for concatenation only.\n * @param v4 Value checked for change.\n * @param i4 Static value used for concatenation only.\n * @param v5 Value checked for change.\n * @param i5 Static value used for concatenation only.\n * @param v6 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @codeGenApi\n */\nexport function styleMapInterpolate7(\n    prefix: string, v0: any, i0: string, v1: any, i1: string, v2: any, i2: string, v3: any,\n    i3: string, v4: any, i4: string, v5: any, i5: string, v6: any, suffix: string): void {\n  const lView = getLView();\n  const interpolatedValue =\n      interpolation7(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, suffix);\n  styleMap(interpolatedValue);\n}\n\n/**\n *\n * Update an interpolated style on an element with 8 bound values surrounded by text.\n *\n * Used when the value passed to a property has 8 interpolated values in it:\n *\n * ```html\n * <div style=\"key: {{v0}}; key1: {{v1}}; key2: {{v2}}; key3: {{v3}}; key4: {{v4}}; key5: {{v5}};\n *             key6: {{v6}}; key7: {{v7}}suffix\"></div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * styleMapInterpolate8(\n *    'key: ', v0, '; key1: ', v1, '; key2: ', v2, '; key3: ', v3, '; key4: ', v4, '; key5: ', v5,\n *    '; key6: ', v6, '; key7: ', v7, 'suffix');\n * ```\n *\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param i1 Static value used for concatenation only.\n * @param v2 Value checked for change.\n * @param i2 Static value used for concatenation only.\n * @param v3 Value checked for change.\n * @param i3 Static value used for concatenation only.\n * @param v4 Value checked for change.\n * @param i4 Static value used for concatenation only.\n * @param v5 Value checked for change.\n * @param i5 Static value used for concatenation only.\n * @param v6 Value checked for change.\n * @param i6 Static value used for concatenation only.\n * @param v7 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @codeGenApi\n */\nexport function styleMapInterpolate8(\n    prefix: string, v0: any, i0: string, v1: any, i1: string, v2: any, i2: string, v3: any,\n    i3: string, v4: any, i4: string, v5: any, i5: string, v6: any, i6: string, v7: any,\n    suffix: string): void {\n  const lView = getLView();\n  const interpolatedValue = interpolation8(\n      lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, i6, v7, suffix);\n  styleMap(interpolatedValue);\n}\n\n/**\n * Update an interpolated style on an element with 9 or more bound values surrounded by text.\n *\n * Used when the number of interpolated values exceeds 8.\n *\n * ```html\n * <div\n *  class=\"key: {{v0}}; key1: {{v1}}; key2: {{v2}}; key3: {{v3}}; key4: {{v4}}; key5: {{v5}};\n *         key6: {{v6}}; key7: {{v7}}; key8: {{v8}}; key9: {{v9}}suffix\"></div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * styleMapInterpolateV(\n *    ['key: ', v0, '; key1: ', v1, '; key2: ', v2, '; key3: ', v3, '; key4: ', v4, '; key5: ', v5,\n *     '; key6: ', v6, '; key7: ', v7, '; key8: ', v8, '; key9: ', v9, 'suffix']);\n * ```\n *.\n * @param values The collection of values and the strings in-between those values, beginning with\n * a string prefix and ending with a string suffix.\n * (e.g. `['prefix', value0, '; key2: ', value1, '; key2: ', value2, ..., value99, 'suffix']`)\n * @codeGenApi\n */\nexport function styleMapInterpolateV(values: any[]): void {\n  const lView = getLView();\n  const interpolatedValue = interpolationV(lView, values);\n  styleMap(interpolatedValue);\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {getLView,} from '../state';\nimport {interpolation1, interpolation2, interpolation3, interpolation4, interpolation5, interpolation6, interpolation7, interpolation8, interpolationV} from './interpolation';\nimport {checkStylingProperty} from './styling';\n\n\n/**\n *\n * Update an interpolated style property on an element with single bound value surrounded by text.\n *\n * Used when the value passed to a property has 1 interpolated value in it:\n *\n * ```html\n * <div style.color=\"prefix{{v0}}suffix\"></div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * stylePropInterpolate1(0, 'prefix', v0, 'suffix');\n * ```\n *\n * @param styleIndex Index of style to update. This index value refers to the\n *        index of the style in the style bindings array that was passed into\n *        `styling`.\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @param valueSuffix Optional suffix. Used with scalar values to add unit such as `px`.\n * @returns itself, so that it may be chained.\n * @codeGenApi\n */\nexport function stylePropInterpolate1(\n    prop: string, prefix: string, v0: any, suffix: string,\n    valueSuffix?: string|null): typeof stylePropInterpolate1 {\n  const lView = getLView();\n  const interpolatedValue = interpolation1(lView, prefix, v0, suffix);\n  checkStylingProperty(prop, interpolatedValue, valueSuffix, false);\n  return stylePropInterpolate1;\n}\n\n/**\n *\n * Update an interpolated style property on an element with 2 bound values surrounded by text.\n *\n * Used when the value passed to a property has 2 interpolated values in it:\n *\n * ```html\n * <div style.color=\"prefix{{v0}}-{{v1}}suffix\"></div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * stylePropInterpolate2(0, 'prefix', v0, '-', v1, 'suffix');\n * ```\n *\n * @param styleIndex Index of style to update. This index value refers to the\n *        index of the style in the style bindings array that was passed into\n *        `styling`.\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @param valueSuffix Optional suffix. Used with scalar values to add unit such as `px`.\n * @returns itself, so that it may be chained.\n * @codeGenApi\n */\nexport function stylePropInterpolate2(\n    prop: string, prefix: string, v0: any, i0: string, v1: any, suffix: string,\n    valueSuffix?: string|null): typeof stylePropInterpolate2 {\n  const lView = getLView();\n  const interpolatedValue = interpolation2(lView, prefix, v0, i0, v1, suffix);\n  checkStylingProperty(prop, interpolatedValue, valueSuffix, false);\n  return stylePropInterpolate2;\n}\n\n/**\n *\n * Update an interpolated style property on an element with 3 bound values surrounded by text.\n *\n * Used when the value passed to a property has 3 interpolated values in it:\n *\n * ```html\n * <div style.color=\"prefix{{v0}}-{{v1}}-{{v2}}suffix\"></div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * stylePropInterpolate3(0, 'prefix', v0, '-', v1, '-', v2, 'suffix');\n * ```\n *\n * @param styleIndex Index of style to update. This index value refers to the\n *        index of the style in the style bindings array that was passed into\n *        `styling`.\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param i1 Static value used for concatenation only.\n * @param v2 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @param valueSuffix Optional suffix. Used with scalar values to add unit such as `px`.\n * @returns itself, so that it may be chained.\n * @codeGenApi\n */\nexport function stylePropInterpolate3(\n    prop: string, prefix: string, v0: any, i0: string, v1: any, i1: string, v2: any, suffix: string,\n    valueSuffix?: string|null): typeof stylePropInterpolate3 {\n  const lView = getLView();\n  const interpolatedValue = interpolation3(lView, prefix, v0, i0, v1, i1, v2, suffix);\n  checkStylingProperty(prop, interpolatedValue, valueSuffix, false);\n  return stylePropInterpolate3;\n}\n\n/**\n *\n * Update an interpolated style property on an element with 4 bound values surrounded by text.\n *\n * Used when the value passed to a property has 4 interpolated values in it:\n *\n * ```html\n * <div style.color=\"prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}suffix\"></div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * stylePropInterpolate4(0, 'prefix', v0, '-', v1, '-', v2, '-', v3, 'suffix');\n * ```\n *\n * @param styleIndex Index of style to update. This index value refers to the\n *        index of the style in the style bindings array that was passed into\n *        `styling`.\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param i1 Static value used for concatenation only.\n * @param v2 Value checked for change.\n * @param i2 Static value used for concatenation only.\n * @param v3 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @param valueSuffix Optional suffix. Used with scalar values to add unit such as `px`.\n * @returns itself, so that it may be chained.\n * @codeGenApi\n */\nexport function stylePropInterpolate4(\n    prop: string, prefix: string, v0: any, i0: string, v1: any, i1: string, v2: any, i2: string,\n    v3: any, suffix: string, valueSuffix?: string|null): typeof stylePropInterpolate4 {\n  const lView = getLView();\n  const interpolatedValue = interpolation4(lView, prefix, v0, i0, v1, i1, v2, i2, v3, suffix);\n  checkStylingProperty(prop, interpolatedValue, valueSuffix, false);\n  return stylePropInterpolate4;\n}\n\n/**\n *\n * Update an interpolated style property on an element with 5 bound values surrounded by text.\n *\n * Used when the value passed to a property has 5 interpolated values in it:\n *\n * ```html\n * <div style.color=\"prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}-{{v4}}suffix\"></div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * stylePropInterpolate5(0, 'prefix', v0, '-', v1, '-', v2, '-', v3, '-', v4, 'suffix');\n * ```\n *\n * @param styleIndex Index of style to update. This index value refers to the\n *        index of the style in the style bindings array that was passed into\n *        `styling`.\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param i1 Static value used for concatenation only.\n * @param v2 Value checked for change.\n * @param i2 Static value used for concatenation only.\n * @param v3 Value checked for change.\n * @param i3 Static value used for concatenation only.\n * @param v4 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @param valueSuffix Optional suffix. Used with scalar values to add unit such as `px`.\n * @returns itself, so that it may be chained.\n * @codeGenApi\n */\nexport function stylePropInterpolate5(\n    prop: string, prefix: string, v0: any, i0: string, v1: any, i1: string, v2: any, i2: string,\n    v3: any, i3: string, v4: any, suffix: string,\n    valueSuffix?: string|null): typeof stylePropInterpolate5 {\n  const lView = getLView();\n  const interpolatedValue =\n      interpolation5(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, suffix);\n  checkStylingProperty(prop, interpolatedValue, valueSuffix, false);\n  return stylePropInterpolate5;\n}\n\n/**\n *\n * Update an interpolated style property on an element with 6 bound values surrounded by text.\n *\n * Used when the value passed to a property has 6 interpolated values in it:\n *\n * ```html\n * <div style.color=\"prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}-{{v4}}-{{v5}}suffix\"></div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * stylePropInterpolate6(0, 'prefix', v0, '-', v1, '-', v2, '-', v3, '-', v4, '-', v5, 'suffix');\n * ```\n *\n * @param styleIndex Index of style to update. This index value refers to the\n *        index of the style in the style bindings array that was passed into\n *        `styling`.\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param i1 Static value used for concatenation only.\n * @param v2 Value checked for change.\n * @param i2 Static value used for concatenation only.\n * @param v3 Value checked for change.\n * @param i3 Static value used for concatenation only.\n * @param v4 Value checked for change.\n * @param i4 Static value used for concatenation only.\n * @param v5 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @param valueSuffix Optional suffix. Used with scalar values to add unit such as `px`.\n * @returns itself, so that it may be chained.\n * @codeGenApi\n */\nexport function stylePropInterpolate6(\n    prop: string, prefix: string, v0: any, i0: string, v1: any, i1: string, v2: any, i2: string,\n    v3: any, i3: string, v4: any, i4: string, v5: any, suffix: string,\n    valueSuffix?: string|null): typeof stylePropInterpolate6 {\n  const lView = getLView();\n  const interpolatedValue =\n      interpolation6(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, suffix);\n  checkStylingProperty(prop, interpolatedValue, valueSuffix, false);\n  return stylePropInterpolate6;\n}\n\n/**\n *\n * Update an interpolated style property on an element with 7 bound values surrounded by text.\n *\n * Used when the value passed to a property has 7 interpolated values in it:\n *\n * ```html\n * <div style.color=\"prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}-{{v4}}-{{v5}}-{{v6}}suffix\"></div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * stylePropInterpolate7(\n *    0, 'prefix', v0, '-', v1, '-', v2, '-', v3, '-', v4, '-', v5, '-', v6, 'suffix');\n * ```\n *\n * @param styleIndex Index of style to update. This index value refers to the\n *        index of the style in the style bindings array that was passed into\n *        `styling`.\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param i1 Static value used for concatenation only.\n * @param v2 Value checked for change.\n * @param i2 Static value used for concatenation only.\n * @param v3 Value checked for change.\n * @param i3 Static value used for concatenation only.\n * @param v4 Value checked for change.\n * @param i4 Static value used for concatenation only.\n * @param v5 Value checked for change.\n * @param i5 Static value used for concatenation only.\n * @param v6 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @param valueSuffix Optional suffix. Used with scalar values to add unit such as `px`.\n * @returns itself, so that it may be chained.\n * @codeGenApi\n */\nexport function stylePropInterpolate7(\n    prop: string, prefix: string, v0: any, i0: string, v1: any, i1: string, v2: any, i2: string,\n    v3: any, i3: string, v4: any, i4: string, v5: any, i5: string, v6: any, suffix: string,\n    valueSuffix?: string|null): typeof stylePropInterpolate7 {\n  const lView = getLView();\n  const interpolatedValue =\n      interpolation7(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, suffix);\n  checkStylingProperty(prop, interpolatedValue, valueSuffix, false);\n  return stylePropInterpolate7;\n}\n\n/**\n *\n * Update an interpolated style property on an element with 8 bound values surrounded by text.\n *\n * Used when the value passed to a property has 8 interpolated values in it:\n *\n * ```html\n * <div style.color=\"prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}-{{v4}}-{{v5}}-{{v6}}-{{v7}}suffix\"></div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * stylePropInterpolate8(0, 'prefix', v0, '-', v1, '-', v2, '-', v3, '-', v4, '-', v5, '-', v6,\n * '-', v7, 'suffix');\n * ```\n *\n * @param styleIndex Index of style to update. This index value refers to the\n *        index of the style in the style bindings array that was passed into\n *        `styling`.\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param i1 Static value used for concatenation only.\n * @param v2 Value checked for change.\n * @param i2 Static value used for concatenation only.\n * @param v3 Value checked for change.\n * @param i3 Static value used for concatenation only.\n * @param v4 Value checked for change.\n * @param i4 Static value used for concatenation only.\n * @param v5 Value checked for change.\n * @param i5 Static value used for concatenation only.\n * @param v6 Value checked for change.\n * @param i6 Static value used for concatenation only.\n * @param v7 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @param valueSuffix Optional suffix. Used with scalar values to add unit such as `px`.\n * @returns itself, so that it may be chained.\n * @codeGenApi\n */\nexport function stylePropInterpolate8(\n    prop: string, prefix: string, v0: any, i0: string, v1: any, i1: string, v2: any, i2: string,\n    v3: any, i3: string, v4: any, i4: string, v5: any, i5: string, v6: any, i6: string, v7: any,\n    suffix: string, valueSuffix?: string|null): typeof stylePropInterpolate8 {\n  const lView = getLView();\n  const interpolatedValue = interpolation8(\n      lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, i6, v7, suffix);\n  checkStylingProperty(prop, interpolatedValue, valueSuffix, false);\n  return stylePropInterpolate8;\n}\n\n/**\n * Update an interpolated style property on an element with 9 or more bound values surrounded by\n * text.\n *\n * Used when the number of interpolated values exceeds 8.\n *\n * ```html\n * <div\n *  style.color=\"prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}-{{v4}}-{{v5}}-{{v6}}-{{v7}}-{{v8}}-{{v9}}suffix\">\n * </div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * stylePropInterpolateV(\n *  0, ['prefix', v0, '-', v1, '-', v2, '-', v3, '-', v4, '-', v5, '-', v6, '-', v7, '-', v9,\n *  'suffix']);\n * ```\n *\n * @param styleIndex Index of style to update. This index value refers to the\n *        index of the style in the style bindings array that was passed into\n *        `styling`..\n * @param values The collection of values and the strings in-between those values, beginning with\n * a string prefix and ending with a string suffix.\n * (e.g. `['prefix', value0, '-', value1, '-', value2, ..., value99, 'suffix']`)\n * @param valueSuffix Optional suffix. Used with scalar values to add unit such as `px`.\n * @returns itself, so that it may be chained.\n * @codeGenApi\n */\nexport function stylePropInterpolateV(\n    prop: string, values: any[], valueSuffix?: string|null): typeof stylePropInterpolateV {\n  const lView = getLView();\n  const interpolatedValue = interpolationV(lView, values);\n  checkStylingProperty(prop, interpolatedValue, valueSuffix, false);\n  return stylePropInterpolateV;\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {RuntimeError, RuntimeErrorCode} from '../errors';\nimport {getTemplateLocationDetails} from '../render3/instructions/element_validation';\nimport {TNodeType} from '../render3/interfaces/node';\nimport {RComment, RElement} from '../render3/interfaces/renderer_dom';\nimport {RENDERER} from '../render3/interfaces/view';\nimport {nativeRemoveNode} from '../render3/node_manipulation';\nimport {getLView, getSelectedTNode} from '../render3/state';\nimport {getNativeByTNode} from '../render3/util/view_utils';\nimport {trustedHTMLFromString} from '../util/security/trusted_types';\n\n\n/**\n * Validation function invoked at runtime for each binding that might potentially\n * represent a security-sensitive attribute of an <iframe>.\n * See `IFRAME_SECURITY_SENSITIVE_ATTRS` in the\n * `packages/compiler/src/schema/dom_security_schema.ts` script for the full list\n * of such attributes.\n *\n * @codeGenApi\n */\nexport function validateIframeAttribute(attrValue: any, tagName: string, attrName: string) {\n  const lView = getLView();\n  const tNode = getSelectedTNode()!;\n  const element = getNativeByTNode(tNode, lView) as RElement | RComment;\n\n  // Restrict any dynamic bindings of security-sensitive attributes/properties\n  // on an <iframe> for security reasons.\n  if (tNode.type === TNodeType.Element && tagName.toLowerCase() === 'iframe') {\n    const iframe = element as HTMLIFrameElement;\n\n    // Unset previously applied `src` and `srcdoc` if we come across a situation when\n    // a security-sensitive attribute is set later via an attribute/property binding.\n    iframe.src = '';\n    iframe.srcdoc = trustedHTMLFromString('') as unknown as string;\n\n    // Also remove the <iframe> from the document.\n    nativeRemoveNode(lView[RENDERER], iframe);\n\n    const errorMessage = ngDevMode &&\n        `Angular has detected that the \\`${attrName}\\` was applied ` +\n            `as a binding to an <iframe>${getTemplateLocationDetails(lView)}. ` +\n            `For security reasons, the \\`${attrName}\\` can be set on an <iframe> ` +\n            `as a static attribute only. \\n` +\n            `To fix this, switch the \\`${attrName}\\` binding to a static attribute ` +\n            `in a template or in host bindings section.`;\n    throw new RuntimeError(RuntimeErrorCode.UNSAFE_IFRAME_ATTRS, errorMessage);\n  }\n  return attrValue;\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {ModuleWithProviders} from '../../di/interface/provider';\nimport {Type} from '../../interface/type';\nimport {NgModuleDef} from '../../metadata/ng_module_def';\nimport {getNgModuleDef} from '../definition';\n\nexport function isModuleWithProviders(value: any): value is ModuleWithProviders<{}> {\n  return (value as {ngModule?: any}).ngModule !== undefined;\n}\n\nexport function isNgModule<T>(value: Type<T>): value is Type<T>&{mod: NgModuleDef<T>} {\n  return !!getNgModuleDef(value);\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {getCompilerFacade, JitCompilerUsage, R3InjectorMetadataFacade} from '../../compiler/compiler_facade';\nimport {resolveForwardRef} from '../../di/forward_ref';\nimport {NG_INJ_DEF} from '../../di/interface/defs';\nimport {ModuleWithProviders} from '../../di/interface/provider';\nimport {reflectDependencies} from '../../di/jit/util';\nimport {Type} from '../../interface/type';\nimport {registerNgModuleType} from '../../linker/ng_module_registration';\nimport {Component} from '../../metadata/directives';\nimport {NgModule} from '../../metadata/ng_module';\nimport {NgModuleDef, NgModuleTransitiveScopes, NgModuleType} from '../../metadata/ng_module_def';\nimport {deepForEach, flatten} from '../../util/array_utils';\nimport {assertDefined} from '../../util/assert';\nimport {EMPTY_ARRAY} from '../../util/empty';\nimport {getComponentDef, getDirectiveDef, getNgModuleDef, getPipeDef, isStandalone} from '../definition';\nimport {NG_COMP_DEF, NG_DIR_DEF, NG_FACTORY_DEF, NG_MOD_DEF, NG_PIPE_DEF} from '../fields';\nimport {ComponentDef} from '../interfaces/definition';\nimport {maybeUnwrapFn} from '../util/misc_utils';\nimport {stringifyForError} from '../util/stringify_utils';\n\nimport {angularCoreEnv} from './environment';\nimport {patchModuleCompilation} from './module_patch';\nimport {isModuleWithProviders, isNgModule} from './util';\n\ninterface ModuleQueueItem {\n  moduleType: Type<any>;\n  ngModule: NgModule;\n}\n\nconst moduleQueue: ModuleQueueItem[] = [];\n\n/**\n * Enqueues moduleDef to be checked later to see if scope can be set on its\n * component declarations.\n */\nfunction enqueueModuleForDelayedScoping(moduleType: Type<any>, ngModule: NgModule) {\n  moduleQueue.push({moduleType, ngModule});\n}\n\nlet flushingModuleQueue = false;\n/**\n * Loops over queued module definitions, if a given module definition has all of its\n * declarations resolved, it dequeues that module definition and sets the scope on\n * its declarations.\n */\nexport function flushModuleScopingQueueAsMuchAsPossible() {\n  if (!flushingModuleQueue) {\n    flushingModuleQueue = true;\n    try {\n      for (let i = moduleQueue.length - 1; i >= 0; i--) {\n        const {moduleType, ngModule} = moduleQueue[i];\n\n        if (ngModule.declarations && ngModule.declarations.every(isResolvedDeclaration)) {\n          // dequeue\n          moduleQueue.splice(i, 1);\n          setScopeOnDeclaredComponents(moduleType, ngModule);\n        }\n      }\n    } finally {\n      flushingModuleQueue = false;\n    }\n  }\n}\n\n/**\n * Returns truthy if a declaration has resolved. If the declaration happens to be\n * an array of declarations, it will recurse to check each declaration in that array\n * (which may also be arrays).\n */\nfunction isResolvedDeclaration(declaration: any[]|Type<any>): boolean {\n  if (Array.isArray(declaration)) {\n    return declaration.every(isResolvedDeclaration);\n  }\n  return !!resolveForwardRef(declaration);\n}\n\n/**\n * Compiles a module in JIT mode.\n *\n * This function automatically gets called when a class has a `@NgModule` decorator.\n */\nexport function compileNgModule(moduleType: Type<any>, ngModule: NgModule = {}): void {\n  patchModuleCompilation();\n  compileNgModuleDefs(moduleType as NgModuleType, ngModule);\n  if (ngModule.id !== undefined) {\n    registerNgModuleType(moduleType as NgModuleType, ngModule.id);\n  }\n\n  // Because we don't know if all declarations have resolved yet at the moment the\n  // NgModule decorator is executing, we're enqueueing the setting of module scope\n  // on its declarations to be run at a later time when all declarations for the module,\n  // including forward refs, have resolved.\n  enqueueModuleForDelayedScoping(moduleType, ngModule);\n}\n\n/**\n * Compiles and adds the `mod`, `fac` and `inj` properties to the module class.\n *\n * It's possible to compile a module via this API which will allow duplicate declarations in its\n * root.\n */\nexport function compileNgModuleDefs(\n    moduleType: NgModuleType, ngModule: NgModule,\n    allowDuplicateDeclarationsInRoot: boolean = false): void {\n  ngDevMode && assertDefined(moduleType, 'Required value moduleType');\n  ngDevMode && assertDefined(ngModule, 'Required value ngModule');\n  const declarations: Type<any>[] = flatten(ngModule.declarations || EMPTY_ARRAY);\n  let ngModuleDef: any = null;\n  Object.defineProperty(moduleType, NG_MOD_DEF, {\n    configurable: true,\n    get: () => {\n      if (ngModuleDef === null) {\n        if (ngDevMode && ngModule.imports && ngModule.imports.indexOf(moduleType) > -1) {\n          // We need to assert this immediately, because allowing it to continue will cause it to\n          // go into an infinite loop before we've reached the point where we throw all the errors.\n          throw new Error(`'${stringifyForError(moduleType)}' module can't import itself`);\n        }\n        const compiler = getCompilerFacade(\n            {usage: JitCompilerUsage.Decorator, kind: 'NgModule', type: moduleType});\n        ngModuleDef = compiler.compileNgModule(angularCoreEnv, `ng:///${moduleType.name}/mod.js`, {\n          type: moduleType,\n          bootstrap: flatten(ngModule.bootstrap || EMPTY_ARRAY).map(resolveForwardRef),\n          declarations: declarations.map(resolveForwardRef),\n          imports: flatten(ngModule.imports || EMPTY_ARRAY)\n                       .map(resolveForwardRef)\n                       .map(expandModuleWithProviders),\n          exports: flatten(ngModule.exports || EMPTY_ARRAY)\n                       .map(resolveForwardRef)\n                       .map(expandModuleWithProviders),\n          schemas: ngModule.schemas ? flatten(ngModule.schemas) : null,\n          id: ngModule.id || null,\n        });\n        // Set `schemas` on ngModuleDef to an empty array in JIT mode to indicate that runtime\n        // should verify that there are no unknown elements in a template. In AOT mode, that check\n        // happens at compile time and `schemas` information is not present on Component and Module\n        // defs after compilation (so the check doesn't happen the second time at runtime).\n        if (!ngModuleDef.schemas) {\n          ngModuleDef.schemas = [];\n        }\n      }\n      return ngModuleDef;\n    }\n  });\n\n  let ngFactoryDef: any = null;\n  Object.defineProperty(moduleType, NG_FACTORY_DEF, {\n    get: () => {\n      if (ngFactoryDef === null) {\n        const compiler = getCompilerFacade(\n            {usage: JitCompilerUsage.Decorator, kind: 'NgModule', type: moduleType});\n        ngFactoryDef = compiler.compileFactory(angularCoreEnv, `ng:///${moduleType.name}/fac.js`, {\n          name: moduleType.name,\n          type: moduleType,\n          deps: reflectDependencies(moduleType),\n          target: compiler.FactoryTarget.NgModule,\n          typeArgumentCount: 0,\n        });\n      }\n      return ngFactoryDef;\n    },\n    // Make the property configurable in dev mode to allow overriding in tests\n    configurable: !!ngDevMode,\n  });\n\n  let ngInjectorDef: any = null;\n  Object.defineProperty(moduleType, NG_INJ_DEF, {\n    get: () => {\n      if (ngInjectorDef === null) {\n        ngDevMode && verifySemanticsOfNgModuleDef(moduleType, allowDuplicateDeclarationsInRoot);\n        const meta: R3InjectorMetadataFacade = {\n          name: moduleType.name,\n          type: moduleType,\n          providers: ngModule.providers || EMPTY_ARRAY,\n          imports: [\n            (ngModule.imports || EMPTY_ARRAY).map(resolveForwardRef),\n            (ngModule.exports || EMPTY_ARRAY).map(resolveForwardRef),\n          ],\n        };\n        const compiler = getCompilerFacade(\n            {usage: JitCompilerUsage.Decorator, kind: 'NgModule', type: moduleType});\n        ngInjectorDef =\n            compiler.compileInjector(angularCoreEnv, `ng:///${moduleType.name}/inj.js`, meta);\n      }\n      return ngInjectorDef;\n    },\n    // Make the property configurable in dev mode to allow overriding in tests\n    configurable: !!ngDevMode,\n  });\n}\n\nexport function generateStandaloneInDeclarationsError(type: Type<any>, location: string) {\n  const prefix = `Unexpected \"${stringifyForError(type)}\" found in the \"declarations\" array of the`;\n  const suffix = `\"${stringifyForError(type)}\" is marked as standalone and can't be declared ` +\n      'in any NgModule - did you intend to import it instead (by adding it to the \"imports\" array)?';\n  return `${prefix} ${location}, ${suffix}`;\n}\n\nfunction verifySemanticsOfNgModuleDef(\n    moduleType: NgModuleType, allowDuplicateDeclarationsInRoot: boolean,\n    importingModule?: NgModuleType): void {\n  if (verifiedNgModule.get(moduleType)) return;\n\n  // skip verifications of standalone components, directives, and pipes\n  if (isStandalone(moduleType)) return;\n\n  verifiedNgModule.set(moduleType, true);\n  moduleType = resolveForwardRef(moduleType);\n  let ngModuleDef: NgModuleDef<any>;\n  if (importingModule) {\n    ngModuleDef = getNgModuleDef(moduleType)!;\n    if (!ngModuleDef) {\n      throw new Error(`Unexpected value '${moduleType.name}' imported by the module '${\n          importingModule.name}'. Please add an @NgModule annotation.`);\n    }\n  } else {\n    ngModuleDef = getNgModuleDef(moduleType, true);\n  }\n  const errors: string[] = [];\n  const declarations = maybeUnwrapFn(ngModuleDef.declarations);\n  const imports = maybeUnwrapFn(ngModuleDef.imports);\n  flatten(imports).map(unwrapModuleWithProvidersImports).forEach(modOrStandaloneCmpt => {\n    verifySemanticsOfNgModuleImport(modOrStandaloneCmpt, moduleType);\n    verifySemanticsOfNgModuleDef(modOrStandaloneCmpt, false, moduleType);\n  });\n  const exports = maybeUnwrapFn(ngModuleDef.exports);\n  declarations.forEach(verifyDeclarationsHaveDefinitions);\n  declarations.forEach(verifyDirectivesHaveSelector);\n  declarations.forEach((declarationType) => verifyNotStandalone(declarationType, moduleType));\n  const combinedDeclarations: Type<any>[] = [\n    ...declarations.map(resolveForwardRef),\n    ...flatten(imports.map(computeCombinedExports)).map(resolveForwardRef),\n  ];\n  exports.forEach(verifyExportsAreDeclaredOrReExported);\n  declarations.forEach(decl => verifyDeclarationIsUnique(decl, allowDuplicateDeclarationsInRoot));\n  declarations.forEach(verifyComponentEntryComponentsIsPartOfNgModule);\n\n  const ngModule = getAnnotation<NgModule>(moduleType, 'NgModule');\n  if (ngModule) {\n    ngModule.imports &&\n        flatten(ngModule.imports).map(unwrapModuleWithProvidersImports).forEach(mod => {\n          verifySemanticsOfNgModuleImport(mod, moduleType);\n          verifySemanticsOfNgModuleDef(mod, false, moduleType);\n        });\n    ngModule.bootstrap && deepForEach(ngModule.bootstrap, verifyCorrectBootstrapType);\n    ngModule.bootstrap && deepForEach(ngModule.bootstrap, verifyComponentIsPartOfNgModule);\n    ngModule.entryComponents &&\n        deepForEach(ngModule.entryComponents, verifyComponentIsPartOfNgModule);\n  }\n\n  // Throw Error if any errors were detected.\n  if (errors.length) {\n    throw new Error(errors.join('\\n'));\n  }\n  ////////////////////////////////////////////////////////////////////////////////////////////////\n  function verifyDeclarationsHaveDefinitions(type: Type<any>): void {\n    type = resolveForwardRef(type);\n    const def = getComponentDef(type) || getDirectiveDef(type) || getPipeDef(type);\n    if (!def) {\n      errors.push(`Unexpected value '${stringifyForError(type)}' declared by the module '${\n          stringifyForError(moduleType)}'. Please add a @Pipe/@Directive/@Component annotation.`);\n    }\n  }\n\n  function verifyDirectivesHaveSelector(type: Type<any>): void {\n    type = resolveForwardRef(type);\n    const def = getDirectiveDef(type);\n    if (!getComponentDef(type) && def && def.selectors.length == 0) {\n      errors.push(`Directive ${stringifyForError(type)} has no selector, please add it!`);\n    }\n  }\n\n  function verifyNotStandalone(type: Type<any>, moduleType: NgModuleType): void {\n    type = resolveForwardRef(type);\n    const def = getComponentDef(type) || getDirectiveDef(type) || getPipeDef(type);\n    if (def?.standalone) {\n      const location = `\"${stringifyForError(moduleType)}\" NgModule`;\n      errors.push(generateStandaloneInDeclarationsError(type, location));\n    }\n  }\n\n  function verifyExportsAreDeclaredOrReExported(type: Type<any>) {\n    type = resolveForwardRef(type);\n    const kind = getComponentDef(type) && 'component' || getDirectiveDef(type) && 'directive' ||\n        getPipeDef(type) && 'pipe';\n    if (kind) {\n      // only checked if we are declared as Component, Directive, or Pipe\n      // Modules don't need to be declared or imported.\n      if (combinedDeclarations.lastIndexOf(type) === -1) {\n        // We are exporting something which we don't explicitly declare or import.\n        errors.push(`Can't export ${kind} ${stringifyForError(type)} from ${\n            stringifyForError(moduleType)} as it was neither declared nor imported!`);\n      }\n    }\n  }\n\n  function verifyDeclarationIsUnique(type: Type<any>, suppressErrors: boolean) {\n    type = resolveForwardRef(type);\n    const existingModule = ownerNgModule.get(type);\n    if (existingModule && existingModule !== moduleType) {\n      if (!suppressErrors) {\n        const modules = [existingModule, moduleType].map(stringifyForError).sort();\n        errors.push(\n            `Type ${stringifyForError(type)} is part of the declarations of 2 modules: ${\n                modules[0]} and ${modules[1]}! ` +\n            `Please consider moving ${stringifyForError(type)} to a higher module that imports ${\n                modules[0]} and ${modules[1]}. ` +\n            `You can also create a new NgModule that exports and includes ${\n                stringifyForError(\n                    type)} then import that NgModule in ${modules[0]} and ${modules[1]}.`);\n      }\n    } else {\n      // Mark type as having owner.\n      ownerNgModule.set(type, moduleType);\n    }\n  }\n\n  function verifyComponentIsPartOfNgModule(type: Type<any>) {\n    type = resolveForwardRef(type);\n    const existingModule = ownerNgModule.get(type);\n    if (!existingModule && !isStandalone(type)) {\n      errors.push(`Component ${\n          stringifyForError(\n              type)} is not part of any NgModule or the module has not been imported into your module.`);\n    }\n  }\n\n  function verifyCorrectBootstrapType(type: Type<any>) {\n    type = resolveForwardRef(type);\n    if (!getComponentDef(type)) {\n      errors.push(`${stringifyForError(type)} cannot be used as an entry component.`);\n    }\n    if (isStandalone(type)) {\n      // Note: this error should be the same as the\n      // `NGMODULE_BOOTSTRAP_IS_STANDALONE` one in AOT compiler.\n      errors.push(\n          `The \\`${stringifyForError(type)}\\` class is a standalone component, which can ` +\n          `not be used in the \\`@NgModule.bootstrap\\` array. Use the \\`bootstrapApplication\\` ` +\n          `function for bootstrap instead.`);\n    }\n  }\n\n  function verifyComponentEntryComponentsIsPartOfNgModule(type: Type<any>) {\n    type = resolveForwardRef(type);\n    if (getComponentDef(type)) {\n      // We know we are component\n      const component = getAnnotation<Component>(type, 'Component');\n      if (component && component.entryComponents) {\n        deepForEach(component.entryComponents, verifyComponentIsPartOfNgModule);\n      }\n    }\n  }\n\n  function verifySemanticsOfNgModuleImport(type: Type<any>, importingModule: Type<any>) {\n    type = resolveForwardRef(type);\n\n    const directiveDef = getComponentDef(type) || getDirectiveDef(type);\n    if (directiveDef !== null && !directiveDef.standalone) {\n      throw new Error(`Unexpected directive '${type.name}' imported by the module '${\n          importingModule.name}'. Please add an @NgModule annotation.`);\n    }\n\n    const pipeDef = getPipeDef(type);\n    if (pipeDef !== null && !pipeDef.standalone) {\n      throw new Error(`Unexpected pipe '${type.name}' imported by the module '${\n          importingModule.name}'. Please add an @NgModule annotation.`);\n    }\n  }\n}\n\nfunction unwrapModuleWithProvidersImports(typeOrWithProviders: NgModuleType<any>|\n                                          {ngModule: NgModuleType<any>}): NgModuleType<any> {\n  typeOrWithProviders = resolveForwardRef(typeOrWithProviders);\n  return (typeOrWithProviders as any).ngModule || typeOrWithProviders;\n}\n\nfunction getAnnotation<T>(type: any, name: string): T|null {\n  let annotation: T|null = null;\n  collect(type.__annotations__);\n  collect(type.decorators);\n  return annotation;\n\n  function collect(annotations: any[]|null) {\n    if (annotations) {\n      annotations.forEach(readAnnotation);\n    }\n  }\n\n  function readAnnotation(\n      decorator: {type: {prototype: {ngMetadataName: string}, args: any[]}, args: any}): void {\n    if (!annotation) {\n      const proto = Object.getPrototypeOf(decorator);\n      if (proto.ngMetadataName == name) {\n        annotation = decorator as any;\n      } else if (decorator.type) {\n        const proto = Object.getPrototypeOf(decorator.type);\n        if (proto.ngMetadataName == name) {\n          annotation = decorator.args[0];\n        }\n      }\n    }\n  }\n}\n\n/**\n * Keep track of compiled components. This is needed because in tests we often want to compile the\n * same component with more than one NgModule. This would cause an error unless we reset which\n * NgModule the component belongs to. We keep the list of compiled components here so that the\n * TestBed can reset it later.\n */\nlet ownerNgModule = new WeakMap<Type<any>, NgModuleType<any>>();\nlet verifiedNgModule = new WeakMap<NgModuleType<any>, boolean>();\n\nexport function resetCompiledComponents(): void {\n  ownerNgModule = new WeakMap<Type<any>, NgModuleType<any>>();\n  verifiedNgModule = new WeakMap<NgModuleType<any>, boolean>();\n  moduleQueue.length = 0;\n}\n\n/**\n * Computes the combined declarations of explicit declarations, as well as declarations inherited by\n * traversing the exports of imported modules.\n * @param type\n */\nfunction computeCombinedExports(type: Type<any>): Type<any>[] {\n  type = resolveForwardRef(type);\n  const ngModuleDef = getNgModuleDef(type);\n\n  // a standalone component, directive or pipe\n  if (ngModuleDef === null) {\n    return [type];\n  }\n\n  return [...flatten(maybeUnwrapFn(ngModuleDef.exports).map((type) => {\n    const ngModuleDef = getNgModuleDef(type);\n    if (ngModuleDef) {\n      verifySemanticsOfNgModuleDef(type as any as NgModuleType, false);\n      return computeCombinedExports(type);\n    } else {\n      return type;\n    }\n  }))];\n}\n\n/**\n * Some declared components may be compiled asynchronously, and thus may not have their\n * cmp set yet. If this is the case, then a reference to the module is written into\n * the `ngSelectorScope` property of the declared type.\n */\nfunction setScopeOnDeclaredComponents(moduleType: Type<any>, ngModule: NgModule) {\n  const declarations: Type<any>[] = flatten(ngModule.declarations || EMPTY_ARRAY);\n\n  const transitiveScopes = transitiveScopesFor(moduleType);\n\n  declarations.forEach(declaration => {\n    declaration = resolveForwardRef(declaration);\n    if (declaration.hasOwnProperty(NG_COMP_DEF)) {\n      // A `cmp` field exists - go ahead and patch the component directly.\n      const component = declaration as Type<any>& {cmp: ComponentDef<any>};\n      const componentDef = getComponentDef(component)!;\n      patchComponentDefWithScope(componentDef, transitiveScopes);\n    } else if (\n        !declaration.hasOwnProperty(NG_DIR_DEF) && !declaration.hasOwnProperty(NG_PIPE_DEF)) {\n      // Set `ngSelectorScope` for future reference when the component compilation finishes.\n      (declaration as Type<any>& {ngSelectorScope?: any}).ngSelectorScope = moduleType;\n    }\n  });\n}\n\n/**\n * Patch the definition of a component with directives and pipes from the compilation scope of\n * a given module.\n */\nexport function patchComponentDefWithScope<C>(\n    componentDef: ComponentDef<C>, transitiveScopes: NgModuleTransitiveScopes) {\n  componentDef.directiveDefs = () =>\n      Array.from(transitiveScopes.compilation.directives)\n          .map(\n              dir => dir.hasOwnProperty(NG_COMP_DEF) ? getComponentDef(dir)! : getDirectiveDef(dir)!\n              )\n          .filter(def => !!def);\n  componentDef.pipeDefs = () =>\n      Array.from(transitiveScopes.compilation.pipes).map(pipe => getPipeDef(pipe)!);\n  componentDef.schemas = transitiveScopes.schemas;\n\n  // Since we avoid Components/Directives/Pipes recompiling in case there are no overrides, we\n  // may face a problem where previously compiled defs available to a given Component/Directive\n  // are cached in TView and may become stale (in case any of these defs gets recompiled). In\n  // order to avoid this problem, we force fresh TView to be created.\n  componentDef.tView = null;\n}\n\n/**\n * Compute the pair of transitive scopes (compilation scope and exported scope) for a given type\n * (either a NgModule or a standalone component / directive / pipe).\n */\nexport function transitiveScopesFor<T>(type: Type<T>): NgModuleTransitiveScopes {\n  if (isNgModule(type)) {\n    return transitiveScopesForNgModule(type);\n  } else if (isStandalone(type)) {\n    const directiveDef = getComponentDef(type) || getDirectiveDef(type);\n    if (directiveDef !== null) {\n      return {\n        schemas: null,\n        compilation: {\n          directives: new Set<any>(),\n          pipes: new Set<any>(),\n        },\n        exported: {\n          directives: new Set<any>([type]),\n          pipes: new Set<any>(),\n        },\n      };\n    }\n\n    const pipeDef = getPipeDef(type);\n    if (pipeDef !== null) {\n      return {\n        schemas: null,\n        compilation: {\n          directives: new Set<any>(),\n          pipes: new Set<any>(),\n        },\n        exported: {\n          directives: new Set<any>(),\n          pipes: new Set<any>([type]),\n        },\n      };\n    }\n  }\n\n  // TODO: change the error message to be more user-facing and take standalone into account\n  throw new Error(`${type.name} does not have a module def (mod property)`);\n}\n\n/**\n * Compute the pair of transitive scopes (compilation scope and exported scope) for a given module.\n *\n * This operation is memoized and the result is cached on the module's definition. This function can\n * be called on modules with components that have not fully compiled yet, but the result should not\n * be used until they have.\n *\n * @param moduleType module that transitive scope should be calculated for.\n */\nexport function transitiveScopesForNgModule<T>(moduleType: Type<T>): NgModuleTransitiveScopes {\n  const def = getNgModuleDef(moduleType, true);\n\n  if (def.transitiveCompileScopes !== null) {\n    return def.transitiveCompileScopes;\n  }\n\n  const scopes: NgModuleTransitiveScopes = {\n    schemas: def.schemas || null,\n    compilation: {\n      directives: new Set<any>(),\n      pipes: new Set<any>(),\n    },\n    exported: {\n      directives: new Set<any>(),\n      pipes: new Set<any>(),\n    },\n  };\n\n  maybeUnwrapFn(def.imports).forEach(<I>(imported: Type<I>) => {\n    // When this module imports another, the imported module's exported directives and pipes are\n    // added to the compilation scope of this module.\n    const importedScope = transitiveScopesFor(imported);\n    importedScope.exported.directives.forEach(entry => scopes.compilation.directives.add(entry));\n    importedScope.exported.pipes.forEach(entry => scopes.compilation.pipes.add(entry));\n  });\n\n  maybeUnwrapFn(def.declarations).forEach(declared => {\n    const declaredWithDefs = declared as Type<any>& {\n      pipe?: any;\n    };\n\n    if (getPipeDef(declaredWithDefs)) {\n      scopes.compilation.pipes.add(declared);\n    } else {\n      // Either declared has a cmp or dir, or it's a component which hasn't\n      // had its template compiled yet. In either case, it gets added to the compilation's\n      // directives.\n      scopes.compilation.directives.add(declared);\n    }\n  });\n\n  maybeUnwrapFn(def.exports).forEach(<E>(exported: Type<E>) => {\n    const exportedType = exported as Type<E>& {\n      // Components, Directives, NgModules, and Pipes can all be exported.\n      cmp?: any;\n      dir?: any;\n      mod?: NgModuleDef<E>;\n      pipe?: any;\n    };\n\n    // Either the type is a module, a pipe, or a component/directive (which may not have a\n    // cmp as it might be compiled asynchronously).\n    if (isNgModule(exportedType)) {\n      // When this module exports another, the exported module's exported directives and pipes are\n      // added to both the compilation and exported scopes of this module.\n      const exportedScope = transitiveScopesFor(exportedType);\n      exportedScope.exported.directives.forEach(entry => {\n        scopes.compilation.directives.add(entry);\n        scopes.exported.directives.add(entry);\n      });\n      exportedScope.exported.pipes.forEach(entry => {\n        scopes.compilation.pipes.add(entry);\n        scopes.exported.pipes.add(entry);\n      });\n    } else if (getPipeDef(exportedType)) {\n      scopes.exported.pipes.add(exportedType);\n    } else {\n      scopes.exported.directives.add(exportedType);\n    }\n  });\n\n  def.transitiveCompileScopes = scopes;\n  return scopes;\n}\n\nfunction expandModuleWithProviders(value: Type<any>|ModuleWithProviders<{}>): Type<any> {\n  if (isModuleWithProviders(value)) {\n    return value.ngModule;\n  }\n  return value;\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {getCompilerFacade, JitCompilerUsage, R3DirectiveMetadataFacade} from '../../compiler/compiler_facade';\nimport {R3ComponentMetadataFacade, R3QueryMetadataFacade} from '../../compiler/compiler_facade_interface';\nimport {isForwardRef, resolveForwardRef} from '../../di/forward_ref';\nimport {getReflect, reflectDependencies} from '../../di/jit/util';\nimport {Type} from '../../interface/type';\nimport {Query} from '../../metadata/di';\nimport {Component, Directive, Input} from '../../metadata/directives';\nimport {componentNeedsResolution, maybeQueueResolutionOfComponentResources} from '../../metadata/resource_loading';\nimport {ViewEncapsulation} from '../../metadata/view';\nimport {flatten} from '../../util/array_utils';\nimport {EMPTY_ARRAY, EMPTY_OBJ} from '../../util/empty';\nimport {initNgDevMode} from '../../util/ng_dev_mode';\nimport {getComponentDef, getDirectiveDef, getNgModuleDef, getPipeDef} from '../definition';\nimport {NG_COMP_DEF, NG_DIR_DEF, NG_FACTORY_DEF} from '../fields';\nimport {ComponentDef, ComponentType, DirectiveDefList, PipeDefList} from '../interfaces/definition';\nimport {stringifyForError} from '../util/stringify_utils';\n\nimport {angularCoreEnv} from './environment';\nimport {getJitOptions} from './jit_options';\nimport {flushModuleScopingQueueAsMuchAsPossible, patchComponentDefWithScope, transitiveScopesFor} from './module';\nimport {isModuleWithProviders} from './util';\n\n/**\n * Keep track of the compilation depth to avoid reentrancy issues during JIT compilation. This\n * matters in the following scenario:\n *\n * Consider a component 'A' that extends component 'B', both declared in module 'M'. During\n * the compilation of 'A' the definition of 'B' is requested to capture the inheritance chain,\n * potentially triggering compilation of 'B'. If this nested compilation were to trigger\n * `flushModuleScopingQueueAsMuchAsPossible` it may happen that module 'M' is still pending in the\n * queue, resulting in 'A' and 'B' to be patched with the NgModule scope. As the compilation of\n * 'A' is still in progress, this would introduce a circular dependency on its compilation. To avoid\n * this issue, the module scope queue is only flushed for compilations at the depth 0, to ensure\n * all compilations have finished.\n */\nlet compilationDepth = 0;\n\n/**\n * Compile an Angular component according to its decorator metadata, and patch the resulting\n * component def (cmp) onto the component type.\n *\n * Compilation may be asynchronous (due to the need to resolve URLs for the component template or\n * other resources, for example). In the event that compilation is not immediate, `compileComponent`\n * will enqueue resource resolution into a global queue and will fail to return the `cmp`\n * until the global queue has been resolved with a call to `resolveComponentResources`.\n */\nexport function compileComponent(type: Type<any>, metadata: Component): void {\n  // Initialize ngDevMode. This must be the first statement in compileComponent.\n  // See the `initNgDevMode` docstring for more information.\n  (typeof ngDevMode === 'undefined' || ngDevMode) && initNgDevMode();\n\n  let ngComponentDef: ComponentDef<unknown>|null = null;\n\n  // Metadata may have resources which need to be resolved.\n  maybeQueueResolutionOfComponentResources(type, metadata);\n\n  // Note that we're using the same function as `Directive`, because that's only subset of metadata\n  // that we need to create the ngFactoryDef. We're avoiding using the component metadata\n  // because we'd have to resolve the asynchronous templates.\n  addDirectiveFactoryDef(type, metadata);\n\n  Object.defineProperty(type, NG_COMP_DEF, {\n    get: () => {\n      if (ngComponentDef === null) {\n        const compiler =\n            getCompilerFacade({usage: JitCompilerUsage.Decorator, kind: 'component', type: type});\n\n        if (componentNeedsResolution(metadata)) {\n          const error = [`Component '${type.name}' is not resolved:`];\n          if (metadata.templateUrl) {\n            error.push(` - templateUrl: ${metadata.templateUrl}`);\n          }\n          if (metadata.styleUrls && metadata.styleUrls.length) {\n            error.push(` - styleUrls: ${JSON.stringify(metadata.styleUrls)}`);\n          }\n          error.push(`Did you run and wait for 'resolveComponentResources()'?`);\n          throw new Error(error.join('\\n'));\n        }\n\n        // This const was called `jitOptions` previously but had to be renamed to `options` because\n        // of a bug with Terser that caused optimized JIT builds to throw a `ReferenceError`.\n        // This bug was investigated in https://github.com/angular/angular-cli/issues/17264.\n        // We should not rename it back until https://github.com/terser/terser/issues/615 is fixed.\n        const options = getJitOptions();\n        let preserveWhitespaces = metadata.preserveWhitespaces;\n        if (preserveWhitespaces === undefined) {\n          if (options !== null && options.preserveWhitespaces !== undefined) {\n            preserveWhitespaces = options.preserveWhitespaces;\n          } else {\n            preserveWhitespaces = false;\n          }\n        }\n        let encapsulation = metadata.encapsulation;\n        if (encapsulation === undefined) {\n          if (options !== null && options.defaultEncapsulation !== undefined) {\n            encapsulation = options.defaultEncapsulation;\n          } else {\n            encapsulation = ViewEncapsulation.Emulated;\n          }\n        }\n\n        const templateUrl = metadata.templateUrl || `ng:///${type.name}/template.html`;\n        const meta: R3ComponentMetadataFacade = {\n          ...directiveMetadata(type, metadata),\n          typeSourceSpan: compiler.createParseSourceSpan('Component', type.name, templateUrl),\n          template: metadata.template || '',\n          preserveWhitespaces,\n          styles: metadata.styles || EMPTY_ARRAY,\n          animations: metadata.animations,\n          // JIT components are always compiled against an empty set of `declarations`. Instead, the\n          // `directiveDefs` and `pipeDefs` are updated at a later point:\n          //  * for NgModule-based components, they're set when the NgModule which declares the\n          //    component resolves in the module scoping queue\n          //  * for standalone components, they're set just below, after `compileComponent`.\n          declarations: [],\n          changeDetection: metadata.changeDetection,\n          encapsulation,\n          interpolation: metadata.interpolation,\n          viewProviders: metadata.viewProviders || null,\n          isStandalone: !!metadata.standalone,\n        };\n\n        compilationDepth++;\n        try {\n          if (meta.usesInheritance) {\n            addDirectiveDefToUndecoratedParents(type);\n          }\n          ngComponentDef =\n              compiler.compileComponent(angularCoreEnv, templateUrl, meta) as ComponentDef<unknown>;\n\n          if (metadata.standalone) {\n            // Patch the component definition for standalone components with `directiveDefs` and\n            // `pipeDefs` functions which lazily compute the directives/pipes available in the\n            // standalone component. Also set `dependencies` to the lazily resolved list of imports.\n            const imports: Type<any>[] = flatten(metadata.imports || EMPTY_ARRAY);\n            const {directiveDefs, pipeDefs} = getStandaloneDefFunctions(type, imports);\n            ngComponentDef.directiveDefs = directiveDefs;\n            ngComponentDef.pipeDefs = pipeDefs;\n            ngComponentDef.dependencies = () => imports.map(resolveForwardRef);\n          }\n        } finally {\n          // Ensure that the compilation depth is decremented even when the compilation failed.\n          compilationDepth--;\n        }\n\n        if (compilationDepth === 0) {\n          // When NgModule decorator executed, we enqueued the module definition such that\n          // it would only dequeue and add itself as module scope to all of its declarations,\n          // but only if  if all of its declarations had resolved. This call runs the check\n          // to see if any modules that are in the queue can be dequeued and add scope to\n          // their declarations.\n          flushModuleScopingQueueAsMuchAsPossible();\n        }\n\n        // If component compilation is async, then the @NgModule annotation which declares the\n        // component may execute and set an ngSelectorScope property on the component type. This\n        // allows the component to patch itself with directiveDefs from the module after it\n        // finishes compiling.\n        if (hasSelectorScope(type)) {\n          const scopes = transitiveScopesFor(type.ngSelectorScope);\n          patchComponentDefWithScope(ngComponentDef, scopes);\n        }\n\n        if (metadata.schemas) {\n          if (metadata.standalone) {\n            ngComponentDef.schemas = metadata.schemas;\n          } else {\n            throw new Error(`The 'schemas' was specified for the ${\n                stringifyForError(type)} but is only valid on a component that is standalone.`);\n          }\n        } else if (metadata.standalone) {\n          ngComponentDef.schemas = [];\n        }\n      }\n      return ngComponentDef;\n    },\n    // Make the property configurable in dev mode to allow overriding in tests\n    configurable: !!ngDevMode,\n  });\n}\n\nfunction getDependencyTypeForError(type: Type<any>) {\n  if (getComponentDef(type)) return 'component';\n  if (getDirectiveDef(type)) return 'directive';\n  if (getPipeDef(type)) return 'pipe';\n  return 'type';\n}\n\nfunction verifyStandaloneImport(depType: Type<unknown>, importingType: Type<unknown>) {\n  if (isForwardRef(depType)) {\n    depType = resolveForwardRef(depType);\n    if (!depType) {\n      throw new Error(`Expected forwardRef function, imported from \"${\n          stringifyForError(importingType)}\", to return a standalone entity or NgModule but got \"${\n          stringifyForError(depType) || depType}\".`);\n    }\n  }\n\n  if (getNgModuleDef(depType) == null) {\n    const def = getComponentDef(depType) || getDirectiveDef(depType) || getPipeDef(depType);\n    if (def != null) {\n      // if a component, directive or pipe is imported make sure that it is standalone\n      if (!def.standalone) {\n        throw new Error(`The \"${stringifyForError(depType)}\" ${\n            getDependencyTypeForError(depType)}, imported from \"${\n            stringifyForError(\n                importingType)}\", is not standalone. Did you forget to add the standalone: true flag?`);\n      }\n    } else {\n      // it can be either a module with provider or an unknown (not annotated) type\n      if (isModuleWithProviders(depType)) {\n        throw new Error(`A module with providers was imported from \"${\n            stringifyForError(\n                importingType)}\". Modules with providers are not supported in standalone components imports.`);\n      } else {\n        throw new Error(`The \"${stringifyForError(depType)}\" type, imported from \"${\n            stringifyForError(\n                importingType)}\", must be a standalone component / directive / pipe or an NgModule. Did you forget to add the required @Component / @Directive / @Pipe or @NgModule annotation?`);\n      }\n    }\n  }\n}\n\n/**\n * Build memoized `directiveDefs` and `pipeDefs` functions for the component definition of a\n * standalone component, which process `imports` and filter out directives and pipes. The use of\n * memoized functions here allows for the delayed resolution of any `forwardRef`s present in the\n * component's `imports`.\n */\nfunction getStandaloneDefFunctions(type: Type<any>, imports: Type<any>[]): {\n  directiveDefs: () => DirectiveDefList,\n  pipeDefs: () => PipeDefList,\n} {\n  let cachedDirectiveDefs: DirectiveDefList|null = null;\n  let cachedPipeDefs: PipeDefList|null = null;\n  const directiveDefs = () => {\n    if (cachedDirectiveDefs === null) {\n      // Standalone components are always able to self-reference, so include the component's own\n      // definition in its `directiveDefs`.\n      cachedDirectiveDefs = [getComponentDef(type)!];\n      const seen = new Set<Type<unknown>>();\n\n      for (const rawDep of imports) {\n        ngDevMode && verifyStandaloneImport(rawDep, type);\n\n        const dep = resolveForwardRef(rawDep);\n        if (seen.has(dep)) {\n          continue;\n        }\n        seen.add(dep);\n\n        if (!!getNgModuleDef(dep)) {\n          const scope = transitiveScopesFor(dep);\n          for (const dir of scope.exported.directives) {\n            const def = getComponentDef(dir) || getDirectiveDef(dir);\n            if (def && !seen.has(dir)) {\n              seen.add(dir);\n              cachedDirectiveDefs.push(def);\n            }\n          }\n        } else {\n          const def = getComponentDef(dep) || getDirectiveDef(dep);\n          if (def) {\n            cachedDirectiveDefs.push(def);\n          }\n        }\n      }\n    }\n    return cachedDirectiveDefs;\n  };\n\n  const pipeDefs = () => {\n    if (cachedPipeDefs === null) {\n      cachedPipeDefs = [];\n      const seen = new Set<Type<unknown>>();\n\n      for (const rawDep of imports) {\n        const dep = resolveForwardRef(rawDep);\n        if (seen.has(dep)) {\n          continue;\n        }\n        seen.add(dep);\n\n        if (!!getNgModuleDef(dep)) {\n          const scope = transitiveScopesFor(dep);\n          for (const pipe of scope.exported.pipes) {\n            const def = getPipeDef(pipe);\n            if (def && !seen.has(pipe)) {\n              seen.add(pipe);\n              cachedPipeDefs.push(def);\n            }\n          }\n        } else {\n          const def = getPipeDef(dep);\n          if (def) {\n            cachedPipeDefs.push(def);\n          }\n        }\n      }\n    }\n    return cachedPipeDefs;\n  };\n\n  return {\n    directiveDefs,\n    pipeDefs,\n  };\n}\n\nfunction hasSelectorScope<T>(component: Type<T>): component is Type<T>&\n    {ngSelectorScope: Type<any>} {\n  return (component as {ngSelectorScope?: any}).ngSelectorScope !== undefined;\n}\n\n/**\n * Compile an Angular directive according to its decorator metadata, and patch the resulting\n * directive def onto the component type.\n *\n * In the event that compilation is not immediate, `compileDirective` will return a `Promise` which\n * will resolve when compilation completes and the directive becomes usable.\n */\nexport function compileDirective(type: Type<any>, directive: Directive|null): void {\n  let ngDirectiveDef: any = null;\n\n  addDirectiveFactoryDef(type, directive || {});\n\n  Object.defineProperty(type, NG_DIR_DEF, {\n    get: () => {\n      if (ngDirectiveDef === null) {\n        // `directive` can be null in the case of abstract directives as a base class\n        // that use `@Directive()` with no selector. In that case, pass empty object to the\n        // `directiveMetadata` function instead of null.\n        const meta = getDirectiveMetadata(type, directive || {});\n        const compiler =\n            getCompilerFacade({usage: JitCompilerUsage.Decorator, kind: 'directive', type});\n        ngDirectiveDef =\n            compiler.compileDirective(angularCoreEnv, meta.sourceMapUrl, meta.metadata);\n      }\n      return ngDirectiveDef;\n    },\n    // Make the property configurable in dev mode to allow overriding in tests\n    configurable: !!ngDevMode,\n  });\n}\n\nfunction getDirectiveMetadata(type: Type<any>, metadata: Directive) {\n  const name = type && type.name;\n  const sourceMapUrl = `ng:///${name}/dir.js`;\n  const compiler = getCompilerFacade({usage: JitCompilerUsage.Decorator, kind: 'directive', type});\n  const facade = directiveMetadata(type as ComponentType<any>, metadata);\n  facade.typeSourceSpan = compiler.createParseSourceSpan('Directive', name, sourceMapUrl);\n  if (facade.usesInheritance) {\n    addDirectiveDefToUndecoratedParents(type);\n  }\n  return {metadata: facade, sourceMapUrl};\n}\n\nfunction addDirectiveFactoryDef(type: Type<any>, metadata: Directive|Component) {\n  let ngFactoryDef: any = null;\n\n  Object.defineProperty(type, NG_FACTORY_DEF, {\n    get: () => {\n      if (ngFactoryDef === null) {\n        const meta = getDirectiveMetadata(type, metadata);\n        const compiler =\n            getCompilerFacade({usage: JitCompilerUsage.Decorator, kind: 'directive', type});\n        ngFactoryDef = compiler.compileFactory(angularCoreEnv, `ng:///${type.name}/fac.js`, {\n          name: meta.metadata.name,\n          type: meta.metadata.type,\n          typeArgumentCount: 0,\n          deps: reflectDependencies(type),\n          target: compiler.FactoryTarget.Directive\n        });\n      }\n      return ngFactoryDef;\n    },\n    // Make the property configurable in dev mode to allow overriding in tests\n    configurable: !!ngDevMode,\n  });\n}\n\nexport function extendsDirectlyFromObject(type: Type<any>): boolean {\n  return Object.getPrototypeOf(type.prototype) === Object.prototype;\n}\n\n/**\n * Extract the `R3DirectiveMetadata` for a particular directive (either a `Directive` or a\n * `Component`).\n */\nexport function directiveMetadata(type: Type<any>, metadata: Directive): R3DirectiveMetadataFacade {\n  // Reflect inputs and outputs.\n  const reflect = getReflect();\n  const propMetadata = reflect.ownPropMetadata(type);\n\n  return {\n    name: type.name,\n    type: type,\n    selector: metadata.selector !== undefined ? metadata.selector : null,\n    host: metadata.host || EMPTY_OBJ,\n    propMetadata: propMetadata,\n    inputs: metadata.inputs || EMPTY_ARRAY,\n    outputs: metadata.outputs || EMPTY_ARRAY,\n    queries: extractQueriesMetadata(type, propMetadata, isContentQuery),\n    lifecycle: {usesOnChanges: reflect.hasLifecycleHook(type, 'ngOnChanges')},\n    typeSourceSpan: null!,\n    usesInheritance: !extendsDirectlyFromObject(type),\n    exportAs: extractExportAs(metadata.exportAs),\n    providers: metadata.providers || null,\n    viewQueries: extractQueriesMetadata(type, propMetadata, isViewQuery),\n    isStandalone: !!metadata.standalone,\n    hostDirectives: metadata.hostDirectives?.map(\n                        directive => typeof directive === 'function' ? {directive} : directive) ||\n        null\n  };\n}\n\n/**\n * Adds a directive definition to all parent classes of a type that don't have an Angular decorator.\n */\nfunction addDirectiveDefToUndecoratedParents(type: Type<any>) {\n  const objPrototype = Object.prototype;\n  let parent = Object.getPrototypeOf(type.prototype).constructor;\n\n  // Go up the prototype until we hit `Object`.\n  while (parent && parent !== objPrototype) {\n    // Since inheritance works if the class was annotated already, we only need to add\n    // the def if there are no annotations and the def hasn't been created already.\n    if (!getDirectiveDef(parent) && !getComponentDef(parent) &&\n        shouldAddAbstractDirective(parent)) {\n      compileDirective(parent, null);\n    }\n    parent = Object.getPrototypeOf(parent);\n  }\n}\n\nfunction convertToR3QueryPredicate(selector: any): any|string[] {\n  return typeof selector === 'string' ? splitByComma(selector) : resolveForwardRef(selector);\n}\n\nexport function convertToR3QueryMetadata(propertyName: string, ann: Query): R3QueryMetadataFacade {\n  return {\n    propertyName: propertyName,\n    predicate: convertToR3QueryPredicate(ann.selector),\n    descendants: ann.descendants,\n    first: ann.first,\n    read: ann.read ? ann.read : null,\n    static: !!ann.static,\n    emitDistinctChangesOnly: !!ann.emitDistinctChangesOnly,\n  };\n}\nfunction extractQueriesMetadata(\n    type: Type<any>, propMetadata: {[key: string]: any[]},\n    isQueryAnn: (ann: any) => ann is Query): R3QueryMetadataFacade[] {\n  const queriesMeta: R3QueryMetadataFacade[] = [];\n  for (const field in propMetadata) {\n    if (propMetadata.hasOwnProperty(field)) {\n      const annotations = propMetadata[field];\n      annotations.forEach(ann => {\n        if (isQueryAnn(ann)) {\n          if (!ann.selector) {\n            throw new Error(\n                `Can't construct a query for the property \"${field}\" of ` +\n                `\"${stringifyForError(type)}\" since the query selector wasn't defined.`);\n          }\n          if (annotations.some(isInputAnnotation)) {\n            throw new Error(`Cannot combine @Input decorators with query decorators`);\n          }\n          queriesMeta.push(convertToR3QueryMetadata(field, ann));\n        }\n      });\n    }\n  }\n  return queriesMeta;\n}\n\nfunction extractExportAs(exportAs: string|undefined): string[]|null {\n  return exportAs === undefined ? null : splitByComma(exportAs);\n}\n\nfunction isContentQuery(value: any): value is Query {\n  const name = value.ngMetadataName;\n  return name === 'ContentChild' || name === 'ContentChildren';\n}\n\nfunction isViewQuery(value: any): value is Query {\n  const name = value.ngMetadataName;\n  return name === 'ViewChild' || name === 'ViewChildren';\n}\n\nfunction isInputAnnotation(value: any): value is Input {\n  return value.ngMetadataName === 'Input';\n}\n\nfunction splitByComma(value: string): string[] {\n  return value.split(',').map(piece => piece.trim());\n}\n\nconst LIFECYCLE_HOOKS = [\n  'ngOnChanges', 'ngOnInit', 'ngOnDestroy', 'ngDoCheck', 'ngAfterViewInit', 'ngAfterViewChecked',\n  'ngAfterContentInit', 'ngAfterContentChecked'\n];\n\nfunction shouldAddAbstractDirective(type: Type<any>): boolean {\n  const reflect = getReflect();\n\n  if (LIFECYCLE_HOOKS.some(hookName => reflect.hasLifecycleHook(type, hookName))) {\n    return true;\n  }\n\n  const propMetadata = reflect.propMetadata(type);\n\n  for (const field in propMetadata) {\n    const annotations = propMetadata[field];\n\n    for (let i = 0; i < annotations.length; i++) {\n      const current = annotations[i];\n      const metadataName = current.ngMetadataName;\n\n      if (isInputAnnotation(current) || isContentQuery(current) || isViewQuery(current) ||\n          metadataName === 'Output' || metadataName === 'HostBinding' ||\n          metadataName === 'HostListener') {\n        return true;\n      }\n    }\n  }\n\n  return false;\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {getCompilerFacade, JitCompilerUsage, R3PipeMetadataFacade} from '../../compiler/compiler_facade';\nimport {reflectDependencies} from '../../di/jit/util';\nimport {Type} from '../../interface/type';\nimport {Pipe} from '../../metadata/directives';\nimport {NG_FACTORY_DEF, NG_PIPE_DEF} from '../fields';\n\nimport {angularCoreEnv} from './environment';\n\nexport function compilePipe(type: Type<any>, meta: Pipe): void {\n  let ngPipeDef: any = null;\n  let ngFactoryDef: any = null;\n\n  Object.defineProperty(type, NG_FACTORY_DEF, {\n    get: () => {\n      if (ngFactoryDef === null) {\n        const metadata = getPipeMetadata(type, meta);\n        const compiler = getCompilerFacade(\n            {usage: JitCompilerUsage.Decorator, kind: 'pipe', type: metadata.type});\n        ngFactoryDef = compiler.compileFactory(angularCoreEnv, `ng:///${metadata.name}/fac.js`, {\n          name: metadata.name,\n          type: metadata.type,\n          typeArgumentCount: 0,\n          deps: reflectDependencies(type),\n          target: compiler.FactoryTarget.Pipe\n        });\n      }\n      return ngFactoryDef;\n    },\n    // Make the property configurable in dev mode to allow overriding in tests\n    configurable: !!ngDevMode,\n  });\n\n  Object.defineProperty(type, NG_PIPE_DEF, {\n    get: () => {\n      if (ngPipeDef === null) {\n        const metadata = getPipeMetadata(type, meta);\n        const compiler = getCompilerFacade(\n            {usage: JitCompilerUsage.Decorator, kind: 'pipe', type: metadata.type});\n        ngPipeDef =\n            compiler.compilePipe(angularCoreEnv, `ng:///${metadata.name}/pipe.js`, metadata);\n      }\n      return ngPipeDef;\n    },\n    // Make the property configurable in dev mode to allow overriding in tests\n    configurable: !!ngDevMode,\n  });\n}\n\nfunction getPipeMetadata(type: Type<any>, meta: Pipe): R3PipeMetadataFacade {\n  return {\n    type: type,\n    name: type.name,\n    pipeName: meta.name,\n    pure: meta.pure !== undefined ? meta.pure : true,\n    isStandalone: !!meta.standalone,\n  };\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {ChangeDetectionStrategy} from '../change_detection/constants';\nimport {Provider} from '../di/interface/provider';\nimport {Type} from '../interface/type';\nimport {compileComponent, compileDirective} from '../render3/jit/directive';\nimport {compilePipe} from '../render3/jit/pipe';\nimport {makeDecorator, makePropDecorator, TypeDecorator} from '../util/decorators';\n\nimport {SchemaMetadata} from './schema';\nimport {ViewEncapsulation} from './view';\n\n\n\n/**\n * Type of the Directive decorator / constructor function.\n * @publicApi\n */\nexport interface DirectiveDecorator {\n  /**\n   * Decorator that marks a class as an Angular directive.\n   * You can define your own directives to attach custom behavior to elements in the DOM.\n   *\n   * The options provide configuration metadata that determines\n   * how the directive should be processed, instantiated and used at\n   * runtime.\n   *\n   * Directive classes, like component classes, can implement\n   * [life-cycle hooks](guide/lifecycle-hooks) to influence their configuration and behavior.\n   *\n   *\n   * @usageNotes\n   * To define a directive, mark the class with the decorator and provide metadata.\n   *\n   * ```ts\n   * import {Directive} from '@angular/core';\n   *\n   * @Directive({\n   *   selector: 'my-directive',\n   * })\n   * export class MyDirective {\n   * ...\n   * }\n   * ```\n   *\n   * ### Declaring directives\n   *\n   * In order to make a directive available to other components in your application, you should do\n   * one of the following:\n   *  - either mark the directive as [standalone](guide/standalone-components),\n   *  - or declare it in an NgModule by adding it to the `declarations` and `exports` fields.\n   *\n   * ** Marking a directive as standalone **\n   *\n   * You can add the `standalone: true` flag to the Directive decorator metadata to declare it as\n   * [standalone](guide/standalone-components):\n   *\n   * ```ts\n   * @Directive({\n   *   standalone: true,\n   *   selector: 'my-directive',\n   * })\n   * class MyDirective {}\n   * ```\n   *\n   * When marking a directive as standalone, please make sure that the directive is not already\n   * declared in an NgModule.\n   *\n   *\n   * ** Declaring a directive in an NgModule **\n   *\n   * Another approach is to declare a directive in an NgModule:\n   *\n   * ```ts\n   * @Directive({\n   *   selector: 'my-directive',\n   * })\n   * class MyDirective {}\n   *\n   * @NgModule({\n   *   declarations: [MyDirective, SomeComponent],\n   *   exports: [MyDirective], // making it available outside of this module\n   * })\n   * class SomeNgModule {}\n   * ```\n   *\n   * When declaring a directive in an NgModule, please make sure that:\n   *  - the directive is declared in exactly one NgModule.\n   *  - the directive is not standalone.\n   *  - you do not re-declare a directive imported from another module.\n   *  - the directive is included into the `exports` field as well if you want this directive to be\n   *    accessible for components outside of the NgModule.\n   *\n   *\n   * @Annotation\n   */\n  (obj?: Directive): TypeDecorator;\n\n  /**\n   * See the `Directive` decorator.\n   */\n  new(obj?: Directive): Directive;\n}\n\n/**\n * Directive decorator and metadata.\n *\n * @Annotation\n * @publicApi\n */\nexport interface Directive {\n  /**\n   * The CSS selector that identifies this directive in a template\n   * and triggers instantiation of the directive.\n   *\n   * Declare as one of the following:\n   *\n   * - `element-name`: Select by element name.\n   * - `.class`: Select by class name.\n   * - `[attribute]`: Select by attribute name.\n   * - `[attribute=value]`: Select by attribute name and value.\n   * - `:not(sub_selector)`: Select only if the element does not match the `sub_selector`.\n   * - `selector1, selector2`: Select if either `selector1` or `selector2` matches.\n   *\n   * Angular only allows directives to apply on CSS selectors that do not cross\n   * element boundaries.\n   *\n   * For the following template HTML, a directive with an `input[type=text]` selector,\n   * would be instantiated only on the `<input type=\"text\">` element.\n   *\n   * ```html\n   * <form>\n   *   <input type=\"text\">\n   *   <input type=\"radio\">\n   * <form>\n   * ```\n   *\n   */\n  selector?: string;\n\n  /**\n   * Enumerates the set of data-bound input properties for a directive\n   *\n   * Angular automatically updates input properties during change detection.\n   * The `inputs` property defines a set of `directiveProperty` to `bindingProperty`\n   * configuration:\n   *\n   * - `directiveProperty` specifies the component property where the value is written.\n   * - `bindingProperty` specifies the DOM property where the value is read from.\n   *\n   * When `bindingProperty` is not provided, it is assumed to be equal to `directiveProperty`.\n   *\n   * @usageNotes\n   *\n   * The following example creates a component with two data-bound properties.\n   *\n   * ```typescript\n   * @Component({\n   *   selector: 'bank-account',\n   *   inputs: ['bankName', 'id: account-id'],\n   *   template: `\n   *     Bank Name: {{bankName}}\n   *     Account Id: {{id}}\n   *   `\n   * })\n   * class BankAccount {\n   *   bankName: string;\n   *   id: string;\n   * }\n   * ```\n   *\n   */\n  inputs?: string[];\n\n  /**\n   * Enumerates the set of event-bound output properties.\n   *\n   * When an output property emits an event, an event handler attached to that event\n   * in the template is invoked.\n   *\n   * The `outputs` property defines a set of `directiveProperty` to `bindingProperty`\n   * configuration:\n   *\n   * - `directiveProperty` specifies the component property that emits events.\n   * - `bindingProperty` specifies the DOM property the event handler is attached to.\n   *\n   * @usageNotes\n   *\n   * ```typescript\n   * @Component({\n   *   selector: 'child-dir',\n   *   outputs: [ 'bankNameChange' ]\n   *   template: `<input (input)=\"bankNameChange.emit($event.target.value)\" />`\n   * })\n   * class ChildDir {\n   *  bankNameChange: EventEmitter<string> = new EventEmitter<string>();\n   * }\n   *\n   * @Component({\n   *   selector: 'main',\n   *   template: `\n   *     {{ bankName }} <child-dir (bankNameChange)=\"onBankNameChange($event)\"></child-dir>\n   *   `\n   * })\n   * class MainComponent {\n   *  bankName: string;\n   *\n   *   onBankNameChange(bankName: string) {\n   *     this.bankName = bankName;\n   *   }\n   * }\n   * ```\n   *\n   */\n  outputs?: string[];\n\n  /**\n   * Configures the [injector](guide/glossary#injector) of this\n   * directive or component with a [token](guide/glossary#di-token)\n   * that maps to a [provider](guide/glossary#provider) of a dependency.\n   */\n  providers?: Provider[];\n\n  /**\n   * Defines the name that can be used in the template to assign this directive to a variable.\n   *\n   * @usageNotes\n   *\n   * ```ts\n   * @Directive({\n   *   selector: 'child-dir',\n   *   exportAs: 'child'\n   * })\n   * class ChildDir {\n   * }\n   *\n   * @Component({\n   *   selector: 'main',\n   *   template: `<child-dir #c=\"child\"></child-dir>`\n   * })\n   * class MainComponent {\n   * }\n   * ```\n   *\n   */\n  exportAs?: string;\n\n  /**\n   * Configures the queries that will be injected into the directive.\n   *\n   * Content queries are set before the `ngAfterContentInit` callback is called.\n   * View queries are set before the `ngAfterViewInit` callback is called.\n   *\n   * @usageNotes\n   *\n   * The following example shows how queries are defined\n   * and when their results are available in lifecycle hooks:\n   *\n   * ```ts\n   * @Component({\n   *   selector: 'someDir',\n   *   queries: {\n   *     contentChildren: new ContentChildren(ChildDirective),\n   *     viewChildren: new ViewChildren(ChildDirective)\n   *   },\n   *   template: '<child-directive></child-directive>'\n   * })\n   * class SomeDir {\n   *   contentChildren: QueryList<ChildDirective>,\n   *   viewChildren: QueryList<ChildDirective>\n   *\n   *   ngAfterContentInit() {\n   *     // contentChildren is set\n   *   }\n   *\n   *   ngAfterViewInit() {\n   *     // viewChildren is set\n   *   }\n   * }\n   * ```\n   *\n   * @Annotation\n   */\n  queries?: {[key: string]: any};\n\n  /**\n   * Maps class properties to host element bindings for properties,\n   * attributes, and events, using a set of key-value pairs.\n   *\n   * Angular automatically checks host property bindings during change detection.\n   * If a binding changes, Angular updates the directive's host element.\n   *\n   * When the key is a property of the host element, the property value is\n   * the propagated to the specified DOM property.\n   *\n   * When the key is a static attribute in the DOM, the attribute value\n   * is propagated to the specified property in the host element.\n   *\n   * For event handling:\n   * - The key is the DOM event that the directive listens to.\n   * To listen to global events, add the target to the event name.\n   * The target can be `window`, `document` or `body`.\n   * - The value is the statement to execute when the event occurs. If the\n   * statement evaluates to `false`, then `preventDefault` is applied on the DOM\n   * event. A handler method can refer to the `$event` local variable.\n   *\n   */\n  host?: {[key: string]: string};\n\n  /**\n   * When present, this directive/component is ignored by the AOT compiler.\n   * It remains in distributed code, and the JIT compiler attempts to compile it\n   * at run time, in the browser.\n   * To ensure the correct behavior, the app must import `@angular/compiler`.\n   */\n  jit?: true;\n\n  /**\n   * Angular directives marked as `standalone` do not need to be declared in an NgModule. Such\n   * directives don't depend on any \"intermediate context\" of an NgModule (ex. configured\n   * providers).\n   *\n   * More information about standalone components, directives, and pipes can be found in [this\n   * guide](guide/standalone-components).\n   */\n  standalone?: boolean;\n\n  /**\n   * Standalone directives that should be applied to the host whenever the directive is matched.\n   * By default, none of the inputs or outputs of the host directives will be available on the host,\n   * unless they are specified in the `inputs` or `outputs` properties.\n   *\n   * You can additionally alias inputs and outputs by putting a colon and the alias after the\n   * original input or output name. For example, if a directive applied via `hostDirectives`\n   * defines an input named `menuDisabled`, you can alias this to `disabled` by adding\n   * `'menuDisabled: disabled'` as an entry to `inputs`.\n   */\n  hostDirectives?: (Type<unknown>|{\n    directive: Type<unknown>,\n    inputs?: string[],\n    outputs?: string[],\n  })[];\n}\n\n/**\n * Type of the Directive metadata.\n *\n * @publicApi\n */\nexport const Directive: DirectiveDecorator = makeDecorator(\n    'Directive', (dir: Directive = {}) => dir, undefined, undefined,\n    (type: Type<any>, meta: Directive) => compileDirective(type, meta));\n\n/**\n * Component decorator interface\n *\n * @publicApi\n */\nexport interface ComponentDecorator {\n  /**\n   * Decorator that marks a class as an Angular component and provides configuration\n   * metadata that determines how the component should be processed,\n   * instantiated, and used at runtime.\n   *\n   * Components are the most basic UI building block of an Angular app.\n   * An Angular app contains a tree of Angular components.\n   *\n   * Angular components are a subset of directives, always associated with a template.\n   * Unlike other directives, only one component can be instantiated for a given element in a\n   * template.\n   *\n   * A component must belong to an NgModule in order for it to be available\n   * to another component or application. To make it a member of an NgModule,\n   * list it in the `declarations` field of the `NgModule` metadata.\n   *\n   * Note that, in addition to these options for configuring a directive,\n   * you can control a component's runtime behavior by implementing\n   * life-cycle hooks. For more information, see the\n   * [Lifecycle Hooks](guide/lifecycle-hooks) guide.\n   *\n   * @usageNotes\n   *\n   * ### Setting component inputs\n   *\n   * The following example creates a component with two data-bound properties,\n   * specified by the `inputs` value.\n   *\n   * <code-example path=\"core/ts/metadata/directives.ts\" region=\"component-input\"></code-example>\n   *\n   *\n   * ### Setting component outputs\n   *\n   * The following example shows two event emitters that emit on an interval. One\n   * emits an output every second, while the other emits every five seconds.\n   *\n   * {@example core/ts/metadata/directives.ts region='component-output-interval'}\n   *\n   * ### Injecting a class with a view provider\n   *\n   * The following simple example injects a class into a component\n   * using the view provider specified in component metadata:\n   *\n   * ```ts\n   * class Greeter {\n   *    greet(name:string) {\n   *      return 'Hello ' + name + '!';\n   *    }\n   * }\n   *\n   * @Directive({\n   *   selector: 'needs-greeter'\n   * })\n   * class NeedsGreeter {\n   *   greeter:Greeter;\n   *\n   *   constructor(greeter:Greeter) {\n   *     this.greeter = greeter;\n   *   }\n   * }\n   *\n   * @Component({\n   *   selector: 'greet',\n   *   viewProviders: [\n   *     Greeter\n   *   ],\n   *   template: `<needs-greeter></needs-greeter>`\n   * })\n   * class HelloWorld {\n   * }\n   *\n   * ```\n   *\n   * ### Preserving whitespace\n   *\n   * Removing whitespace can greatly reduce AOT-generated code size and speed up view creation.\n   * As of Angular 6, the default for `preserveWhitespaces` is false (whitespace is removed).\n   * To change the default setting for all components in your application, set\n   * the `preserveWhitespaces` option of the AOT compiler.\n   *\n   * By default, the AOT compiler removes whitespace characters as follows:\n   * * Trims all whitespaces at the beginning and the end of a template.\n   * * Removes whitespace-only text nodes. For example,\n   *\n   * ```html\n   * <button>Action 1</button>  <button>Action 2</button>\n   * ```\n   *\n   * becomes:\n   *\n   * ```html\n   * <button>Action 1</button><button>Action 2</button>\n   * ```\n   *\n   * * Replaces a series of whitespace characters in text nodes with a single space.\n   * For example, `<span>\\n some text\\n</span>` becomes `<span> some text </span>`.\n   * * Does NOT alter text nodes inside HTML tags such as `<pre>` or `<textarea>`,\n   * where whitespace characters are significant.\n   *\n   * Note that these transformations can influence DOM nodes layout, although impact\n   * should be minimal.\n   *\n   * You can override the default behavior to preserve whitespace characters\n   * in certain fragments of a template. For example, you can exclude an entire\n   * DOM sub-tree by using the `ngPreserveWhitespaces` attribute:\n   *\n   * ```html\n   * <div ngPreserveWhitespaces>\n   *     whitespaces are preserved here\n   *     <span>    and here </span>\n   * </div>\n   * ```\n   *\n   * You can force a single space to be preserved in a text node by using `&ngsp;`,\n   * which is replaced with a space character by Angular's template\n   * compiler:\n   *\n   * ```html\n   * <a>Spaces</a>&ngsp;<a>between</a>&ngsp;<a>links.</a>\n   * <!-- compiled to be equivalent to:\n   *  <a>Spaces</a> <a>between</a> <a>links.</a>  -->\n   * ```\n   *\n   * Note that sequences of `&ngsp;` are still collapsed to just one space character when\n   * the `preserveWhitespaces` option is set to `false`.\n   *\n   * ```html\n   * <a>before</a>&ngsp;&ngsp;&ngsp;<a>after</a>\n   * <!-- compiled to be equivalent to:\n   *  <a>before</a> <a>after</a> -->\n   * ```\n   *\n   * To preserve sequences of whitespace characters, use the\n   * `ngPreserveWhitespaces` attribute.\n   *\n   * @Annotation\n   */\n  (obj: Component): TypeDecorator;\n  /**\n   * See the `Component` decorator.\n   */\n  new(obj: Component): Component;\n}\n\n/**\n * Supplies configuration metadata for an Angular component.\n *\n * @publicApi\n */\nexport interface Component extends Directive {\n  /**\n   * The change-detection strategy to use for this component.\n   *\n   * When a component is instantiated, Angular creates a change detector,\n   * which is responsible for propagating the component's bindings.\n   * The strategy is one of:\n   * - `ChangeDetectionStrategy#OnPush` sets the strategy to `CheckOnce` (on demand).\n   * - `ChangeDetectionStrategy#Default` sets the strategy to `CheckAlways`.\n   */\n  changeDetection?: ChangeDetectionStrategy;\n\n  /**\n   * Defines the set of injectable objects that are visible to its view DOM children.\n   * See [example](#injecting-a-class-with-a-view-provider).\n   *\n   */\n  viewProviders?: Provider[];\n\n  /**\n   * The module ID of the module that contains the component.\n   * The component must be able to resolve relative URLs for templates and styles.\n   * SystemJS exposes the `__moduleName` variable within each module.\n   * In CommonJS, this can  be set to `module.id`.\n   *\n   */\n  moduleId?: string;\n\n  /**\n   * The relative path or absolute URL of a template file for an Angular component.\n   * If provided, do not supply an inline template using `template`.\n   *\n   */\n  templateUrl?: string;\n\n  /**\n   * An inline template for an Angular component. If provided,\n   * do not supply a template file using `templateUrl`.\n   *\n   */\n  template?: string;\n\n  /**\n   * One or more relative paths or absolute URLs for files containing CSS stylesheets to use\n   * in this component.\n   */\n  styleUrls?: string[];\n\n  /**\n   * One or more inline CSS stylesheets to use\n   * in this component.\n   */\n  styles?: string[];\n\n  /**\n   * One or more animation `trigger()` calls, containing\n   * [`state()`](api/animations/state) and `transition()` definitions.\n   * See the [Animations guide](/guide/animations) and animations API documentation.\n   *\n   */\n  animations?: any[];\n\n  /**\n   * An encapsulation policy for the component's styling.\n   * Possible values:\n   * - `ViewEncapsulation.Emulated`: Apply modified component styles in order to emulate\n   *                                 a native Shadow DOM CSS encapsulation behavior.\n   * - `ViewEncapsulation.None`: Apply component styles globally without any sort of encapsulation.\n   * - `ViewEncapsulation.ShadowDom`: Use the browser's native Shadow DOM API to encapsulate styles.\n   *\n   * If not supplied, the value is taken from the `CompilerOptions`\n   * which defaults to `ViewEncapsulation.Emulated`.\n   *\n   * If the policy is `ViewEncapsulation.Emulated` and the component has no\n   * {@link Component#styles styles} nor {@link Component#styleUrls styleUrls},\n   * the policy is automatically switched to `ViewEncapsulation.None`.\n   */\n  encapsulation?: ViewEncapsulation;\n\n  /**\n   * Overrides the default interpolation start and end delimiters (`{{` and `}}`).\n   */\n  interpolation?: [string, string];\n\n  /**\n   * A set of components that should be compiled along with\n   * this component. For each component listed here,\n   * Angular creates a {@link ComponentFactory} and stores it in the\n   * {@link ComponentFactoryResolver}.\n   * @deprecated Since 9.0.0. With Ivy, this property is no longer necessary.\n   */\n  entryComponents?: Array<Type<any>|any[]>;\n\n  /**\n   * True to preserve or false to remove potentially superfluous whitespace characters\n   * from the compiled template. Whitespace characters are those matching the `\\s`\n   * character class in JavaScript regular expressions. Default is false, unless\n   * overridden in compiler options.\n   */\n  preserveWhitespaces?: boolean;\n\n  /**\n   * Angular components marked as `standalone` do not need to be declared in an NgModule. Such\n   * components directly manage their own template dependencies (components, directives, and pipes\n   * used in a template) via the imports property.\n   *\n   * More information about standalone components, directives, and pipes can be found in [this\n   * guide](guide/standalone-components).\n   */\n  standalone?: boolean;\n\n  /**\n   * The imports property specifies the standalone component's template dependencies  those\n   * directives, components, and pipes that can be used within its template. Standalone components\n   * can import other standalone components, directives, and pipes as well as existing NgModules.\n   *\n   * This property is only available for standalone components - specifying it for components\n   * declared in an NgModule generates a compilation error.\n   *\n   * More information about standalone components, directives, and pipes can be found in [this\n   * guide](guide/standalone-components).\n   */\n  imports?: (Type<any>|ReadonlyArray<any>)[];\n\n  /**\n   * The set of schemas that declare elements to be allowed in a standalone component. Elements and\n   * properties that are neither Angular components nor directives must be declared in a schema.\n   *\n   * This property is only available for standalone components - specifying it for components\n   * declared in an NgModule generates a compilation error.\n   *\n   * More information about standalone components, directives, and pipes can be found in [this\n   * guide](guide/standalone-components).\n   */\n  schemas?: SchemaMetadata[];\n}\n\n/**\n * Component decorator and metadata.\n *\n * @Annotation\n * @publicApi\n */\nexport const Component: ComponentDecorator = makeDecorator(\n    'Component', (c: Component = {}) => ({changeDetection: ChangeDetectionStrategy.Default, ...c}),\n    Directive, undefined, (type: Type<any>, meta: Component) => compileComponent(type, meta));\n\n/**\n * Type of the Pipe decorator / constructor function.\n *\n * @publicApi\n */\nexport interface PipeDecorator {\n  /**\n   *\n   * Decorator that marks a class as pipe and supplies configuration metadata.\n   *\n   * A pipe class must implement the `PipeTransform` interface.\n   * For example, if the name is \"myPipe\", use a template binding expression\n   * such as the following:\n   *\n   * ```\n   * {{ exp | myPipe }}\n   * ```\n   *\n   * The result of the expression is passed to the pipe's `transform()` method.\n   *\n   * A pipe must belong to an NgModule in order for it to be available\n   * to a template. To make it a member of an NgModule,\n   * list it in the `declarations` field of the `NgModule` metadata.\n   *\n   * @see [Style Guide: Pipe Names](guide/styleguide#02-09)\n   *\n   */\n  (obj: Pipe): TypeDecorator;\n\n  /**\n   * See the `Pipe` decorator.\n   */\n  new(obj: Pipe): Pipe;\n}\n\n/**\n * Type of the Pipe metadata.\n *\n * @publicApi\n */\nexport interface Pipe {\n  /**\n   * The pipe name to use in template bindings.\n   * Typically uses [lowerCamelCase](guide/glossary#case-types)\n   * because the name cannot contain hyphens.\n   */\n  name: string;\n\n  /**\n   * When true, the pipe is pure, meaning that the\n   * `transform()` method is invoked only when its input arguments\n   * change. Pipes are pure by default.\n   *\n   * If the pipe has internal state (that is, the result\n   * depends on state other than its arguments), set `pure` to false.\n   * In this case, the pipe is invoked on each change-detection cycle,\n   * even if the arguments have not changed.\n   */\n  pure?: boolean;\n\n  /**\n   * Angular pipes marked as `standalone` do not need to be declared in an NgModule. Such\n   * pipes don't depend on any \"intermediate context\" of an NgModule (ex. configured providers).\n   *\n   * More information about standalone components, directives, and pipes can be found in [this\n   * guide](guide/standalone-components).\n   */\n  standalone?: boolean;\n}\n\n/**\n * @Annotation\n * @publicApi\n */\nexport const Pipe: PipeDecorator = makeDecorator(\n    'Pipe', (p: Pipe) => ({pure: true, ...p}), undefined, undefined,\n    (type: Type<any>, meta: Pipe) => compilePipe(type, meta));\n\n\n/**\n * @publicApi\n */\nexport interface InputDecorator {\n  /**\n   * Decorator that marks a class field as an input property and supplies configuration metadata.\n   * The input property is bound to a DOM property in the template. During change detection,\n   * Angular automatically updates the data property with the DOM property's value.\n   *\n   * @usageNotes\n   *\n   * You can supply an optional name to use in templates when the\n   * component is instantiated, that maps to the\n   * name of the bound property. By default, the original\n   * name of the bound property is used for input binding.\n   *\n   * The following example creates a component with two input properties,\n   * one of which is given a special binding name.\n   *\n   * ```typescript\n   * @Component({\n   *   selector: 'bank-account',\n   *   template: `\n   *     Bank Name: {{bankName}}\n   *     Account Id: {{id}}\n   *   `\n   * })\n   * class BankAccount {\n   *   // This property is bound using its original name.\n   *   @Input() bankName: string;\n   *   // this property value is bound to a different property name\n   *   // when this component is instantiated in a template.\n   *   @Input('account-id') id: string;\n   *\n   *   // this property is not bound, and is not automatically updated by Angular\n   *   normalizedBankName: string;\n   * }\n   *\n   * @Component({\n   *   selector: 'app',\n   *   template: `\n   *     <bank-account bankName=\"RBC\" account-id=\"4747\"></bank-account>\n   *   `\n   * })\n   * class App {}\n   * ```\n   *\n   * @see [Input and Output properties](guide/inputs-outputs)\n   */\n  (bindingPropertyName?: string): any;\n  new(bindingPropertyName?: string): any;\n}\n\n/**\n * Type of metadata for an `Input` property.\n *\n * @publicApi\n */\nexport interface Input {\n  /**\n   * The name of the DOM property to which the input property is bound.\n   */\n  bindingPropertyName?: string;\n}\n\n/**\n * @Annotation\n * @publicApi\n */\nexport const Input: InputDecorator =\n    makePropDecorator('Input', (bindingPropertyName?: string) => ({bindingPropertyName}));\n\n/**\n * Type of the Output decorator / constructor function.\n *\n * @publicApi\n */\nexport interface OutputDecorator {\n  /**\n   * Decorator that marks a class field as an output property and supplies configuration metadata.\n   * The DOM property bound to the output property is automatically updated during change detection.\n   *\n   * @usageNotes\n   *\n   * You can supply an optional name to use in templates when the\n   * component is instantiated, that maps to the\n   * name of the bound property. By default, the original\n   * name of the bound property is used for output binding.\n   *\n   * See `Input` decorator for an example of providing a binding name.\n   *\n   * @see [Input and Output properties](guide/inputs-outputs)\n   *\n   */\n  (bindingPropertyName?: string): any;\n  new(bindingPropertyName?: string): any;\n}\n\n/**\n * Type of the Output metadata.\n *\n * @publicApi\n */\nexport interface Output {\n  /**\n   * The name of the DOM property to which the output property is bound.\n   */\n  bindingPropertyName?: string;\n}\n\n/**\n * @Annotation\n * @publicApi\n */\nexport const Output: OutputDecorator =\n    makePropDecorator('Output', (bindingPropertyName?: string) => ({bindingPropertyName}));\n\n\n\n/**\n * Type of the HostBinding decorator / constructor function.\n *\n * @publicApi\n */\nexport interface HostBindingDecorator {\n  /**\n   * Decorator that marks a DOM property as a host-binding property and supplies configuration\n   * metadata.\n   * Angular automatically checks host property bindings during change detection, and\n   * if a binding changes it updates the host element of the directive.\n   *\n   * @usageNotes\n   *\n   * The following example creates a directive that sets the `valid` and `invalid`\n   * properties on the DOM element that has an `ngModel` directive on it.\n   *\n   * ```typescript\n   * @Directive({selector: '[ngModel]'})\n   * class NgModelStatus {\n   *   constructor(public control: NgModel) {}\n   *   @HostBinding('class.valid') get valid() { return this.control.valid; }\n   *   @HostBinding('class.invalid') get invalid() { return this.control.invalid; }\n   * }\n   *\n   * @Component({\n   *   selector: 'app',\n   *   template: `<input [(ngModel)]=\"prop\">`,\n   * })\n   * class App {\n   *   prop;\n   * }\n   * ```\n   *\n   */\n  (hostPropertyName?: string): any;\n  new(hostPropertyName?: string): any;\n}\n\n/**\n * Type of the HostBinding metadata.\n *\n * @publicApi\n */\nexport interface HostBinding {\n  /**\n   * The DOM property that is bound to a data property.\n   */\n  hostPropertyName?: string;\n}\n\n/**\n * @Annotation\n * @publicApi\n */\nexport const HostBinding: HostBindingDecorator =\n    makePropDecorator('HostBinding', (hostPropertyName?: string) => ({hostPropertyName}));\n\n\n/**\n * Type of the HostListener decorator / constructor function.\n *\n * @publicApi\n */\nexport interface HostListenerDecorator {\n  /**\n   * Decorator that declares a DOM event to listen for,\n   * and provides a handler method to run when that event occurs.\n   *\n   * Angular invokes the supplied handler method when the host element emits the specified event,\n   * and updates the bound element with the result.\n   *\n   * If the handler method returns false, applies `preventDefault` on the bound element.\n   */\n  (eventName: string, args?: string[]): any;\n  new(eventName: string, args?: string[]): any;\n}\n\n/**\n * Type of the HostListener metadata.\n *\n * @publicApi\n */\nexport interface HostListener {\n  /**\n   * The DOM event to listen for.\n   */\n  eventName?: string;\n  /**\n   * A set of arguments to pass to the handler method when the event occurs.\n   */\n  args?: string[];\n}\n\n/**\n * Decorator that binds a DOM event to a host listener and supplies configuration metadata.\n * Angular invokes the supplied handler method when the host element emits the specified event,\n * and updates the bound element with the result.\n *\n * If the handler method returns false, applies `preventDefault` on the bound element.\n *\n * @usageNotes\n *\n * The following example declares a directive\n * that attaches a click listener to a button and counts clicks.\n *\n * ```ts\n * @Directive({selector: 'button[counting]'})\n * class CountClicks {\n *   numberOfClicks = 0;\n *\n *   @HostListener('click', ['$event.target'])\n *   onClick(btn) {\n *     console.log('button', btn, 'number of clicks:', this.numberOfClicks++);\n *   }\n * }\n *\n * @Component({\n *   selector: 'app',\n *   template: '<button counting>Increment</button>',\n * })\n * class App {}\n *\n * ```\n *\n * The following example registers another DOM event handler that listens for `Enter` key-press\n * events on the global `window`.\n * ``` ts\n * import { HostListener, Component } from \"@angular/core\";\n *\n * @Component({\n *   selector: 'app',\n *   template: `<h1>Hello, you have pressed enter {{counter}} number of times!</h1> Press enter key\n * to increment the counter.\n *   <button (click)=\"resetCounter()\">Reset Counter</button>`\n * })\n * class AppComponent {\n *   counter = 0;\n *   @HostListener('window:keydown.enter', ['$event'])\n *   handleKeyDown(event: KeyboardEvent) {\n *     this.counter++;\n *   }\n *   resetCounter() {\n *     this.counter = 0;\n *   }\n * }\n * ```\n * The list of valid key names for `keydown` and `keyup` events\n * can be found here:\n * https://www.w3.org/TR/DOM-Level-3-Events-key/#named-key-attribute-values\n *\n * Note that keys can also be combined, e.g. `@HostListener('keydown.shift.a')`.\n *\n * The global target names that can be used to prefix an event name are\n * `document:`, `window:` and `body:`.\n *\n * @Annotation\n * @publicApi\n */\nexport const HostListener: HostListenerDecorator =\n    makePropDecorator('HostListener', (eventName?: string, args?: string[]) => ({eventName, args}));\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {keyValueArraySet} from '../../util/array_utils';\nimport {getLView} from '../state';\nimport {interpolation1, interpolation2, interpolation3, interpolation4, interpolation5, interpolation6, interpolation7, interpolation8, interpolationV} from './interpolation';\nimport {checkStylingMap, classStringParser} from './styling';\n\n\n\n/**\n *\n * Update an interpolated class on an element with single bound value surrounded by text.\n *\n * Used when the value passed to a property has 1 interpolated value in it:\n *\n * ```html\n * <div class=\"prefix{{v0}}suffix\"></div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * classMapInterpolate1('prefix', v0, 'suffix');\n * ```\n *\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @codeGenApi\n */\nexport function classMapInterpolate1(prefix: string, v0: any, suffix: string): void {\n  const lView = getLView();\n  const interpolatedValue = interpolation1(lView, prefix, v0, suffix);\n  checkStylingMap(keyValueArraySet, classStringParser, interpolatedValue, true);\n}\n\n/**\n *\n * Update an interpolated class on an element with 2 bound values surrounded by text.\n *\n * Used when the value passed to a property has 2 interpolated values in it:\n *\n * ```html\n * <div class=\"prefix{{v0}}-{{v1}}suffix\"></div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * classMapInterpolate2('prefix', v0, '-', v1, 'suffix');\n * ```\n *\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @codeGenApi\n */\nexport function classMapInterpolate2(\n    prefix: string, v0: any, i0: string, v1: any, suffix: string): void {\n  const lView = getLView();\n  const interpolatedValue = interpolation2(lView, prefix, v0, i0, v1, suffix);\n  checkStylingMap(keyValueArraySet, classStringParser, interpolatedValue, true);\n}\n\n/**\n *\n * Update an interpolated class on an element with 3 bound values surrounded by text.\n *\n * Used when the value passed to a property has 3 interpolated values in it:\n *\n * ```html\n * <div class=\"prefix{{v0}}-{{v1}}-{{v2}}suffix\"></div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * classMapInterpolate3(\n * 'prefix', v0, '-', v1, '-', v2, 'suffix');\n * ```\n *\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param i1 Static value used for concatenation only.\n * @param v2 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @codeGenApi\n */\nexport function classMapInterpolate3(\n    prefix: string, v0: any, i0: string, v1: any, i1: string, v2: any, suffix: string): void {\n  const lView = getLView();\n  const interpolatedValue = interpolation3(lView, prefix, v0, i0, v1, i1, v2, suffix);\n  checkStylingMap(keyValueArraySet, classStringParser, interpolatedValue, true);\n}\n\n/**\n *\n * Update an interpolated class on an element with 4 bound values surrounded by text.\n *\n * Used when the value passed to a property has 4 interpolated values in it:\n *\n * ```html\n * <div class=\"prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}suffix\"></div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * classMapInterpolate4(\n * 'prefix', v0, '-', v1, '-', v2, '-', v3, 'suffix');\n * ```\n *\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param i1 Static value used for concatenation only.\n * @param v2 Value checked for change.\n * @param i2 Static value used for concatenation only.\n * @param v3 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @codeGenApi\n */\nexport function classMapInterpolate4(\n    prefix: string, v0: any, i0: string, v1: any, i1: string, v2: any, i2: string, v3: any,\n    suffix: string): void {\n  const lView = getLView();\n  const interpolatedValue = interpolation4(lView, prefix, v0, i0, v1, i1, v2, i2, v3, suffix);\n  checkStylingMap(keyValueArraySet, classStringParser, interpolatedValue, true);\n}\n\n/**\n *\n * Update an interpolated class on an element with 5 bound values surrounded by text.\n *\n * Used when the value passed to a property has 5 interpolated values in it:\n *\n * ```html\n * <div class=\"prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}-{{v4}}suffix\"></div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * classMapInterpolate5(\n * 'prefix', v0, '-', v1, '-', v2, '-', v3, '-', v4, 'suffix');\n * ```\n *\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param i1 Static value used for concatenation only.\n * @param v2 Value checked for change.\n * @param i2 Static value used for concatenation only.\n * @param v3 Value checked for change.\n * @param i3 Static value used for concatenation only.\n * @param v4 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @codeGenApi\n */\nexport function classMapInterpolate5(\n    prefix: string, v0: any, i0: string, v1: any, i1: string, v2: any, i2: string, v3: any,\n    i3: string, v4: any, suffix: string): void {\n  const lView = getLView();\n  const interpolatedValue =\n      interpolation5(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, suffix);\n  checkStylingMap(keyValueArraySet, classStringParser, interpolatedValue, true);\n}\n\n/**\n *\n * Update an interpolated class on an element with 6 bound values surrounded by text.\n *\n * Used when the value passed to a property has 6 interpolated values in it:\n *\n * ```html\n * <div class=\"prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}-{{v4}}-{{v5}}suffix\"></div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * classMapInterpolate6(\n *    'prefix', v0, '-', v1, '-', v2, '-', v3, '-', v4, '-', v5, 'suffix');\n * ```\n *\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param i1 Static value used for concatenation only.\n * @param v2 Value checked for change.\n * @param i2 Static value used for concatenation only.\n * @param v3 Value checked for change.\n * @param i3 Static value used for concatenation only.\n * @param v4 Value checked for change.\n * @param i4 Static value used for concatenation only.\n * @param v5 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @codeGenApi\n */\nexport function classMapInterpolate6(\n    prefix: string, v0: any, i0: string, v1: any, i1: string, v2: any, i2: string, v3: any,\n    i3: string, v4: any, i4: string, v5: any, suffix: string): void {\n  const lView = getLView();\n  const interpolatedValue =\n      interpolation6(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, suffix);\n  checkStylingMap(keyValueArraySet, classStringParser, interpolatedValue, true);\n}\n\n/**\n *\n * Update an interpolated class on an element with 7 bound values surrounded by text.\n *\n * Used when the value passed to a property has 7 interpolated values in it:\n *\n * ```html\n * <div class=\"prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}-{{v4}}-{{v5}}-{{v6}}suffix\"></div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * classMapInterpolate7(\n *    'prefix', v0, '-', v1, '-', v2, '-', v3, '-', v4, '-', v5, '-', v6, 'suffix');\n * ```\n *\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param i1 Static value used for concatenation only.\n * @param v2 Value checked for change.\n * @param i2 Static value used for concatenation only.\n * @param v3 Value checked for change.\n * @param i3 Static value used for concatenation only.\n * @param v4 Value checked for change.\n * @param i4 Static value used for concatenation only.\n * @param v5 Value checked for change.\n * @param i5 Static value used for concatenation only.\n * @param v6 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @codeGenApi\n */\nexport function classMapInterpolate7(\n    prefix: string, v0: any, i0: string, v1: any, i1: string, v2: any, i2: string, v3: any,\n    i3: string, v4: any, i4: string, v5: any, i5: string, v6: any, suffix: string): void {\n  const lView = getLView();\n  const interpolatedValue =\n      interpolation7(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, suffix);\n  checkStylingMap(keyValueArraySet, classStringParser, interpolatedValue, true);\n}\n\n/**\n *\n * Update an interpolated class on an element with 8 bound values surrounded by text.\n *\n * Used when the value passed to a property has 8 interpolated values in it:\n *\n * ```html\n * <div class=\"prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}-{{v4}}-{{v5}}-{{v6}}-{{v7}}suffix\"></div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * classMapInterpolate8(\n *  'prefix', v0, '-', v1, '-', v2, '-', v3, '-', v4, '-', v5, '-', v6, '-', v7, 'suffix');\n * ```\n *\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param i1 Static value used for concatenation only.\n * @param v2 Value checked for change.\n * @param i2 Static value used for concatenation only.\n * @param v3 Value checked for change.\n * @param i3 Static value used for concatenation only.\n * @param v4 Value checked for change.\n * @param i4 Static value used for concatenation only.\n * @param v5 Value checked for change.\n * @param i5 Static value used for concatenation only.\n * @param v6 Value checked for change.\n * @param i6 Static value used for concatenation only.\n * @param v7 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @codeGenApi\n */\nexport function classMapInterpolate8(\n    prefix: string, v0: any, i0: string, v1: any, i1: string, v2: any, i2: string, v3: any,\n    i3: string, v4: any, i4: string, v5: any, i5: string, v6: any, i6: string, v7: any,\n    suffix: string): void {\n  const lView = getLView();\n  const interpolatedValue = interpolation8(\n      lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, i6, v7, suffix);\n  checkStylingMap(keyValueArraySet, classStringParser, interpolatedValue, true);\n}\n\n/**\n * Update an interpolated class on an element with 9 or more bound values surrounded by text.\n *\n * Used when the number of interpolated values exceeds 8.\n *\n * ```html\n * <div\n *  class=\"prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}-{{v4}}-{{v5}}-{{v6}}-{{v7}}-{{v8}}-{{v9}}suffix\"></div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * classMapInterpolateV(\n *  ['prefix', v0, '-', v1, '-', v2, '-', v3, '-', v4, '-', v5, '-', v6, '-', v7, '-', v9,\n *  'suffix']);\n * ```\n *.\n * @param values The collection of values and the strings in-between those values, beginning with\n * a string prefix and ending with a string suffix.\n * (e.g. `['prefix', value0, '-', value1, '-', value2, ..., value99, 'suffix']`)\n * @codeGenApi\n */\nexport function classMapInterpolateV(values: any[]): void {\n  const lView = getLView();\n  const interpolatedValue = interpolationV(lView, values);\n  checkStylingMap(keyValueArraySet, classStringParser, interpolatedValue, true);\n}\n"],"names":["ES5_DELEGATE_CTOR","ES2015_INHERITED_CLASS","ES2015_INHERITED_CLASS_WITH_CTOR","ES2015_INHERITED_CLASS_WITH_DELEGATE_CTOR","ReflectionCapabilities","constructor","reflect","this","_reflect","global","factory","t","args","_zipTypesAndAnnotations","paramTypes","paramAnnotations","result","newArray","length","i","Object","concat","_ownParameters","type","parentCtor","typeStr","toString","test","parameters","tsickleCtorParams","ctorParameters","map","ctorParam","convertTsickleDecoratorIntoMetadata","decorators","hasOwnProperty","PARAMETERS","getOwnMetadata","isType","getParentCtor","_ownAnnotations","typeOrFunc","annotations","ANNOTATIONS","ownAnnotations","_ownPropMetadata","propMetadata","propDecorators","keys","forEach","prop","PROP_METADATA","parentPropMetadata","propName","ownPropMetadata","push","hasLifecycleHook","lcProperty","Type","prototype","decoratorInvocations","decoratorInvocation","annotationCls","ctor","parentProto","getPrototypeOf","Attribute","makeParamDecorator","attributeName","__NG_ELEMENT_ID__","injectAttribute","getReflect","reflectDependencies","dep","meta","token","attribute","host","optional","self","skipSelf","Array","isArray","j","param","undefined","proto","Optional","ngMetadataName","SkipSelf","Self","Host","Inject","RuntimeError","ngDevMode","reflectDependency","modules","Map","findHostDirectiveDefs","currentDef","matchedDefs","hostDirectiveDefs","hostDirectives","hostDirectiveConfig","hostDirectiveDef","getDirectiveDef","directive","patchDeclaredInputs","declaredInputs","inputs","set","bindingArrayToMap","bindings","EMPTY_OBJ","exposedInputs","publicName","remappedPublicName","privateName","COPY_DIRECTIVE_FIELDS","COPY_COMPONENT_FIELDS","propertyInterpolate1","prefix","v0","suffix","sanitizer","lView","getLView","interpolatedValue","interpolation1","NO_CHANGE","tView","getTView","tNode","getSelectedTNode","elementPropertyInternal","RENDERER","ELEMENT_MARKER","marker","ICU_MARKER","I18nCreateOpCode","getInsertInFrontOfRNodeWithI18n","parentTNode","currentTNode","tNodeInsertBeforeIndex","insertBeforeIndex","getInsertInFrontOfRNodeWithNoI18n","unwrapRNode","processI18nInsertBefore","renderer","childTNode","childRNode","parentRElement","i18nParent","anchorRNode","componentOffset","i18nChild","nativeInsertBefore","addTNodeAndUpdateInsertBeforeIndex","previousTNodes","newTNode","existingTNode","isI18nText","isNewTNodeCreatedBefore","getInsertBeforeIndex","setInsertBeforeIndex","index","value","setI18nHandling","getTIcu","data","createTNodePlaceholder","createTNodeAtIndex","getCurrentICUCaseIndex","tIcu","currentCase","currentCaseLViewIndex","changeMask","changeMaskCounter","applyMutableOpCodes","mutableOpCodes","rootRNode","rootIdx","opCode","textNodeIndex","createTextNode","parentIdx","insertInFrontOf","parentRNode","nativeParentNode","refIdx","child","caseIndex","create","anchorIdx","elementNodeIndex","attrName","attrValue","setElementAttribute","getNativeByIndex","commentValue","commentNodeIndex","commentRNode","createCommentNode","attachPatchData","tagName","elementRNode","createElementNode","applyUpdateOpCodes","updateOpCodes","bindingsStartIndex","checkBit","skipCodes","renderStringify","nodeIndex","sanitizeFn","tNodeOrTagName","rText","updateTextNode","applyIcuSwitchCase","applyIcuUpdateCase","activeCaseIndex","mask","update","icuExpression","bindingValue","cases","indexOf","resolvedCase","getPluralCase","getLocaleId","getCaseIndex","applyIcuSwitchCaseRemove","removeCodes","remove","nodeOrIcuIndex","rNode","nativeRemoveNode","loadIcuContainerVisitor","_stack","_lView","_removes","_index","enterIcu","EMPTY_ARRAY","icuContainerIteratorNext","removeOpCode","tIcuIndex","TVIEW","pop","tIcuContainerNode","BINDING_REGEXP","ICU_REGEXP","NESTED_ICU","ICU_BLOCK_REGEXP","MARKER","SUBTEMPLATE_REGEXP","PH_REGEXP","NGSP_UNICODE_REGEXP","createTNodeAndAddOpCode","rootTNode","existingTNodes","createOpCodes","text","isICU","i18nNodeIdx","allocExpando","SHIFT","getCurrentParentTNode","APPEND_EAGERLY","COMMENT","ensureIcuContainerVisitorLoaded","tNodeIdx","setCurrentTNode","assertEqual","setTNodeInsertBeforeIndex","i18nStartFirstCreatePassProcessTextNode","hasBinding","match","generateBindingUpdateOpCodes","str","destinationNode","bindingStart","maskIndex","sizeIndex","startIndex","textParts","split","textValue","bindingIndex","parseInt","toMaskBit","countBindings","opCodes","count","Math","min","removeInnerTemplateTranslation","message","tagMatched","res","inTemplate","exec","substring","slice","icuStart","bindingMask","mainBinding","addUpdateIcuSwitch","setTIcu","values","valueArr","nestedIcus","icuIndex","parseIcuCase","join","addUpdateIcuUpdate","parseICUBlock","pattern","icuType","parts","i18nParseTextIntoPartsAndICU","replace","binding","pos","key","trim","blocks","prevPos","braceStack","results","braces","lastIndex","block","caseName","unsafeCaseHtml","inertBodyElement","getInertBodyHelper","getDocument","getInertBodyElement","inertRootNode","getTemplateContent","walkIcuTree","sharedUpdateOpCodes","parentNode","depth","currentNode","firstChild","newIndex","nodeType","Node","ELEMENT_NODE","element","toLowerCase","VALID_ELEMENTS","addCreateNodeAndAppend","elAttrs","attributes","attr","item","lowerAttrName","name","VALID_ATTRS","URI_ATTRS","_sanitizeUrl","addCreateAttribute","addRemoveNode","TEXT_NODE","textContent","COMMENT_NODE","isNestedIcu","addRemoveNestedIcu","nextSibling","appendToParentIdx","createAtIdx","PP_MULTI_VALUE_PLACEHOLDERS_REGEXP","PP_PLACEHOLDERS_REGEXP","PP_ICU_VARS_REGEXP","PP_ICU_PLACEHOLDERS_REGEXP","PP_ICUS_REGEXP","PP_CLOSE_TEMPLATE_REGEXP","PP_TEMPLATE_ID_REGEXP","i18nStart","messageIndex","subTemplateIndex","adjustedIndex","HEADER_OFFSET","getConstant","consts","firstCreatePass","parentTNodeIndex","existingTNodeStack","isRootTemplateMessage","start","end","search","RegExp","getTranslationForTemplate","msgParts","part","Error","isClosing","charCodeAt","Number","shift","unshift","i18nStartFirstCreatePass","tI18n","sameViewParentTNode","T_HOST","getClosestRElement","isComment","appendNow","createComment","applyCreateOpCodes","setInI18nBlock","i18nEnd","angularCoreEnv","r3","attributeInterpolate1","namespace","elementAttributeInternal","attributeInterpolate2","i0","v1","interpolation2","attributeInterpolate3","i1","v2","interpolation3","attributeInterpolate4","i2","v3","interpolation4","attributeInterpolate5","i3","v4","interpolation5","attributeInterpolate6","i4","v5","interpolation6","attributeInterpolate7","i5","v6","interpolation7","attributeInterpolate8","i6","v7","interpolation8","attributeInterpolateV","interpolated","interpolationV","defineInjectable","defineInjector","inject","invalidFactoryDep","rawHostDirectives","definition","dir","resolveForwardRef","outputs","superDef","superType","getSuperType","isComponentDef","cmp","dir","defAny","field","propertyInterpolate","propertyInterpolate2","propertyInterpolate3","propertyInterpolate4","propertyInterpolate5","propertyInterpolate6","propertyInterpolate7","propertyInterpolate8","propertyInterpolateV","styleMap","stylePropInterpolate1","valueSuffix","checkStylingProperty","stylePropInterpolate2","stylePropInterpolate3","stylePropInterpolate4","stylePropInterpolate5","stylePropInterpolate6","stylePropInterpolate7","stylePropInterpolate8","stylePropInterpolateV","attrsIndex","attrs","previousElementIndex","getCurrentTNode","i18nAttributesFirstPass","i18nExp","bindingUpdated","nextBindingIndex","getBindingIndex","applyI18n","replacements","matches","templateIdsStack","m","phs","tmpl","content","placeholders","placeholder","templateId","isCloseTemplateTag","currentTemplateId","idx","splice","_type","_idx","list","i18nPostprocess","ngModuleType","id","incoming","stringify","assertSameOrNotExisting","get","sanitization","getNativeByTNode","iframe","src","srcdoc","trustedHTMLFromString","errorMessage","forwardRef","isNgModule","getNgModuleDef","moduleQueue","flushingModuleQueue","isResolvedDeclaration","declaration","every","setScopeOnDeclaredComponents","moduleType","ngModule","declarations","flatten","transitiveScopes","transitiveScopesFor","NG_COMP_DEF","component","patchComponentDefWithScope","getComponentDef","NG_DIR_DEF","NG_PIPE_DEF","ngSelectorScope","componentDef","directiveDefs","from","compilation","directives","filter","def","pipeDefs","pipes","pipe","getPipeDef","schemas","transitiveCompileScopes","scopes","Set","exported","maybeUnwrapFn","imports","imported","importedScope","entry","add","declared","declaredWithDefs","exports","exportedType","exportedScope","transitiveScopesForNgModule","isStandalone","WeakMap","compilationDepth","compileDirective","ngDirectiveDef","addDirectiveFactoryDef","defineProperty","getDirectiveMetadata","compiler","getCompilerFacade","usage","kind","sourceMapUrl","metadata","configurable","facade","directiveMetadata","typeSourceSpan","createParseSourceSpan","usesInheritance","addDirectiveDefToUndecoratedParents","ngFactoryDef","NG_FACTORY_DEF","compileFactory","typeArgumentCount","deps","target","FactoryTarget","Directive","extendsDirectlyFromObject","selector","queries","extractQueriesMetadata","isContentQuery","lifecycle","usesOnChanges","exportAs","splitByComma","providers","viewQueries","isViewQuery","standalone","objPrototype","parent","shouldAddAbstractDirective","convertToR3QueryMetadata","propertyName","ann","predicate","descendants","first","read","static","emitDistinctChangesOnly","isQueryAnn","queriesMeta","stringifyForError","some","isInputAnnotation","piece","LIFECYCLE_HOOKS","hookName","current","metadataName","getPipeMetadata","pipeName","pure","makeDecorator","Input","c","changeDetection","ChangeDetectionStrategy","ngComponentDef","maybeQueueResolutionOfComponentResources","componentNeedsResolution","error","templateUrl","styleUrls","JSON","options","getJitOptions","preserveWhitespaces","encapsulation","defaultEncapsulation","ViewEncapsulation","template","styles","animations","interpolation","viewProviders","compileComponent","cachedDirectiveDefs","cachedPipeDefs","seen","rawDep","has","scope","getStandaloneDefFunctions","dependencies","flushModuleScopingQueueAsMuchAsPossible","p","ngPipeDef","Pipe","compilePipe","makePropDecorator","bindingPropertyName","hostPropertyName","eventName","classMapInterpolate1","checkStylingMap","keyValueArraySet","classStringParser","classMapInterpolate2","classMapInterpolate3","classMapInterpolate4","classMapInterpolate5","classMapInterpolate6","classMapInterpolate7","classMapInterpolate8","classMapInterpolateV"],"sourceRoot":""}