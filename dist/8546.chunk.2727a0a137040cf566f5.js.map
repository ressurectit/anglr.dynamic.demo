{"version":3,"file":"8546.chunk.2727a0a137040cf566f5.js","mappings":"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","sources":["webpack://ng-universal-demo/../../../../src/cdk/text-field/text-field-module.ts","webpack://ng-universal-demo/../../../../src/material/input/input-value-accessor.ts","webpack://ng-universal-demo/../../../../src/cdk/platform/features/input-types.ts","webpack://ng-universal-demo/../../../../src/cdk/text-field/autofill.ts","webpack://ng-universal-demo/../../../../src/material/input/input.ts","webpack://ng-universal-demo/../../../../src/material/input/module.ts"],"sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {NgModule} from '@angular/core';\nimport {CdkAutofill} from './autofill';\nimport {CdkTextareaAutosize} from './autosize';\n\n@NgModule({\n  declarations: [CdkAutofill, CdkTextareaAutosize],\n  exports: [CdkAutofill, CdkTextareaAutosize],\n})\nexport class TextFieldModule {}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {InjectionToken} from '@angular/core';\n\n/**\n * This token is used to inject the object whose value should be set into `MatInput`. If none is\n * provided, the native `HTMLInputElement` is used. Directives like `MatDatepickerInput` can provide\n * themselves for this token, in order to make `MatInput` delegate the getting and setting of the\n * value to them.\n */\nexport const MAT_INPUT_VALUE_ACCESSOR = new InjectionToken<{value: any}>(\n  'MAT_INPUT_VALUE_ACCESSOR',\n);\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/** Cached result Set of input types support by the current browser. */\nlet supportedInputTypes: Set<string>;\n\n/** Types of `<input>` that *might* be supported. */\nconst candidateInputTypes = [\n  // `color` must come first. Chrome 56 shows a warning if we change the type to `color` after\n  // first changing it to something else:\n  // The specified value \"\" does not conform to the required format.\n  // The format is \"#rrggbb\" where rr, gg, bb are two-digit hexadecimal numbers.\n  'color',\n  'button',\n  'checkbox',\n  'date',\n  'datetime-local',\n  'email',\n  'file',\n  'hidden',\n  'image',\n  'month',\n  'number',\n  'password',\n  'radio',\n  'range',\n  'reset',\n  'search',\n  'submit',\n  'tel',\n  'text',\n  'time',\n  'url',\n  'week',\n];\n\n/** @returns The input types supported by this browser. */\nexport function getSupportedInputTypes(): Set<string> {\n  // Result is cached.\n  if (supportedInputTypes) {\n    return supportedInputTypes;\n  }\n\n  // We can't check if an input type is not supported until we're on the browser, so say that\n  // everything is supported when not on the browser. We don't use `Platform` here since it's\n  // just a helper function and can't inject it.\n  if (typeof document !== 'object' || !document) {\n    supportedInputTypes = new Set(candidateInputTypes);\n    return supportedInputTypes;\n  }\n\n  let featureTestInput = document.createElement('input');\n  supportedInputTypes = new Set(\n    candidateInputTypes.filter(value => {\n      featureTestInput.setAttribute('type', value);\n      return featureTestInput.type === value;\n    }),\n  );\n\n  return supportedInputTypes;\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {Platform, normalizePassiveListenerOptions} from '@angular/cdk/platform';\nimport {\n  Directive,\n  ElementRef,\n  EventEmitter,\n  Injectable,\n  NgZone,\n  OnDestroy,\n  OnInit,\n  Output,\n} from '@angular/core';\nimport {coerceElement} from '@angular/cdk/coercion';\nimport {EMPTY, Observable, Subject} from 'rxjs';\n\n/** An event that is emitted when the autofill state of an input changes. */\nexport type AutofillEvent = {\n  /** The element whose autofill state changes. */\n  target: Element;\n  /** Whether the element is currently autofilled. */\n  isAutofilled: boolean;\n};\n\n/** Used to track info about currently monitored elements. */\ntype MonitoredElementInfo = {\n  readonly subject: Subject<AutofillEvent>;\n  unlisten: () => void;\n};\n\n/** Options to pass to the animationstart listener. */\nconst listenerOptions = normalizePassiveListenerOptions({passive: true});\n\n/**\n * An injectable service that can be used to monitor the autofill state of an input.\n * Based on the following blog post:\n * https://medium.com/@brunn/detecting-autofilled-fields-in-javascript-aed598d25da7\n */\n@Injectable({providedIn: 'root'})\nexport class AutofillMonitor implements OnDestroy {\n  private _monitoredElements = new Map<Element, MonitoredElementInfo>();\n\n  constructor(private _platform: Platform, private _ngZone: NgZone) {}\n\n  /**\n   * Monitor for changes in the autofill state of the given input element.\n   * @param element The element to monitor.\n   * @return A stream of autofill state changes.\n   */\n  monitor(element: Element): Observable<AutofillEvent>;\n\n  /**\n   * Monitor for changes in the autofill state of the given input element.\n   * @param element The element to monitor.\n   * @return A stream of autofill state changes.\n   */\n  monitor(element: ElementRef<Element>): Observable<AutofillEvent>;\n\n  monitor(elementOrRef: Element | ElementRef<Element>): Observable<AutofillEvent> {\n    if (!this._platform.isBrowser) {\n      return EMPTY;\n    }\n\n    const element = coerceElement(elementOrRef);\n    const info = this._monitoredElements.get(element);\n\n    if (info) {\n      return info.subject;\n    }\n\n    const result = new Subject<AutofillEvent>();\n    const cssClass = 'cdk-text-field-autofilled';\n    const listener = ((event: AnimationEvent) => {\n      // Animation events fire on initial element render, we check for the presence of the autofill\n      // CSS class to make sure this is a real change in state, not just the initial render before\n      // we fire off events.\n      if (\n        event.animationName === 'cdk-text-field-autofill-start' &&\n        !element.classList.contains(cssClass)\n      ) {\n        element.classList.add(cssClass);\n        this._ngZone.run(() => result.next({target: event.target as Element, isAutofilled: true}));\n      } else if (\n        event.animationName === 'cdk-text-field-autofill-end' &&\n        element.classList.contains(cssClass)\n      ) {\n        element.classList.remove(cssClass);\n        this._ngZone.run(() => result.next({target: event.target as Element, isAutofilled: false}));\n      }\n    }) as EventListenerOrEventListenerObject;\n\n    this._ngZone.runOutsideAngular(() => {\n      element.addEventListener('animationstart', listener, listenerOptions);\n      element.classList.add('cdk-text-field-autofill-monitored');\n    });\n\n    this._monitoredElements.set(element, {\n      subject: result,\n      unlisten: () => {\n        element.removeEventListener('animationstart', listener, listenerOptions);\n      },\n    });\n\n    return result;\n  }\n\n  /**\n   * Stop monitoring the autofill state of the given input element.\n   * @param element The element to stop monitoring.\n   */\n  stopMonitoring(element: Element): void;\n\n  /**\n   * Stop monitoring the autofill state of the given input element.\n   * @param element The element to stop monitoring.\n   */\n  stopMonitoring(element: ElementRef<Element>): void;\n\n  stopMonitoring(elementOrRef: Element | ElementRef<Element>): void {\n    const element = coerceElement(elementOrRef);\n    const info = this._monitoredElements.get(element);\n\n    if (info) {\n      info.unlisten();\n      info.subject.complete();\n      element.classList.remove('cdk-text-field-autofill-monitored');\n      element.classList.remove('cdk-text-field-autofilled');\n      this._monitoredElements.delete(element);\n    }\n  }\n\n  ngOnDestroy() {\n    this._monitoredElements.forEach((_info, element) => this.stopMonitoring(element));\n  }\n}\n\n/** A directive that can be used to monitor the autofill state of an input. */\n@Directive({\n  selector: '[cdkAutofill]',\n})\nexport class CdkAutofill implements OnDestroy, OnInit {\n  /** Emits when the autofill state of the element changes. */\n  @Output() readonly cdkAutofill = new EventEmitter<AutofillEvent>();\n\n  constructor(\n    private _elementRef: ElementRef<HTMLElement>,\n    private _autofillMonitor: AutofillMonitor,\n  ) {}\n\n  ngOnInit() {\n    this._autofillMonitor\n      .monitor(this._elementRef)\n      .subscribe(event => this.cdkAutofill.emit(event));\n  }\n\n  ngOnDestroy() {\n    this._autofillMonitor.stopMonitoring(this._elementRef);\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {BooleanInput, coerceBooleanProperty} from '@angular/cdk/coercion';\nimport {getSupportedInputTypes, Platform} from '@angular/cdk/platform';\nimport {AutofillMonitor} from '@angular/cdk/text-field';\nimport {\n  AfterViewInit,\n  Directive,\n  DoCheck,\n  ElementRef,\n  Inject,\n  Input,\n  NgZone,\n  OnChanges,\n  OnDestroy,\n  Optional,\n  Self,\n} from '@angular/core';\nimport {FormGroupDirective, NgControl, NgForm, Validators} from '@angular/forms';\nimport {CanUpdateErrorState, ErrorStateMatcher, mixinErrorState} from '@angular/material/core';\nimport {MatFormFieldControl, MatFormField, MAT_FORM_FIELD} from '@angular/material/form-field';\nimport {Subject} from 'rxjs';\nimport {getMatInputUnsupportedTypeError} from './input-errors';\nimport {MAT_INPUT_VALUE_ACCESSOR} from './input-value-accessor';\n\n// Invalid input type. Using one of these will throw an MatInputUnsupportedTypeError.\nconst MAT_INPUT_INVALID_TYPES = [\n  'button',\n  'checkbox',\n  'file',\n  'hidden',\n  'image',\n  'radio',\n  'range',\n  'reset',\n  'submit',\n];\n\nlet nextUniqueId = 0;\n\n// Boilerplate for applying mixins to MatInput.\n/** @docs-private */\nconst _MatInputBase = mixinErrorState(\n  class {\n    /**\n     * Emits whenever the component state changes and should cause the parent\n     * form field to update. Implemented as part of `MatFormFieldControl`.\n     * @docs-private\n     */\n    readonly stateChanges = new Subject<void>();\n\n    constructor(\n      public _defaultErrorStateMatcher: ErrorStateMatcher,\n      public _parentForm: NgForm,\n      public _parentFormGroup: FormGroupDirective,\n      /**\n       * Form control bound to the component.\n       * Implemented as part of `MatFormFieldControl`.\n       * @docs-private\n       */\n      public ngControl: NgControl,\n    ) {}\n  },\n);\n\n@Directive({\n  selector: `input[matInput], textarea[matInput], select[matNativeControl],\n      input[matNativeControl], textarea[matNativeControl]`,\n  exportAs: 'matInput',\n  host: {\n    'class': 'mat-mdc-input-element',\n    // The BaseMatInput parent class adds `mat-input-element`, `mat-form-field-control` and\n    // `mat-form-field-autofill-control` to the CSS class list, but this should not be added for\n    // this MDC equivalent input.\n    '[class.mat-input-server]': '_isServer',\n    '[class.mat-mdc-form-field-textarea-control]': '_isInFormField && _isTextarea',\n    '[class.mat-mdc-form-field-input-control]': '_isInFormField',\n    '[class.mdc-text-field__input]': '_isInFormField',\n    '[class.mat-mdc-native-select-inline]': '_isInlineSelect()',\n    // Native input properties that are overwritten by Angular inputs need to be synced with\n    // the native input element. Otherwise property bindings for those don't work.\n    '[id]': 'id',\n    '[disabled]': 'disabled',\n    '[required]': 'required',\n    '[attr.name]': 'name || null',\n    '[attr.readonly]': 'readonly && !_isNativeSelect || null',\n    // Only mark the input as invalid for assistive technology if it has a value since the\n    // state usually overlaps with `aria-required` when the input is empty and can be redundant.\n    '[attr.aria-invalid]': '(empty && required) ? null : errorState',\n    '[attr.aria-required]': 'required',\n    // Native input properties that are overwritten by Angular inputs need to be synced with\n    // the native input element. Otherwise property bindings for those don't work.\n    '[attr.id]': 'id',\n    '(focus)': '_focusChanged(true)',\n    '(blur)': '_focusChanged(false)',\n    '(input)': '_onInput()',\n  },\n  providers: [{provide: MatFormFieldControl, useExisting: MatInput}],\n})\nexport class MatInput\n  extends _MatInputBase\n  implements\n    MatFormFieldControl<any>,\n    OnChanges,\n    OnDestroy,\n    AfterViewInit,\n    DoCheck,\n    CanUpdateErrorState\n{\n  protected _uid = `mat-input-${nextUniqueId++}`;\n  protected _previousNativeValue: any;\n  private _inputValueAccessor: {value: any};\n  private _previousPlaceholder: string | null;\n\n  /** Whether the component is being rendered on the server. */\n  readonly _isServer: boolean;\n\n  /** Whether the component is a native html select. */\n  readonly _isNativeSelect: boolean;\n\n  /** Whether the component is a textarea. */\n  readonly _isTextarea: boolean;\n\n  /** Whether the input is inside of a form field. */\n  readonly _isInFormField: boolean;\n\n  /**\n   * Implemented as part of MatFormFieldControl.\n   * @docs-private\n   */\n  focused: boolean = false;\n\n  /**\n   * Implemented as part of MatFormFieldControl.\n   * @docs-private\n   */\n  override readonly stateChanges: Subject<void> = new Subject<void>();\n\n  /**\n   * Implemented as part of MatFormFieldControl.\n   * @docs-private\n   */\n  controlType: string = 'mat-input';\n\n  /**\n   * Implemented as part of MatFormFieldControl.\n   * @docs-private\n   */\n  autofilled = false;\n\n  /**\n   * Implemented as part of MatFormFieldControl.\n   * @docs-private\n   */\n  @Input()\n  get disabled(): boolean {\n    return this._disabled;\n  }\n  set disabled(value: BooleanInput) {\n    this._disabled = coerceBooleanProperty(value);\n\n    // Browsers may not fire the blur event if the input is disabled too quickly.\n    // Reset from here to ensure that the element doesn't become stuck.\n    if (this.focused) {\n      this.focused = false;\n      this.stateChanges.next();\n    }\n  }\n  protected _disabled = false;\n\n  /**\n   * Implemented as part of MatFormFieldControl.\n   * @docs-private\n   */\n  @Input()\n  get id(): string {\n    return this._id;\n  }\n  set id(value: string) {\n    this._id = value || this._uid;\n  }\n  protected _id: string;\n\n  /**\n   * Implemented as part of MatFormFieldControl.\n   * @docs-private\n   */\n  @Input() placeholder: string;\n\n  /**\n   * Name of the input.\n   * @docs-private\n   */\n  @Input() name: string;\n\n  /**\n   * Implemented as part of MatFormFieldControl.\n   * @docs-private\n   */\n  @Input()\n  get required(): boolean {\n    return this._required ?? this.ngControl?.control?.hasValidator(Validators.required) ?? false;\n  }\n  set required(value: BooleanInput) {\n    this._required = coerceBooleanProperty(value);\n  }\n  protected _required: boolean | undefined;\n\n  /** Input type of the element. */\n  @Input()\n  get type(): string {\n    return this._type;\n  }\n  set type(value: string) {\n    this._type = value || 'text';\n    this._validateType();\n\n    // When using Angular inputs, developers are no longer able to set the properties on the native\n    // input element. To ensure that bindings for `type` work, we need to sync the setter\n    // with the native property. Textarea elements don't support the type property or attribute.\n    if (!this._isTextarea && getSupportedInputTypes().has(this._type)) {\n      (this._elementRef.nativeElement as HTMLInputElement).type = this._type;\n    }\n  }\n  protected _type = 'text';\n\n  /** An object used to control when error messages are shown. */\n  @Input() override errorStateMatcher: ErrorStateMatcher;\n\n  /**\n   * Implemented as part of MatFormFieldControl.\n   * @docs-private\n   */\n  @Input('aria-describedby') userAriaDescribedBy: string;\n\n  /**\n   * Implemented as part of MatFormFieldControl.\n   * @docs-private\n   */\n  @Input()\n  get value(): string {\n    return this._inputValueAccessor.value;\n  }\n  set value(value: any) {\n    if (value !== this.value) {\n      this._inputValueAccessor.value = value;\n      this.stateChanges.next();\n    }\n  }\n\n  /** Whether the element is readonly. */\n  @Input()\n  get readonly(): boolean {\n    return this._readonly;\n  }\n  set readonly(value: BooleanInput) {\n    this._readonly = coerceBooleanProperty(value);\n  }\n  private _readonly = false;\n\n  protected _neverEmptyInputTypes = [\n    'date',\n    'datetime',\n    'datetime-local',\n    'month',\n    'time',\n    'week',\n  ].filter(t => getSupportedInputTypes().has(t));\n\n  constructor(\n    protected _elementRef: ElementRef<HTMLInputElement | HTMLSelectElement | HTMLTextAreaElement>,\n    protected _platform: Platform,\n    @Optional() @Self() ngControl: NgControl,\n    @Optional() _parentForm: NgForm,\n    @Optional() _parentFormGroup: FormGroupDirective,\n    _defaultErrorStateMatcher: ErrorStateMatcher,\n    @Optional() @Self() @Inject(MAT_INPUT_VALUE_ACCESSOR) inputValueAccessor: any,\n    private _autofillMonitor: AutofillMonitor,\n    ngZone: NgZone,\n    // TODO: Remove this once the legacy appearance has been removed. We only need\n    // to inject the form field for determining whether the placeholder has been promoted.\n    @Optional() @Inject(MAT_FORM_FIELD) protected _formField?: MatFormField,\n  ) {\n    super(_defaultErrorStateMatcher, _parentForm, _parentFormGroup, ngControl);\n\n    const element = this._elementRef.nativeElement;\n    const nodeName = element.nodeName.toLowerCase();\n\n    // If no input value accessor was explicitly specified, use the element as the input value\n    // accessor.\n    this._inputValueAccessor = inputValueAccessor || element;\n\n    this._previousNativeValue = this.value;\n\n    // Force setter to be called in case id was not specified.\n    this.id = this.id;\n\n    // On some versions of iOS the caret gets stuck in the wrong place when holding down the delete\n    // key. In order to get around this we need to \"jiggle\" the caret loose. Since this bug only\n    // exists on iOS, we only bother to install the listener on iOS.\n    if (_platform.IOS) {\n      ngZone.runOutsideAngular(() => {\n        _elementRef.nativeElement.addEventListener('keyup', this._iOSKeyupListener);\n      });\n    }\n\n    this._isServer = !this._platform.isBrowser;\n    this._isNativeSelect = nodeName === 'select';\n    this._isTextarea = nodeName === 'textarea';\n    this._isInFormField = !!_formField;\n\n    if (this._isNativeSelect) {\n      this.controlType = (element as HTMLSelectElement).multiple\n        ? 'mat-native-select-multiple'\n        : 'mat-native-select';\n    }\n  }\n\n  ngAfterViewInit() {\n    if (this._platform.isBrowser) {\n      this._autofillMonitor.monitor(this._elementRef.nativeElement).subscribe(event => {\n        this.autofilled = event.isAutofilled;\n        this.stateChanges.next();\n      });\n    }\n  }\n\n  ngOnChanges() {\n    this.stateChanges.next();\n  }\n\n  ngOnDestroy() {\n    this.stateChanges.complete();\n\n    if (this._platform.isBrowser) {\n      this._autofillMonitor.stopMonitoring(this._elementRef.nativeElement);\n    }\n\n    if (this._platform.IOS) {\n      this._elementRef.nativeElement.removeEventListener('keyup', this._iOSKeyupListener);\n    }\n  }\n\n  ngDoCheck() {\n    if (this.ngControl) {\n      // We need to re-evaluate this on every change detection cycle, because there are some\n      // error triggers that we can't subscribe to (e.g. parent form submissions). This means\n      // that whatever logic is in here has to be super lean or we risk destroying the performance.\n      this.updateErrorState();\n\n      // Since the input isn't a `ControlValueAccessor`, we don't have a good way of knowing when\n      // the disabled state has changed. We can't use the `ngControl.statusChanges`, because it\n      // won't fire if the input is disabled with `emitEvents = false`, despite the input becoming\n      // disabled.\n      if (this.ngControl.disabled !== null && this.ngControl.disabled !== this.disabled) {\n        this.disabled = this.ngControl.disabled;\n        this.stateChanges.next();\n      }\n    }\n\n    // We need to dirty-check the native element's value, because there are some cases where\n    // we won't be notified when it changes (e.g. the consumer isn't using forms or they're\n    // updating the value using `emitEvent: false`).\n    this._dirtyCheckNativeValue();\n\n    // We need to dirty-check and set the placeholder attribute ourselves, because whether it's\n    // present or not depends on a query which is prone to \"changed after checked\" errors.\n    this._dirtyCheckPlaceholder();\n  }\n\n  /** Focuses the input. */\n  focus(options?: FocusOptions): void {\n    this._elementRef.nativeElement.focus(options);\n  }\n\n  /** Callback for the cases where the focused state of the input changes. */\n  _focusChanged(isFocused: boolean) {\n    if (isFocused !== this.focused) {\n      this.focused = isFocused;\n      this.stateChanges.next();\n    }\n  }\n\n  _onInput() {\n    // This is a noop function and is used to let Angular know whenever the value changes.\n    // Angular will run a new change detection each time the `input` event has been dispatched.\n    // It's necessary that Angular recognizes the value change, because when floatingLabel\n    // is set to false and Angular forms aren't used, the placeholder won't recognize the\n    // value changes and will not disappear.\n    // Listening to the input event wouldn't be necessary when the input is using the\n    // FormsModule or ReactiveFormsModule, because Angular forms also listens to input events.\n  }\n\n  /** Does some manual dirty checking on the native input `value` property. */\n  protected _dirtyCheckNativeValue() {\n    const newValue = this._elementRef.nativeElement.value;\n\n    if (this._previousNativeValue !== newValue) {\n      this._previousNativeValue = newValue;\n      this.stateChanges.next();\n    }\n  }\n\n  /** Does some manual dirty checking on the native input `placeholder` attribute. */\n  private _dirtyCheckPlaceholder() {\n    const placeholder = this._getPlaceholder();\n    if (placeholder !== this._previousPlaceholder) {\n      const element = this._elementRef.nativeElement;\n      this._previousPlaceholder = placeholder;\n      placeholder\n        ? element.setAttribute('placeholder', placeholder)\n        : element.removeAttribute('placeholder');\n    }\n  }\n\n  /** Gets the current placeholder of the form field. */\n  protected _getPlaceholder(): string | null {\n    return this.placeholder || null;\n  }\n\n  /** Make sure the input is a supported type. */\n  protected _validateType() {\n    if (\n      MAT_INPUT_INVALID_TYPES.indexOf(this._type) > -1 &&\n      (typeof ngDevMode === 'undefined' || ngDevMode)\n    ) {\n      throw getMatInputUnsupportedTypeError(this._type);\n    }\n  }\n\n  /** Checks whether the input type is one of the types that are never empty. */\n  protected _isNeverEmpty() {\n    return this._neverEmptyInputTypes.indexOf(this._type) > -1;\n  }\n\n  /** Checks whether the input is invalid based on the native validation. */\n  protected _isBadInput() {\n    // The `validity` property won't be present on platform-server.\n    let validity = (this._elementRef.nativeElement as HTMLInputElement).validity;\n    return validity && validity.badInput;\n  }\n\n  /**\n   * Implemented as part of MatFormFieldControl.\n   * @docs-private\n   */\n  get empty(): boolean {\n    return (\n      !this._isNeverEmpty() &&\n      !this._elementRef.nativeElement.value &&\n      !this._isBadInput() &&\n      !this.autofilled\n    );\n  }\n\n  /**\n   * Implemented as part of MatFormFieldControl.\n   * @docs-private\n   */\n  get shouldLabelFloat(): boolean {\n    if (this._isNativeSelect) {\n      // For a single-selection `<select>`, the label should float when the selected option has\n      // a non-empty display value. For a `<select multiple>`, the label *always* floats to avoid\n      // overlapping the label with the options.\n      const selectElement = this._elementRef.nativeElement as HTMLSelectElement;\n      const firstOption: HTMLOptionElement | undefined = selectElement.options[0];\n\n      // On most browsers the `selectedIndex` will always be 0, however on IE and Edge it'll be\n      // -1 if the `value` is set to something, that isn't in the list of options, at a later point.\n      return (\n        this.focused ||\n        selectElement.multiple ||\n        !this.empty ||\n        !!(selectElement.selectedIndex > -1 && firstOption && firstOption.label)\n      );\n    } else {\n      return this.focused || !this.empty;\n    }\n  }\n\n  /**\n   * Implemented as part of MatFormFieldControl.\n   * @docs-private\n   */\n  setDescribedByIds(ids: string[]) {\n    if (ids.length) {\n      this._elementRef.nativeElement.setAttribute('aria-describedby', ids.join(' '));\n    } else {\n      this._elementRef.nativeElement.removeAttribute('aria-describedby');\n    }\n  }\n\n  /**\n   * Implemented as part of MatFormFieldControl.\n   * @docs-private\n   */\n  onContainerClick() {\n    // Do not re-focus the input element if the element is already focused. Otherwise it can happen\n    // that someone clicks on a time input and the cursor resets to the \"hours\" field while the\n    // \"minutes\" field was actually clicked. See: https://github.com/angular/components/issues/12849\n    if (!this.focused) {\n      this.focus();\n    }\n  }\n\n  /** Whether the form control is a native select that is displayed inline. */\n  _isInlineSelect(): boolean {\n    const element = this._elementRef.nativeElement as HTMLSelectElement;\n    return this._isNativeSelect && (element.multiple || element.size > 1);\n  }\n\n  private _iOSKeyupListener = (event: Event): void => {\n    const el = event.target as HTMLInputElement;\n\n    // Note: We specifically check for 0, rather than `!el.selectionStart`, because the two\n    // indicate different things. If the value is 0, it means that the caret is at the start\n    // of the input, whereas a value of `null` means that the input doesn't support\n    // manipulating the selection range. Inputs that don't support setting the selection range\n    // will throw an error so we want to avoid calling `setSelectionRange` on them. See:\n    // https://html.spec.whatwg.org/multipage/input.html#do-not-apply\n    if (!el.value && el.selectionStart === 0 && el.selectionEnd === 0) {\n      // Note: Just setting `0, 0` doesn't fix the issue. Setting\n      // `1, 1` fixes it for the first time that you type text and\n      // then hold delete. Toggling to `1, 1` and then back to\n      // `0, 0` seems to completely fix it.\n      el.setSelectionRange(1, 1);\n      el.setSelectionRange(0, 0);\n    }\n  };\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {TextFieldModule} from '@angular/cdk/text-field';\nimport {NgModule} from '@angular/core';\nimport {MatCommonModule} from '@angular/material/core';\nimport {MatFormFieldModule} from '@angular/material/form-field';\nimport {MatInput} from './input';\n\n@NgModule({\n  imports: [MatCommonModule, MatFormFieldModule],\n  exports: [MatInput, MatFormFieldModule, TextFieldModule, MatCommonModule],\n  declarations: [MatInput],\n})\nexport class MatInputModule {}\n"],"names":["TextFieldModule","MAT_INPUT_VALUE_ACCESSOR","InjectionToken","supportedInputTypes","candidateInputTypes","getSupportedInputTypes","document","Set","featureTestInput","createElement","filter","value","setAttribute","type","listenerOptions","normalizePassiveListenerOptions","passive","AutofillMonitor","constructor","_platform","_ngZone","_monitoredElements","Map","monitor","elementOrRef","this","isBrowser","EMPTY","element","coerceElement","info","get","subject","result","Subject","cssClass","listener","event","animationName","classList","contains","remove","run","next","target","isAutofilled","add","runOutsideAngular","addEventListener","set","unlisten","removeEventListener","stopMonitoring","complete","delete","ngOnDestroy","forEach","_info","i1","i0","factory","ɵfac","providedIn","CdkAutofill","_elementRef","_autofillMonitor","cdkAutofill","EventEmitter","ngOnInit","subscribe","emit","selectors","outputs","MAT_INPUT_INVALID_TYPES","nextUniqueId","_MatInputBase","mixinErrorState","_defaultErrorStateMatcher","_parentForm","_parentFormGroup","ngControl","stateChanges","MatInput","disabled","_disabled","coerceBooleanProperty","focused","id","_id","_uid","required","_required","control","hasValidator","Validators","_type","_validateType","_isTextarea","has","nativeElement","_inputValueAccessor","readonly","_readonly","inputValueAccessor","ngZone","_formField","super","controlType","autofilled","_neverEmptyInputTypes","t","_iOSKeyupListener","el","selectionStart","selectionEnd","setSelectionRange","nodeName","toLowerCase","_previousNativeValue","IOS","_isServer","_isNativeSelect","_isInFormField","multiple","ngAfterViewInit","ngOnChanges","ngDoCheck","updateErrorState","_dirtyCheckNativeValue","_dirtyCheckPlaceholder","focus","options","_focusChanged","isFocused","_onInput","newValue","placeholder","_getPlaceholder","_previousPlaceholder","removeAttribute","indexOf","_isNeverEmpty","_isBadInput","validity","badInput","empty","shouldLabelFloat","selectElement","firstOption","selectedIndex","label","setDescribedByIds","ids","length","join","onContainerClick","_isInlineSelect","size","i2","i3","i4","MAT_FORM_FIELD","hostAttrs","hostVars","hostBindings","rf","ctx","provide","MatFormFieldControl","useExisting","MatInputModule","MatCommonModule","MatFormFieldModule"],"sourceRoot":""}