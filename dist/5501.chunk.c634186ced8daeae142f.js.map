{"version":3,"file":"5501.chunk.c634186ced8daeae142f.js","mappings":"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","sources":["webpack://ng-universal-demo/../../../../router/src/decorators/componentRoute.decorator.ts","webpack://ng-universal-demo/../../../../router/src/decorators/moduleRoutes.decorator.ts","webpack://ng-universal-demo/../../../../src/cdk/drag-drop/directives/drop-list-group.ts","webpack://ng-universal-demo/../../../../src/cdk/drag-drop/directives/drop-list.ts","webpack://ng-universal-demo/../../../../src/cdk/drag-drop/drag-drop-module.ts"],"sourcesContent":["import {Route} from '@angular/router';\nimport {isBlank} from '@jscrpt/common';\n\n/**\n * Extended type with route definition\n */\nexport interface RouteDecoratedComponent\n{\n    /**\n     * Definition of routes that are assigned to this type\n     */\n    routeValues: Route[];\n}\n\n/**\n * Type that represents options that can be passed to control represented by model property\n */\nexport type ComponentRouteDefinition = Omit<Route, keyof Pick<Route, 'component'>>;\n\n/**\n * Defines route for component on which is this decorator applied\n * @param route - route Definition of route, does not require component to be set\n */\nexport function ComponentRoute(route: ComponentRouteDefinition): ClassDecorator\n{\n    return function <TFunction extends Function> (target: TFunction): TFunction\n    {\n        const rt = route as Route;\n\n        rt.component = <any>target;\n\n        const routeDecoratedComponent: RouteDecoratedComponent = <any>target;\n\n        if(isBlank(routeDecoratedComponent.routeValues))\n        {\n            Object.defineProperty(target,\n                                  'routeValues',\n                                  {\n                                      enumerable: true,\n                                      configurable: false,\n                                      writable: false,\n                                      value: []\n                                  });\n        }\n\n        routeDecoratedComponent.routeValues.push(rt);\n\n        return target;\n    };\n}","import {Type} from '@angular/core';\nimport {RouterModule, Route, ExtraOptions} from '@angular/router';\n\nimport {extractRoutes} from '../misc/utils';\n\n/**\n * Extended route with possibility to extract children from components\n */\nexport interface ComponentRouteChildren extends Route\n{\n    /**\n     * Array of components which contains routes\n     */\n    childrenComponents?: Type<any>[];\n}\n\n/**\n * Describes options for ModuleRoutes decorator\n */\nexport interface ModuleRoutesOptions\n{\n    /**\n     * Indication that `forRoot` should be used during registration of routes\n     */\n    rootModule?: boolean;\n\n    /**\n     * Extra options used for `forRoot` module creation\n     */\n    rootModuleConfig?: ExtraOptions;\n\n    /**\n     * Routes that will be set before routedComponents\n     */\n    staticRoutesBefore?: ComponentRouteChildren[];\n\n    /**\n     * Routes that will be set after routedComponents\n     */\n    staticRoutesAfter?: ComponentRouteChildren[];\n}\n\n/**\n * Extracts routes from children components\n * @param route - Route which can contain array of components with routes\n */\nfunction extractChildrenComponents(route: ComponentRouteChildren): Route\n{\n    if(route.childrenComponents && route.childrenComponents.length)\n    {\n        const routes: ComponentRouteChildren[] = extractRoutes(route.childrenComponents).map(extractChildrenComponents);\n\n        if(route.children && route.children.length)\n        {\n            route.children =\n            [\n                ...route.children,\n                ...routes\n            ];\n        }\n        else\n        {\n            route.children = routes;\n        }\n    }\n\n    return route;\n}\n\n/**\n * Registers routes for module to which is attached\n * @param routedComponents - Array of components that will be used for routes extration\n * @param options - Optional options for defining routes\n */\nexport function ModuleRoutes(routedComponents: Type<any>[], options: ModuleRoutesOptions = {rootModule: false, staticRoutesAfter: [], staticRoutesBefore: []})\n{\n    return function<TFunction extends Function> (target: TFunction): TFunction\n    {\n        const ngModule: \n        {\n            ɵinj:\n            {\n                imports: any[]\n            }\n        } = target as any;\n        \n        if(ngModule.ɵinj && Array.isArray(ngModule.ɵinj.imports))\n        {\n            const routes = \n            [\n                ...(options.staticRoutesBefore || []).map(extractChildrenComponents),\n                ...extractRoutes(routedComponents).map(extractChildrenComponents),\n                ...(options.staticRoutesAfter || []).map(extractChildrenComponents)\n            ];\n\n            ngModule.ɵinj.imports.push(options.rootModule ? RouterModule.forRoot(routes, options.rootModuleConfig) : RouterModule.forChild(routes));\n        }\n\n        return target;\n    };\n}","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {Directive, OnDestroy, Input, InjectionToken, booleanAttribute} from '@angular/core';\n\n/**\n * Injection token that can be used to reference instances of `CdkDropListGroup`. It serves as\n * alternative token to the actual `CdkDropListGroup` class which could cause unnecessary\n * retention of the class and its directive metadata.\n */\nexport const CDK_DROP_LIST_GROUP = new InjectionToken<CdkDropListGroup<unknown>>(\n  'CdkDropListGroup',\n);\n\n/**\n * Declaratively connects sibling `cdkDropList` instances together. All of the `cdkDropList`\n * elements that are placed inside a `cdkDropListGroup` will be connected to each other\n * automatically. Can be used as an alternative to the `cdkDropListConnectedTo` input\n * from `cdkDropList`.\n */\n@Directive({\n  selector: '[cdkDropListGroup]',\n  exportAs: 'cdkDropListGroup',\n  standalone: true,\n  providers: [{provide: CDK_DROP_LIST_GROUP, useExisting: CdkDropListGroup}],\n})\nexport class CdkDropListGroup<T> implements OnDestroy {\n  /** Drop lists registered inside the group. */\n  readonly _items = new Set<T>();\n\n  /** Whether starting a dragging sequence from inside this group is disabled. */\n  @Input({alias: 'cdkDropListGroupDisabled', transform: booleanAttribute})\n  disabled: boolean = false;\n\n  ngOnDestroy() {\n    this._items.clear();\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {NumberInput, coerceArray, coerceNumberProperty} from '@angular/cdk/coercion';\nimport {\n  ElementRef,\n  EventEmitter,\n  Input,\n  OnDestroy,\n  Output,\n  Optional,\n  Directive,\n  ChangeDetectorRef,\n  SkipSelf,\n  Inject,\n  booleanAttribute,\n} from '@angular/core';\nimport {Directionality} from '@angular/cdk/bidi';\nimport {ScrollDispatcher} from '@angular/cdk/scrolling';\nimport {CDK_DROP_LIST, CdkDrag} from './drag';\nimport {CdkDragDrop, CdkDragEnter, CdkDragExit, CdkDragSortEvent} from '../drag-events';\nimport {CDK_DROP_LIST_GROUP, CdkDropListGroup} from './drop-list-group';\nimport {DropListRef} from '../drop-list-ref';\nimport {DragRef} from '../drag-ref';\nimport {DragDrop} from '../drag-drop';\nimport {DropListOrientation, DragAxis, DragDropConfig, CDK_DRAG_CONFIG} from './config';\nimport {merge, Subject} from 'rxjs';\nimport {startWith, takeUntil} from 'rxjs/operators';\nimport {assertElementNode} from './assertions';\n\n/** Counter used to generate unique ids for drop zones. */\nlet _uniqueIdCounter = 0;\n\n/** Container that wraps a set of draggable items. */\n@Directive({\n  selector: '[cdkDropList], cdk-drop-list',\n  exportAs: 'cdkDropList',\n  standalone: true,\n  providers: [\n    // Prevent child drop lists from picking up the same group as their parent.\n    {provide: CDK_DROP_LIST_GROUP, useValue: undefined},\n    {provide: CDK_DROP_LIST, useExisting: CdkDropList},\n  ],\n  host: {\n    'class': 'cdk-drop-list',\n    '[attr.id]': 'id',\n    '[class.cdk-drop-list-disabled]': 'disabled',\n    '[class.cdk-drop-list-dragging]': '_dropListRef.isDragging()',\n    '[class.cdk-drop-list-receiving]': '_dropListRef.isReceiving()',\n  },\n})\nexport class CdkDropList<T = any> implements OnDestroy {\n  /** Emits when the list has been destroyed. */\n  private readonly _destroyed = new Subject<void>();\n\n  /** Whether the element's scrollable parents have been resolved. */\n  private _scrollableParentsResolved: boolean;\n\n  /** Keeps track of the drop lists that are currently on the page. */\n  private static _dropLists: CdkDropList[] = [];\n\n  /** Reference to the underlying drop list instance. */\n  _dropListRef: DropListRef<CdkDropList<T>>;\n\n  /**\n   * Other draggable containers that this container is connected to and into which the\n   * container's items can be transferred. Can either be references to other drop containers,\n   * or their unique IDs.\n   */\n  @Input('cdkDropListConnectedTo')\n  connectedTo: (CdkDropList | string)[] | CdkDropList | string = [];\n\n  /** Arbitrary data to attach to this container. */\n  @Input('cdkDropListData') data: T;\n\n  /** Direction in which the list is oriented. */\n  @Input('cdkDropListOrientation') orientation: DropListOrientation;\n\n  /**\n   * Unique ID for the drop zone. Can be used as a reference\n   * in the `connectedTo` of another `CdkDropList`.\n   */\n  @Input() id: string = `cdk-drop-list-${_uniqueIdCounter++}`;\n\n  /** Locks the position of the draggable elements inside the container along the specified axis. */\n  @Input('cdkDropListLockAxis') lockAxis: DragAxis;\n\n  /** Whether starting a dragging sequence from this container is disabled. */\n  @Input({alias: 'cdkDropListDisabled', transform: booleanAttribute})\n  get disabled(): boolean {\n    return this._disabled || (!!this._group && this._group.disabled);\n  }\n  set disabled(value: boolean) {\n    // Usually we sync the directive and ref state right before dragging starts, in order to have\n    // a single point of failure and to avoid having to use setters for everything. `disabled` is\n    // a special case, because it can prevent the `beforeStarted` event from firing, which can lock\n    // the user in a disabled state, so we also need to sync it as it's being set.\n    this._dropListRef.disabled = this._disabled = value;\n  }\n  private _disabled: boolean;\n\n  /** Whether sorting within this drop list is disabled. */\n  @Input({alias: 'cdkDropListSortingDisabled', transform: booleanAttribute})\n  sortingDisabled: boolean;\n\n  /**\n   * Function that is used to determine whether an item\n   * is allowed to be moved into a drop container.\n   */\n  @Input('cdkDropListEnterPredicate')\n  enterPredicate: (drag: CdkDrag, drop: CdkDropList) => boolean = () => true;\n\n  /** Functions that is used to determine whether an item can be sorted into a particular index. */\n  @Input('cdkDropListSortPredicate')\n  sortPredicate: (index: number, drag: CdkDrag, drop: CdkDropList) => boolean = () => true;\n\n  /** Whether to auto-scroll the view when the user moves their pointer close to the edges. */\n  @Input({alias: 'cdkDropListAutoScrollDisabled', transform: booleanAttribute})\n  autoScrollDisabled: boolean;\n\n  /** Number of pixels to scroll for each frame when auto-scrolling an element. */\n  @Input('cdkDropListAutoScrollStep')\n  autoScrollStep: NumberInput;\n\n  /** Emits when the user drops an item inside the container. */\n  @Output('cdkDropListDropped')\n  readonly dropped: EventEmitter<CdkDragDrop<T, any>> = new EventEmitter<CdkDragDrop<T, any>>();\n\n  /**\n   * Emits when the user has moved a new drag item into this container.\n   */\n  @Output('cdkDropListEntered')\n  readonly entered: EventEmitter<CdkDragEnter<T>> = new EventEmitter<CdkDragEnter<T>>();\n\n  /**\n   * Emits when the user removes an item from the container\n   * by dragging it into another container.\n   */\n  @Output('cdkDropListExited')\n  readonly exited: EventEmitter<CdkDragExit<T>> = new EventEmitter<CdkDragExit<T>>();\n\n  /** Emits as the user is swapping items while actively dragging. */\n  @Output('cdkDropListSorted')\n  readonly sorted: EventEmitter<CdkDragSortEvent<T>> = new EventEmitter<CdkDragSortEvent<T>>();\n\n  /**\n   * Keeps track of the items that are registered with this container. Historically we used to\n   * do this with a `ContentChildren` query, however queries don't handle transplanted views very\n   * well which means that we can't handle cases like dragging the headers of a `mat-table`\n   * correctly. What we do instead is to have the items register themselves with the container\n   * and then we sort them based on their position in the DOM.\n   */\n  private _unsortedItems = new Set<CdkDrag>();\n\n  constructor(\n    /** Element that the drop list is attached to. */\n    public element: ElementRef<HTMLElement>,\n    dragDrop: DragDrop,\n    private _changeDetectorRef: ChangeDetectorRef,\n    private _scrollDispatcher: ScrollDispatcher,\n    @Optional() private _dir?: Directionality,\n    @Optional()\n    @Inject(CDK_DROP_LIST_GROUP)\n    @SkipSelf()\n    private _group?: CdkDropListGroup<CdkDropList>,\n    @Optional() @Inject(CDK_DRAG_CONFIG) config?: DragDropConfig,\n  ) {\n    if (typeof ngDevMode === 'undefined' || ngDevMode) {\n      assertElementNode(element.nativeElement, 'cdkDropList');\n    }\n\n    this._dropListRef = dragDrop.createDropList(element);\n    this._dropListRef.data = this;\n\n    if (config) {\n      this._assignDefaults(config);\n    }\n\n    this._dropListRef.enterPredicate = (drag: DragRef<CdkDrag>, drop: DropListRef<CdkDropList>) => {\n      return this.enterPredicate(drag.data, drop.data);\n    };\n\n    this._dropListRef.sortPredicate = (\n      index: number,\n      drag: DragRef<CdkDrag>,\n      drop: DropListRef<CdkDropList>,\n    ) => {\n      return this.sortPredicate(index, drag.data, drop.data);\n    };\n\n    this._setupInputSyncSubscription(this._dropListRef);\n    this._handleEvents(this._dropListRef);\n    CdkDropList._dropLists.push(this);\n\n    if (_group) {\n      _group._items.add(this);\n    }\n  }\n\n  /** Registers an items with the drop list. */\n  addItem(item: CdkDrag): void {\n    this._unsortedItems.add(item);\n\n    if (this._dropListRef.isDragging()) {\n      this._syncItemsWithRef();\n    }\n  }\n\n  /** Removes an item from the drop list. */\n  removeItem(item: CdkDrag): void {\n    this._unsortedItems.delete(item);\n\n    if (this._dropListRef.isDragging()) {\n      this._syncItemsWithRef();\n    }\n  }\n\n  /** Gets the registered items in the list, sorted by their position in the DOM. */\n  getSortedItems(): CdkDrag[] {\n    return Array.from(this._unsortedItems).sort((a: CdkDrag, b: CdkDrag) => {\n      const documentPosition = a._dragRef\n        .getVisibleElement()\n        .compareDocumentPosition(b._dragRef.getVisibleElement());\n\n      // `compareDocumentPosition` returns a bitmask so we have to use a bitwise operator.\n      // https://developer.mozilla.org/en-US/docs/Web/API/Node/compareDocumentPosition\n      // tslint:disable-next-line:no-bitwise\n      return documentPosition & Node.DOCUMENT_POSITION_FOLLOWING ? -1 : 1;\n    });\n  }\n\n  ngOnDestroy() {\n    const index = CdkDropList._dropLists.indexOf(this);\n\n    if (index > -1) {\n      CdkDropList._dropLists.splice(index, 1);\n    }\n\n    if (this._group) {\n      this._group._items.delete(this);\n    }\n\n    this._unsortedItems.clear();\n    this._dropListRef.dispose();\n    this._destroyed.next();\n    this._destroyed.complete();\n  }\n\n  /** Syncs the inputs of the CdkDropList with the options of the underlying DropListRef. */\n  private _setupInputSyncSubscription(ref: DropListRef<CdkDropList>) {\n    if (this._dir) {\n      this._dir.change\n        .pipe(startWith(this._dir.value), takeUntil(this._destroyed))\n        .subscribe(value => ref.withDirection(value));\n    }\n\n    ref.beforeStarted.subscribe(() => {\n      const siblings = coerceArray(this.connectedTo).map(drop => {\n        if (typeof drop === 'string') {\n          const correspondingDropList = CdkDropList._dropLists.find(list => list.id === drop);\n\n          if (!correspondingDropList && (typeof ngDevMode === 'undefined' || ngDevMode)) {\n            console.warn(`CdkDropList could not find connected drop list with id \"${drop}\"`);\n          }\n\n          return correspondingDropList!;\n        }\n\n        return drop;\n      });\n\n      if (this._group) {\n        this._group._items.forEach(drop => {\n          if (siblings.indexOf(drop) === -1) {\n            siblings.push(drop);\n          }\n        });\n      }\n\n      // Note that we resolve the scrollable parents here so that we delay the resolution\n      // as long as possible, ensuring that the element is in its final place in the DOM.\n      if (!this._scrollableParentsResolved) {\n        const scrollableParents = this._scrollDispatcher\n          .getAncestorScrollContainers(this.element)\n          .map(scrollable => scrollable.getElementRef().nativeElement);\n        this._dropListRef.withScrollableParents(scrollableParents);\n\n        // Only do this once since it involves traversing the DOM and the parents\n        // shouldn't be able to change without the drop list being destroyed.\n        this._scrollableParentsResolved = true;\n      }\n\n      ref.disabled = this.disabled;\n      ref.lockAxis = this.lockAxis;\n      ref.sortingDisabled = this.sortingDisabled;\n      ref.autoScrollDisabled = this.autoScrollDisabled;\n      ref.autoScrollStep = coerceNumberProperty(this.autoScrollStep, 2);\n      ref\n        .connectedTo(siblings.filter(drop => drop && drop !== this).map(list => list._dropListRef))\n        .withOrientation(this.orientation);\n    });\n  }\n\n  /** Handles events from the underlying DropListRef. */\n  private _handleEvents(ref: DropListRef<CdkDropList>) {\n    ref.beforeStarted.subscribe(() => {\n      this._syncItemsWithRef();\n      this._changeDetectorRef.markForCheck();\n    });\n\n    ref.entered.subscribe(event => {\n      this.entered.emit({\n        container: this,\n        item: event.item.data,\n        currentIndex: event.currentIndex,\n      });\n    });\n\n    ref.exited.subscribe(event => {\n      this.exited.emit({\n        container: this,\n        item: event.item.data,\n      });\n      this._changeDetectorRef.markForCheck();\n    });\n\n    ref.sorted.subscribe(event => {\n      this.sorted.emit({\n        previousIndex: event.previousIndex,\n        currentIndex: event.currentIndex,\n        container: this,\n        item: event.item.data,\n      });\n    });\n\n    ref.dropped.subscribe(dropEvent => {\n      this.dropped.emit({\n        previousIndex: dropEvent.previousIndex,\n        currentIndex: dropEvent.currentIndex,\n        previousContainer: dropEvent.previousContainer.data,\n        container: dropEvent.container.data,\n        item: dropEvent.item.data,\n        isPointerOverContainer: dropEvent.isPointerOverContainer,\n        distance: dropEvent.distance,\n        dropPoint: dropEvent.dropPoint,\n        event: dropEvent.event,\n      });\n\n      // Mark for check since all of these events run outside of change\n      // detection and we're not guaranteed for something else to have triggered it.\n      this._changeDetectorRef.markForCheck();\n    });\n\n    merge(ref.receivingStarted, ref.receivingStopped).subscribe(() =>\n      this._changeDetectorRef.markForCheck(),\n    );\n  }\n\n  /** Assigns the default input values based on a provided config object. */\n  private _assignDefaults(config: DragDropConfig) {\n    const {lockAxis, draggingDisabled, sortingDisabled, listAutoScrollDisabled, listOrientation} =\n      config;\n\n    this.disabled = draggingDisabled == null ? false : draggingDisabled;\n    this.sortingDisabled = sortingDisabled == null ? false : sortingDisabled;\n    this.autoScrollDisabled = listAutoScrollDisabled == null ? false : listAutoScrollDisabled;\n    this.orientation = listOrientation || 'vertical';\n\n    if (lockAxis) {\n      this.lockAxis = lockAxis;\n    }\n  }\n\n  /** Syncs up the registered drag items with underlying drop list ref. */\n  private _syncItemsWithRef() {\n    this._dropListRef.withItems(this.getSortedItems().map(item => item._dragRef));\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {NgModule} from '@angular/core';\nimport {CdkScrollableModule} from '@angular/cdk/scrolling';\nimport {CdkDropList} from './directives/drop-list';\nimport {CdkDropListGroup} from './directives/drop-list-group';\nimport {CdkDrag} from './directives/drag';\nimport {CdkDragHandle} from './directives/drag-handle';\nimport {CdkDragPreview} from './directives/drag-preview';\nimport {CdkDragPlaceholder} from './directives/drag-placeholder';\nimport {DragDrop} from './drag-drop';\n\nconst DRAG_DROP_DIRECTIVES = [\n  CdkDropList,\n  CdkDropListGroup,\n  CdkDrag,\n  CdkDragHandle,\n  CdkDragPreview,\n  CdkDragPlaceholder,\n];\n\n@NgModule({\n  imports: DRAG_DROP_DIRECTIVES,\n  exports: [CdkScrollableModule, ...DRAG_DROP_DIRECTIVES],\n  providers: [DragDrop],\n})\nexport class DragDropModule {}\n"],"names":["ComponentRoute","route","target","rt","component","routeDecoratedComponent","isBlank","routeValues","Object","defineProperty","enumerable","configurable","writable","value","push","extractChildrenComponents","childrenComponents","length","routes","extractRoutes","map","children","ModuleRoutes","routedComponents","options","rootModule","staticRoutesAfter","staticRoutesBefore","ngModule","ɵinj","Array","isArray","imports","RouterModule","forRoot","rootModuleConfig","forChild","CDK_DROP_LIST_GROUP","InjectionToken","CdkDropListGroup","constructor","_items","Set","disabled","ngOnDestroy","this","clear","selectors","inputs","booleanAttribute","exportAs","standalone","features","provide","useExisting","_uniqueIdCounter","CdkDropList","_dropLists","_disabled","_group","_dropListRef","element","dragDrop","_changeDetectorRef","_scrollDispatcher","_dir","config","_destroyed","Subject","connectedTo","id","enterPredicate","sortPredicate","dropped","EventEmitter","entered","exited","sorted","_unsortedItems","createDropList","data","_assignDefaults","drag","drop","index","_setupInputSyncSubscription","_handleEvents","add","addItem","item","isDragging","_syncItemsWithRef","removeItem","delete","getSortedItems","from","sort","a","b","_dragRef","getVisibleElement","compareDocumentPosition","Node","DOCUMENT_POSITION_FOLLOWING","indexOf","splice","dispose","next","complete","ref","change","pipe","startWith","takeUntil","subscribe","withDirection","beforeStarted","siblings","coerceArray","find","list","forEach","_scrollableParentsResolved","scrollableParents","getAncestorScrollContainers","scrollable","getElementRef","nativeElement","withScrollableParents","lockAxis","sortingDisabled","autoScrollDisabled","autoScrollStep","coerceNumberProperty","filter","withOrientation","orientation","markForCheck","event","emit","container","currentIndex","previousIndex","dropEvent","previousContainer","isPointerOverContainer","distance","dropPoint","merge","receivingStarted","receivingStopped","draggingDisabled","listAutoScrollDisabled","listOrientation","withItems","i0","i1","i2","i3","CDK_DRAG_CONFIG","hostAttrs","hostVars","hostBindings","rf","ctx","outputs","useValue","undefined","CDK_DROP_LIST","CdkDrag","CdkDragHandle","CdkDragPreview","CdkDragPlaceholder","DragDropModule","DragDrop","CdkScrollableModule"],"sourceRoot":""}