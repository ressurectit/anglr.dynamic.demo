{"version":3,"file":"5008.chunk.22115349350a3af6b874.js","mappings":"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","sources":["webpack://ng-universal-demo/../../../../forms/src/modules/formPipes/pipes/asFormControl/asFormControl.pipe.ts","webpack://ng-universal-demo/../../../../src/modules/castPipes/modules/castPipes.module.ts","webpack://ng-universal-demo/../../../../src/cdk/collections/unique-selection-dispatcher.ts","webpack://ng-universal-demo/../../../../src/material/radio/module.ts","webpack://ng-universal-demo/../../../../src/material/radio/radio.ts","webpack://ng-universal-demo/../../src/material/radio/radio.html","webpack://ng-universal-demo/../../../../src/material/radio/radio.html"],"sourcesContent":["import {Inject, Optional, Pipe} from '@angular/core';\nimport {AbstractControl, FormControl} from '@angular/forms';\nimport {Logger, LOGGER} from '@anglr/common';\nimport {isBlank} from '@jscrpt/common';\n\n/**\n * Tries to convert `AbstractControl` to `FormControl`\n */\n@Pipe({name: 'asFormControl'})\nexport class AsFormControlPipe\n{\n    //######################### constructors #########################\n    constructor(@Optional() @Inject(LOGGER) private _logger?: Logger)\n    {\n    }\n\n    //######################### public methods - implementation of PipeTransform #########################\n\n    /**\n     * Allows casting of `AbstractControl` to `FormControl`\n     * @param value - `AbstractControl` to be cast to `FormControl`\n     * @param _valueHash - Parameter that can be used to change value, indicates that pipe input value has changed\n     */\n    public transform<TModel>(value: AbstractControl<TModel>|null|undefined, _valueHash?: any): FormControl<TModel>|null\n    {\n        if(isBlank(value))\n        {\n            return null;\n        }\n\n        if(value instanceof FormControl)\n        {\n            return value as FormControl<TModel>;\n        }\n\n        this._logger?.warn('Failed to cast AbstractControl to FormControl');\n\n        return null;\n    }\n}","import {NgModule} from '@angular/core';\n\nimport {AsHtmlElementPipe, AsNgClassRequiredPipe, AsRequiredTypePipe, CastTypePipe} from '../pipes';\n\n/**\n * Module that holds cast pipes\n */\n@NgModule(\n{\n    declarations:\n    [\n        AsHtmlElementPipe,\n        AsNgClassRequiredPipe,\n        AsRequiredTypePipe,\n        CastTypePipe,\n    ],\n    exports:\n    [\n        AsHtmlElementPipe,\n        AsNgClassRequiredPipe,\n        AsRequiredTypePipe,\n        CastTypePipe,\n    ]\n})\nexport class CastPipesModule\n{\n}","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {Injectable, OnDestroy} from '@angular/core';\n\n// Users of the Dispatcher never need to see this type, but TypeScript requires it to be exported.\nexport type UniqueSelectionDispatcherListener = (id: string, name: string) => void;\n\n/**\n * Class to coordinate unique selection based on name.\n * Intended to be consumed as an Angular service.\n * This service is needed because native radio change events are only fired on the item currently\n * being selected, and we still need to uncheck the previous selection.\n *\n * This service does not *store* any IDs and names because they may change at any time, so it is\n * less error-prone if they are simply passed through when the events occur.\n */\n@Injectable({providedIn: 'root'})\nexport class UniqueSelectionDispatcher implements OnDestroy {\n  private _listeners: UniqueSelectionDispatcherListener[] = [];\n\n  /**\n   * Notify other items that selection for the given name has been set.\n   * @param id ID of the item.\n   * @param name Name of the item.\n   */\n  notify(id: string, name: string) {\n    for (let listener of this._listeners) {\n      listener(id, name);\n    }\n  }\n\n  /**\n   * Listen for future changes to item selection.\n   * @return Function used to deregister listener\n   */\n  listen(listener: UniqueSelectionDispatcherListener): () => void {\n    this._listeners.push(listener);\n    return () => {\n      this._listeners = this._listeners.filter((registered: UniqueSelectionDispatcherListener) => {\n        return listener !== registered;\n      });\n    };\n  }\n\n  ngOnDestroy() {\n    this._listeners = [];\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {CommonModule} from '@angular/common';\nimport {NgModule} from '@angular/core';\nimport {MatCommonModule, MatRippleModule} from '@angular/material/core';\nimport {MatRadioButton, MatRadioGroup} from './radio';\n\n@NgModule({\n  imports: [MatCommonModule, CommonModule, MatRippleModule],\n  exports: [MatCommonModule, MatRadioGroup, MatRadioButton],\n  declarations: [MatRadioGroup, MatRadioButton],\n})\nexport class MatRadioModule {}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {\n  AfterContentInit,\n  AfterViewInit,\n  Attribute,\n  ChangeDetectionStrategy,\n  ChangeDetectorRef,\n  Component,\n  ContentChildren,\n  Directive,\n  DoCheck,\n  ElementRef,\n  EventEmitter,\n  forwardRef,\n  Inject,\n  InjectionToken,\n  Input,\n  OnDestroy,\n  OnInit,\n  Optional,\n  Output,\n  QueryList,\n  ViewChild,\n  ViewEncapsulation,\n} from '@angular/core';\nimport {\n  CanDisableRipple,\n  HasTabIndex,\n  mixinDisableRipple,\n  mixinTabIndex,\n  ThemePalette,\n} from '@angular/material/core';\nimport {FocusMonitor, FocusOrigin} from '@angular/cdk/a11y';\nimport {BooleanInput, coerceBooleanProperty, coerceNumberProperty} from '@angular/cdk/coercion';\nimport {UniqueSelectionDispatcher} from '@angular/cdk/collections';\nimport {ANIMATION_MODULE_TYPE} from '@angular/platform-browser/animations';\nimport {ControlValueAccessor, NG_VALUE_ACCESSOR} from '@angular/forms';\n\n// Increasing integer for generating unique ids for radio components.\nlet nextUniqueId = 0;\n\n/** Change event object emitted by radio button and radio group. */\nexport class MatRadioChange {\n  constructor(\n    /** The radio button that emits the change event. */\n    public source: _MatRadioButtonBase,\n    /** The value of the radio button. */\n    public value: any,\n  ) {}\n}\n\n/**\n * Provider Expression that allows mat-radio-group to register as a ControlValueAccessor. This\n * allows it to support [(ngModel)] and ngControl.\n * @docs-private\n */\nexport const MAT_RADIO_GROUP_CONTROL_VALUE_ACCESSOR: any = {\n  provide: NG_VALUE_ACCESSOR,\n  useExisting: forwardRef(() => MatRadioGroup),\n  multi: true,\n};\n\n/**\n * Injection token that can be used to inject instances of `MatRadioGroup`. It serves as\n * alternative token to the actual `MatRadioGroup` class which could cause unnecessary\n * retention of the class and its component metadata.\n */\nexport const MAT_RADIO_GROUP = new InjectionToken<_MatRadioGroupBase<_MatRadioButtonBase>>(\n  'MatRadioGroup',\n);\n\nexport interface MatRadioDefaultOptions {\n  color: ThemePalette;\n}\n\nexport const MAT_RADIO_DEFAULT_OPTIONS = new InjectionToken<MatRadioDefaultOptions>(\n  'mat-radio-default-options',\n  {\n    providedIn: 'root',\n    factory: MAT_RADIO_DEFAULT_OPTIONS_FACTORY,\n  },\n);\n\nexport function MAT_RADIO_DEFAULT_OPTIONS_FACTORY(): MatRadioDefaultOptions {\n  return {\n    color: 'accent',\n  };\n}\n\n/**\n * Base class with all of the `MatRadioGroup` functionality.\n * @docs-private\n */\n@Directive()\nexport abstract class _MatRadioGroupBase<T extends _MatRadioButtonBase>\n  implements AfterContentInit, ControlValueAccessor\n{\n  /** Selected value for the radio group. */\n  private _value: any = null;\n\n  /** The HTML name attribute applied to radio buttons in this group. */\n  private _name: string = `mat-radio-group-${nextUniqueId++}`;\n\n  /** The currently selected radio button. Should match value. */\n  private _selected: T | null = null;\n\n  /** Whether the `value` has been set to its initial value. */\n  private _isInitialized: boolean = false;\n\n  /** Whether the labels should appear after or before the radio-buttons. Defaults to 'after' */\n  private _labelPosition: 'before' | 'after' = 'after';\n\n  /** Whether the radio group is disabled. */\n  private _disabled: boolean = false;\n\n  /** Whether the radio group is required. */\n  private _required: boolean = false;\n\n  /** The method to be called in order to update ngModel */\n  _controlValueAccessorChangeFn: (value: any) => void = () => {};\n\n  /**\n   * onTouch function registered via registerOnTouch (ControlValueAccessor).\n   * @docs-private\n   */\n  onTouched: () => any = () => {};\n\n  /**\n   * Event emitted when the group value changes.\n   * Change events are only emitted when the value changes due to user interaction with\n   * a radio button (the same behavior as `<input type-\"radio\">`).\n   */\n  @Output() readonly change: EventEmitter<MatRadioChange> = new EventEmitter<MatRadioChange>();\n\n  /** Child radio buttons. */\n  abstract _radios: QueryList<T>;\n\n  /** Theme color for all of the radio buttons in the group. */\n  @Input() color: ThemePalette;\n\n  /** Name of the radio button group. All radio buttons inside this group will use this name. */\n  @Input()\n  get name(): string {\n    return this._name;\n  }\n  set name(value: string) {\n    this._name = value;\n    this._updateRadioButtonNames();\n  }\n\n  /** Whether the labels should appear after or before the radio-buttons. Defaults to 'after' */\n  @Input()\n  get labelPosition(): 'before' | 'after' {\n    return this._labelPosition;\n  }\n  set labelPosition(v) {\n    this._labelPosition = v === 'before' ? 'before' : 'after';\n    this._markRadiosForCheck();\n  }\n\n  /**\n   * Value for the radio-group. Should equal the value of the selected radio button if there is\n   * a corresponding radio button with a matching value. If there is not such a corresponding\n   * radio button, this value persists to be applied in case a new radio button is added with a\n   * matching value.\n   */\n  @Input()\n  get value(): any {\n    return this._value;\n  }\n  set value(newValue: any) {\n    if (this._value !== newValue) {\n      // Set this before proceeding to ensure no circular loop occurs with selection.\n      this._value = newValue;\n\n      this._updateSelectedRadioFromValue();\n      this._checkSelectedRadioButton();\n    }\n  }\n\n  _checkSelectedRadioButton() {\n    if (this._selected && !this._selected.checked) {\n      this._selected.checked = true;\n    }\n  }\n\n  /**\n   * The currently selected radio button. If set to a new radio button, the radio group value\n   * will be updated to match the new selected button.\n   */\n  @Input()\n  get selected() {\n    return this._selected;\n  }\n  set selected(selected: T | null) {\n    this._selected = selected;\n    this.value = selected ? selected.value : null;\n    this._checkSelectedRadioButton();\n  }\n\n  /** Whether the radio group is disabled */\n  @Input()\n  get disabled(): boolean {\n    return this._disabled;\n  }\n  set disabled(value: BooleanInput) {\n    this._disabled = coerceBooleanProperty(value);\n    this._markRadiosForCheck();\n  }\n\n  /** Whether the radio group is required */\n  @Input()\n  get required(): boolean {\n    return this._required;\n  }\n  set required(value: BooleanInput) {\n    this._required = coerceBooleanProperty(value);\n    this._markRadiosForCheck();\n  }\n\n  constructor(private _changeDetector: ChangeDetectorRef) {}\n\n  /**\n   * Initialize properties once content children are available.\n   * This allows us to propagate relevant attributes to associated buttons.\n   */\n  ngAfterContentInit() {\n    // Mark this component as initialized in AfterContentInit because the initial value can\n    // possibly be set by NgModel on MatRadioGroup, and it is possible that the OnInit of the\n    // NgModel occurs *after* the OnInit of the MatRadioGroup.\n    this._isInitialized = true;\n  }\n\n  /**\n   * Mark this group as being \"touched\" (for ngModel). Meant to be called by the contained\n   * radio buttons upon their blur.\n   */\n  _touch() {\n    if (this.onTouched) {\n      this.onTouched();\n    }\n  }\n\n  private _updateRadioButtonNames(): void {\n    if (this._radios) {\n      this._radios.forEach(radio => {\n        radio.name = this.name;\n        radio._markForCheck();\n      });\n    }\n  }\n\n  /** Updates the `selected` radio button from the internal _value state. */\n  private _updateSelectedRadioFromValue(): void {\n    // If the value already matches the selected radio, do nothing.\n    const isAlreadySelected = this._selected !== null && this._selected.value === this._value;\n\n    if (this._radios && !isAlreadySelected) {\n      this._selected = null;\n      this._radios.forEach(radio => {\n        radio.checked = this.value === radio.value;\n        if (radio.checked) {\n          this._selected = radio;\n        }\n      });\n    }\n  }\n\n  /** Dispatch change event with current selection and group value. */\n  _emitChangeEvent(): void {\n    if (this._isInitialized) {\n      this.change.emit(new MatRadioChange(this._selected!, this._value));\n    }\n  }\n\n  _markRadiosForCheck() {\n    if (this._radios) {\n      this._radios.forEach(radio => radio._markForCheck());\n    }\n  }\n\n  /**\n   * Sets the model value. Implemented as part of ControlValueAccessor.\n   * @param value\n   */\n  writeValue(value: any) {\n    this.value = value;\n    this._changeDetector.markForCheck();\n  }\n\n  /**\n   * Registers a callback to be triggered when the model value changes.\n   * Implemented as part of ControlValueAccessor.\n   * @param fn Callback to be registered.\n   */\n  registerOnChange(fn: (value: any) => void) {\n    this._controlValueAccessorChangeFn = fn;\n  }\n\n  /**\n   * Registers a callback to be triggered when the control is touched.\n   * Implemented as part of ControlValueAccessor.\n   * @param fn Callback to be registered.\n   */\n  registerOnTouched(fn: any) {\n    this.onTouched = fn;\n  }\n\n  /**\n   * Sets the disabled state of the control. Implemented as a part of ControlValueAccessor.\n   * @param isDisabled Whether the control should be disabled.\n   */\n  setDisabledState(isDisabled: boolean) {\n    this.disabled = isDisabled;\n    this._changeDetector.markForCheck();\n  }\n}\n\n// Boilerplate for applying mixins to MatRadioButton.\n/** @docs-private */\nabstract class MatRadioButtonBase {\n  // Since the disabled property is manually defined for the MatRadioButton and isn't set up in\n  // the mixin base class. To be able to use the tabindex mixin, a disabled property must be\n  // defined to properly work.\n  abstract disabled: boolean;\n  constructor(public _elementRef: ElementRef) {}\n}\n\nconst _MatRadioButtonMixinBase = mixinDisableRipple(mixinTabIndex(MatRadioButtonBase));\n\n/**\n * Base class with all of the `MatRadioButton` functionality.\n * @docs-private\n */\n@Directive()\nexport abstract class _MatRadioButtonBase\n  extends _MatRadioButtonMixinBase\n  implements OnInit, AfterViewInit, DoCheck, OnDestroy, CanDisableRipple, HasTabIndex\n{\n  private _uniqueId: string = `mat-radio-${++nextUniqueId}`;\n\n  /** The unique ID for the radio button. */\n  @Input() id: string = this._uniqueId;\n\n  /** Analog to HTML 'name' attribute used to group radios for unique selection. */\n  @Input() name: string;\n\n  /** Used to set the 'aria-label' attribute on the underlying input element. */\n  @Input('aria-label') ariaLabel: string;\n\n  /** The 'aria-labelledby' attribute takes precedence as the element's text alternative. */\n  @Input('aria-labelledby') ariaLabelledby: string;\n\n  /** The 'aria-describedby' attribute is read after the element's label and field type. */\n  @Input('aria-describedby') ariaDescribedby: string;\n\n  /** Whether this radio button is checked. */\n  @Input()\n  get checked(): boolean {\n    return this._checked;\n  }\n  set checked(value: BooleanInput) {\n    const newCheckedState = coerceBooleanProperty(value);\n    if (this._checked !== newCheckedState) {\n      this._checked = newCheckedState;\n      if (newCheckedState && this.radioGroup && this.radioGroup.value !== this.value) {\n        this.radioGroup.selected = this;\n      } else if (!newCheckedState && this.radioGroup && this.radioGroup.value === this.value) {\n        // When unchecking the selected radio button, update the selected radio\n        // property on the group.\n        this.radioGroup.selected = null;\n      }\n\n      if (newCheckedState) {\n        // Notify all radio buttons with the same name to un-check.\n        this._radioDispatcher.notify(this.id, this.name);\n      }\n      this._changeDetector.markForCheck();\n    }\n  }\n\n  /** The value of this radio button. */\n  @Input()\n  get value(): any {\n    return this._value;\n  }\n  set value(value: any) {\n    if (this._value !== value) {\n      this._value = value;\n      if (this.radioGroup !== null) {\n        if (!this.checked) {\n          // Update checked when the value changed to match the radio group's value\n          this.checked = this.radioGroup.value === value;\n        }\n        if (this.checked) {\n          this.radioGroup.selected = this;\n        }\n      }\n    }\n  }\n\n  /** Whether the label should appear after or before the radio button. Defaults to 'after' */\n  @Input()\n  get labelPosition(): 'before' | 'after' {\n    return this._labelPosition || (this.radioGroup && this.radioGroup.labelPosition) || 'after';\n  }\n  set labelPosition(value) {\n    this._labelPosition = value;\n  }\n  private _labelPosition: 'before' | 'after';\n\n  /** Whether the radio button is disabled. */\n  @Input()\n  get disabled(): boolean {\n    return this._disabled || (this.radioGroup !== null && this.radioGroup.disabled);\n  }\n  set disabled(value: BooleanInput) {\n    this._setDisabled(coerceBooleanProperty(value));\n  }\n\n  /** Whether the radio button is required. */\n  @Input()\n  get required(): boolean {\n    return this._required || (this.radioGroup && this.radioGroup.required);\n  }\n  set required(value: BooleanInput) {\n    this._required = coerceBooleanProperty(value);\n  }\n\n  /** Theme color of the radio button. */\n  @Input()\n  get color(): ThemePalette {\n    // As per Material design specifications the selection control radio should use the accent color\n    // palette by default. https://material.io/guidelines/components/selection-controls.html\n    return (\n      this._color ||\n      (this.radioGroup && this.radioGroup.color) ||\n      (this._providerOverride && this._providerOverride.color) ||\n      'accent'\n    );\n  }\n  set color(newValue: ThemePalette) {\n    this._color = newValue;\n  }\n  private _color: ThemePalette;\n\n  /**\n   * Event emitted when the checked state of this radio button changes.\n   * Change events are only emitted when the value changes due to user interaction with\n   * the radio button (the same behavior as `<input type-\"radio\">`).\n   */\n  @Output() readonly change: EventEmitter<MatRadioChange> = new EventEmitter<MatRadioChange>();\n\n  /** The parent radio group. May or may not be present. */\n  radioGroup: _MatRadioGroupBase<_MatRadioButtonBase>;\n\n  /** ID of the native input element inside `<mat-radio-button>` */\n  get inputId(): string {\n    return `${this.id || this._uniqueId}-input`;\n  }\n\n  /** Whether this radio is checked. */\n  private _checked: boolean = false;\n\n  /** Whether this radio is disabled. */\n  private _disabled: boolean;\n\n  /** Whether this radio is required. */\n  private _required: boolean;\n\n  /** Value assigned to this radio. */\n  private _value: any = null;\n\n  /** Unregister function for _radioDispatcher */\n  private _removeUniqueSelectionListener: () => void = () => {};\n\n  /** Previous value of the input's tabindex. */\n  private _previousTabIndex: number | undefined;\n\n  /** The native `<input type=radio>` element */\n  @ViewChild('input') _inputElement: ElementRef<HTMLInputElement>;\n\n  /** Whether animations are disabled. */\n  _noopAnimations: boolean;\n\n  constructor(\n    radioGroup: _MatRadioGroupBase<_MatRadioButtonBase>,\n    elementRef: ElementRef,\n    protected _changeDetector: ChangeDetectorRef,\n    private _focusMonitor: FocusMonitor,\n    private _radioDispatcher: UniqueSelectionDispatcher,\n    animationMode?: string,\n    private _providerOverride?: MatRadioDefaultOptions,\n    tabIndex?: string,\n  ) {\n    super(elementRef);\n\n    // Assertions. Ideally these should be stripped out by the compiler.\n    // TODO(jelbourn): Assert that there's no name binding AND a parent radio group.\n    this.radioGroup = radioGroup;\n    this._noopAnimations = animationMode === 'NoopAnimations';\n\n    if (tabIndex) {\n      this.tabIndex = coerceNumberProperty(tabIndex, 0);\n    }\n  }\n\n  /** Focuses the radio button. */\n  focus(options?: FocusOptions, origin?: FocusOrigin): void {\n    if (origin) {\n      this._focusMonitor.focusVia(this._inputElement, origin, options);\n    } else {\n      this._inputElement.nativeElement.focus(options);\n    }\n  }\n\n  /**\n   * Marks the radio button as needing checking for change detection.\n   * This method is exposed because the parent radio group will directly\n   * update bound properties of the radio button.\n   */\n  _markForCheck() {\n    // When group value changes, the button will not be notified. Use `markForCheck` to explicit\n    // update radio button's status\n    this._changeDetector.markForCheck();\n  }\n\n  ngOnInit() {\n    if (this.radioGroup) {\n      // If the radio is inside a radio group, determine if it should be checked\n      this.checked = this.radioGroup.value === this._value;\n\n      if (this.checked) {\n        this.radioGroup.selected = this;\n      }\n\n      // Copy name from parent radio group\n      this.name = this.radioGroup.name;\n    }\n\n    this._removeUniqueSelectionListener = this._radioDispatcher.listen((id, name) => {\n      if (id !== this.id && name === this.name) {\n        this.checked = false;\n      }\n    });\n  }\n\n  ngDoCheck(): void {\n    this._updateTabIndex();\n  }\n\n  ngAfterViewInit() {\n    this._updateTabIndex();\n    this._focusMonitor.monitor(this._elementRef, true).subscribe(focusOrigin => {\n      if (!focusOrigin && this.radioGroup) {\n        this.radioGroup._touch();\n      }\n    });\n  }\n\n  ngOnDestroy() {\n    this._focusMonitor.stopMonitoring(this._elementRef);\n    this._removeUniqueSelectionListener();\n  }\n\n  /** Dispatch change event with current value. */\n  private _emitChangeEvent(): void {\n    this.change.emit(new MatRadioChange(this, this._value));\n  }\n\n  _isRippleDisabled() {\n    return this.disableRipple || this.disabled;\n  }\n\n  _onInputClick(event: Event) {\n    // We have to stop propagation for click events on the visual hidden input element.\n    // By default, when a user clicks on a label element, a generated click event will be\n    // dispatched on the associated input element. Since we are using a label element as our\n    // root container, the click event on the `radio-button` will be executed twice.\n    // The real click event will bubble up, and the generated click event also tries to bubble up.\n    // This will lead to multiple click events.\n    // Preventing bubbling for the second event will solve that issue.\n    event.stopPropagation();\n  }\n\n  /** Triggered when the radio button receives an interaction from the user. */\n  _onInputInteraction(event: Event) {\n    // We always have to stop propagation on the change event.\n    // Otherwise the change event, from the input element, will bubble up and\n    // emit its event object to the `change` output.\n    event.stopPropagation();\n\n    if (!this.checked && !this.disabled) {\n      const groupValueChanged = this.radioGroup && this.value !== this.radioGroup.value;\n      this.checked = true;\n      this._emitChangeEvent();\n\n      if (this.radioGroup) {\n        this.radioGroup._controlValueAccessorChangeFn(this.value);\n        if (groupValueChanged) {\n          this.radioGroup._emitChangeEvent();\n        }\n      }\n    }\n  }\n\n  /** Sets the disabled state and marks for check if a change occurred. */\n  protected _setDisabled(value: boolean) {\n    if (this._disabled !== value) {\n      this._disabled = value;\n      this._changeDetector.markForCheck();\n    }\n  }\n\n  /** Gets the tabindex for the underlying input element. */\n  private _updateTabIndex() {\n    const group = this.radioGroup;\n    let value: number;\n\n    // Implement a roving tabindex if the button is inside a group. For most cases this isn't\n    // necessary, because the browser handles the tab order for inputs inside a group automatically,\n    // but we need an explicitly higher tabindex for the selected button in order for things like\n    // the focus trap to pick it up correctly.\n    if (!group || !group.selected || this.disabled) {\n      value = this.tabIndex;\n    } else {\n      value = group.selected === this ? this.tabIndex : -1;\n    }\n\n    if (value !== this._previousTabIndex) {\n      // We have to set the tabindex directly on the DOM node, because it depends on\n      // the selected state which is prone to \"changed after checked errors\".\n      const input: HTMLInputElement | undefined = this._inputElement?.nativeElement;\n\n      if (input) {\n        input.setAttribute('tabindex', value + '');\n        this._previousTabIndex = value;\n      }\n    }\n  }\n}\n\n/**\n * A group of radio buttons. May contain one or more `<mat-radio-button>` elements.\n */\n@Directive({\n  selector: 'mat-radio-group',\n  exportAs: 'matRadioGroup',\n  providers: [\n    MAT_RADIO_GROUP_CONTROL_VALUE_ACCESSOR,\n    {provide: MAT_RADIO_GROUP, useExisting: MatRadioGroup},\n  ],\n  host: {\n    'role': 'radiogroup',\n    'class': 'mat-mdc-radio-group',\n  },\n})\nexport class MatRadioGroup extends _MatRadioGroupBase<MatRadioButton> {\n  /** Child radio buttons. */\n  @ContentChildren(forwardRef(() => MatRadioButton), {descendants: true})\n  _radios: QueryList<MatRadioButton>;\n}\n\n@Component({\n  selector: 'mat-radio-button',\n  templateUrl: 'radio.html',\n  styleUrls: ['radio.css'],\n  host: {\n    'class': 'mat-mdc-radio-button',\n    '[attr.id]': 'id',\n    '[class.mat-primary]': 'color === \"primary\"',\n    '[class.mat-accent]': 'color === \"accent\"',\n    '[class.mat-warn]': 'color === \"warn\"',\n    '[class.mat-mdc-radio-checked]': 'checked',\n    '[class._mat-animation-noopable]': '_noopAnimations',\n    // Needs to be removed since it causes some a11y issues (see #21266).\n    '[attr.tabindex]': 'null',\n    '[attr.aria-label]': 'null',\n    '[attr.aria-labelledby]': 'null',\n    '[attr.aria-describedby]': 'null',\n    // Note: under normal conditions focus shouldn't land on this element, however it may be\n    // programmatically set, for example inside of a focus trap, in this case we want to forward\n    // the focus to the native element.\n    '(focus)': '_inputElement.nativeElement.focus()',\n  },\n  inputs: ['disableRipple', 'tabIndex'],\n  exportAs: 'matRadioButton',\n  encapsulation: ViewEncapsulation.None,\n  changeDetection: ChangeDetectionStrategy.OnPush,\n})\nexport class MatRadioButton extends _MatRadioButtonBase {\n  constructor(\n    @Optional() @Inject(MAT_RADIO_GROUP) radioGroup: MatRadioGroup,\n    elementRef: ElementRef,\n    _changeDetector: ChangeDetectorRef,\n    _focusMonitor: FocusMonitor,\n    _radioDispatcher: UniqueSelectionDispatcher,\n    @Optional() @Inject(ANIMATION_MODULE_TYPE) animationMode?: string,\n    @Optional()\n    @Inject(MAT_RADIO_DEFAULT_OPTIONS)\n    _providerOverride?: MatRadioDefaultOptions,\n    @Attribute('tabindex') tabIndex?: string,\n  ) {\n    super(\n      radioGroup,\n      elementRef,\n      _changeDetector,\n      _focusMonitor,\n      _radioDispatcher,\n      animationMode,\n      _providerOverride,\n      tabIndex,\n    );\n  }\n}\n",null,"<div class=\"mdc-form-field\" #formField\n     [class.mdc-form-field--align-end]=\"labelPosition == 'before'\">\n  <div class=\"mdc-radio\" [class.mdc-radio--disabled]=\"disabled\">\n    <!-- Render this element first so the input is on top. -->\n    <div class=\"mat-mdc-radio-touch-target\" (click)=\"_onInputInteraction($event)\"></div>\n    <input #input class=\"mdc-radio__native-control\" type=\"radio\"\n           [id]=\"inputId\"\n           [checked]=\"checked\"\n           [disabled]=\"disabled\"\n           [attr.name]=\"name\"\n           [attr.value]=\"value\"\n           [required]=\"required\"\n           [attr.aria-label]=\"ariaLabel\"\n           [attr.aria-labelledby]=\"ariaLabelledby\"\n           [attr.aria-describedby]=\"ariaDescribedby\"\n           (change)=\"_onInputInteraction($event)\">\n    <div class=\"mdc-radio__background\">\n      <div class=\"mdc-radio__outer-circle\"></div>\n      <div class=\"mdc-radio__inner-circle\"></div>\n    </div>\n    <div mat-ripple class=\"mat-radio-ripple mat-mdc-focus-indicator\"\n         [matRippleTrigger]=\"formField\"\n         [matRippleDisabled]=\"_isRippleDisabled()\"\n         [matRippleCentered]=\"true\">\n      <div class=\"mat-ripple-element mat-radio-persistent-ripple\"></div>\n    </div>\n  </div>\n  <label [for]=\"inputId\">\n    <ng-content></ng-content>\n  </label>\n</div>\n"],"names":["AsFormControlPipe","constructor","_logger","transform","value","_valueHash","isBlank","FormControl","this","warn","LOGGER","CastPipesModule","UniqueSelectionDispatcher","_listeners","notify","id","name","listener","listen","push","filter","registered","ngOnDestroy","MatRadioModule","MatCommonModule","CommonModule","MatRippleModule","nextUniqueId","MatRadioChange","source","MAT_RADIO_GROUP_CONTROL_VALUE_ACCESSOR","provide","NG_VALUE_ACCESSOR","useExisting","forwardRef","MatRadioGroup","multi","MAT_RADIO_GROUP","InjectionToken","MAT_RADIO_DEFAULT_OPTIONS","providedIn","factory","color","_MatRadioGroupBase","_name","_updateRadioButtonNames","labelPosition","_labelPosition","v","_markRadiosForCheck","_value","newValue","_updateSelectedRadioFromValue","_checkSelectedRadioButton","_selected","checked","selected","disabled","_disabled","coerceBooleanProperty","required","_required","_changeDetector","_isInitialized","_controlValueAccessorChangeFn","onTouched","change","EventEmitter","ngAfterContentInit","_touch","_radios","forEach","radio","_markForCheck","isAlreadySelected","_emitChangeEvent","emit","writeValue","markForCheck","registerOnChange","fn","registerOnTouched","setDisabledState","isDisabled","_MatRadioButtonMixinBase","mixinDisableRipple","mixinTabIndex","_elementRef","_MatRadioButtonBase","_checked","newCheckedState","radioGroup","_radioDispatcher","_setDisabled","_color","_providerOverride","inputId","_uniqueId","elementRef","_focusMonitor","animationMode","tabIndex","super","_removeUniqueSelectionListener","_noopAnimations","coerceNumberProperty","focus","options","origin","focusVia","_inputElement","nativeElement","ngOnInit","ngDoCheck","_updateTabIndex","ngAfterViewInit","monitor","subscribe","focusOrigin","stopMonitoring","_isRippleDisabled","disableRipple","_onInputClick","event","stopPropagation","_onInputInteraction","groupValueChanged","group","_previousTabIndex","input","setAttribute","MatRadioButton","ANIMATION_MODULE_TYPE","i3"],"sourceRoot":""}