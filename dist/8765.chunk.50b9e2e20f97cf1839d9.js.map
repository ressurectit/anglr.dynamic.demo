{"version":3,"file":"8765.chunk.50b9e2e20f97cf1839d9.js","mappings":"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","sources":["webpack://ng-universal-demo/../../../../packages/core/src/reflection/reflection_capabilities.ts","webpack://ng-universal-demo/../../../../packages/core/src/di/metadata_attr.ts","webpack://ng-universal-demo/../../../../packages/core/src/di/jit/util.ts","webpack://ng-universal-demo/../../../../packages/core/src/render3/jit/util.ts","webpack://ng-universal-demo/../../../../packages/core/src/render3/deps_tracker/deps_tracker.ts","webpack://ng-universal-demo/../../../../packages/core/src/linker/ng_module_registration.ts","webpack://ng-universal-demo/../../../../packages/core/src/render3/features/host_directives_feature.ts","webpack://ng-universal-demo/../../../../packages/core/src/render3/features/copy_definition_feature.ts","webpack://ng-universal-demo/../../../../packages/core/src/render3/instructions/element_validation.ts","webpack://ng-universal-demo/../../../../packages/core/src/defer/interfaces.ts","webpack://ng-universal-demo/../../../../packages/core/src/defer/cleanup.ts","webpack://ng-universal-demo/../../../../packages/core/src/defer/utils.ts","webpack://ng-universal-demo/../../../../packages/core/src/defer/dom_triggers.ts","webpack://ng-universal-demo/../../../../packages/core/src/defer/idle_scheduler.ts","webpack://ng-universal-demo/../../../../packages/core/src/defer/timer_scheduler.ts","webpack://ng-universal-demo/../../../../packages/core/src/defer/instructions.ts","webpack://ng-universal-demo/../../../../packages/core/src/render3/interfaces/i18n.ts","webpack://ng-universal-demo/../../../../packages/core/src/render3/node_manipulation_i18n.ts","webpack://ng-universal-demo/../../../../packages/core/src/render3/i18n/i18n_insert_before_index.ts","webpack://ng-universal-demo/../../../../packages/core/src/render3/i18n/i18n_util.ts","webpack://ng-universal-demo/../../../../packages/core/src/render3/i18n/i18n_apply.ts","webpack://ng-universal-demo/../../../../packages/core/src/render3/instructions/i18n_icu_container_visitor.ts","webpack://ng-universal-demo/../../../../packages/core/src/render3/i18n/i18n_parse.ts","webpack://ng-universal-demo/../../../../packages/core/src/render3/i18n/i18n_postprocess.ts","webpack://ng-universal-demo/../../../../packages/core/src/render3/instructions/i18n.ts","webpack://ng-universal-demo/../../../../packages/core/src/render3/scope.ts","webpack://ng-universal-demo/../../../../packages/core/src/render3/jit/environment.ts","webpack://ng-universal-demo/../../../../packages/core/src/render3/instructions/attribute_interpolation.ts","webpack://ng-universal-demo/../../../../packages/core/src/render3/instructions/style_map_interpolation.ts","webpack://ng-universal-demo/../../../../packages/core/src/render3/instructions/style_prop_interpolation.ts","webpack://ng-universal-demo/../../../../packages/core/src/render3/instructions/component_instance.ts","webpack://ng-universal-demo/../../../../packages/core/src/render3/local_compilation.ts","webpack://ng-universal-demo/../../../../packages/core/src/render3/debug/set_debug_info.ts","webpack://ng-universal-demo/../../../../packages/core/src/sanitization/iframe_attrs_validation.ts","webpack://ng-universal-demo/../../../../packages/core/src/render3/jit/module.ts","webpack://ng-universal-demo/../../../../packages/core/src/render3/jit/directive.ts","webpack://ng-universal-demo/../../../../packages/core/src/render3/jit/pipe.ts","webpack://ng-universal-demo/../../../../packages/core/src/metadata/directives.ts","webpack://ng-universal-demo/../../../../packages/core/src/render3/instructions/class_map_interpolation.ts","webpack://ng-universal-demo/../../../../packages/core/src/render3/instructions/property_interpolation.ts"],"sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {isType, Type} from '../interface/type';\nimport {newArray} from '../util/array_utils';\nimport {ANNOTATIONS, PARAMETERS, PROP_METADATA} from '../util/decorators';\nimport {global} from '../util/global';\n\nimport {PlatformReflectionCapabilities} from './platform_reflection_capabilities';\n\n\n\n/*\n * #########################\n * Attention: These Regular expressions have to hold even if the code is minified!\n * ##########################\n */\n\n/**\n * Regular expression that detects pass-through constructors for ES5 output. This Regex\n * intends to capture the common delegation pattern emitted by TypeScript and Babel. Also\n * it intends to capture the pattern where existing constructors have been downleveled from\n * ES2015 to ES5 using TypeScript w/ downlevel iteration. e.g.\n *\n * ```\n *   function MyClass() {\n *     var _this = _super.apply(this, arguments) || this;\n * ```\n *\n * downleveled to ES5 with `downlevelIteration` for TypeScript < 4.2:\n * ```\n *   function MyClass() {\n *     var _this = _super.apply(this, __spread(arguments)) || this;\n * ```\n *\n * or downleveled to ES5 with `downlevelIteration` for TypeScript >= 4.2:\n * ```\n *   function MyClass() {\n *     var _this = _super.apply(this, __spreadArray([], __read(arguments), false)) || this;\n * ```\n *\n * More details can be found in: https://github.com/angular/angular/issues/38453.\n */\nexport const ES5_DELEGATE_CTOR =\n    /^function\\s+\\S+\\(\\)\\s*{[\\s\\S]+\\.apply\\(this,\\s*(arguments|(?:[^()]+\\(\\[\\],)?[^()]+\\(arguments\\).*)\\)/;\n/** Regular expression that detects ES2015 classes which extend from other classes. */\nexport const ES2015_INHERITED_CLASS = /^class\\s+[A-Za-z\\d$_]*\\s*extends\\s+[^{]+{/;\n/**\n * Regular expression that detects ES2015 classes which extend from other classes and\n * have an explicit constructor defined.\n */\nexport const ES2015_INHERITED_CLASS_WITH_CTOR =\n    /^class\\s+[A-Za-z\\d$_]*\\s*extends\\s+[^{]+{[\\s\\S]*constructor\\s*\\(/;\n/**\n * Regular expression that detects ES2015 classes which extend from other classes\n * and inherit a constructor.\n */\nexport const ES2015_INHERITED_CLASS_WITH_DELEGATE_CTOR =\n    /^class\\s+[A-Za-z\\d$_]*\\s*extends\\s+[^{]+{[\\s\\S]*constructor\\s*\\(\\)\\s*{[^}]*super\\(\\.\\.\\.arguments\\)/;\n\n/**\n * Determine whether a stringified type is a class which delegates its constructor\n * to its parent.\n *\n * This is not trivial since compiled code can actually contain a constructor function\n * even if the original source code did not. For instance, when the child class contains\n * an initialized instance property.\n */\nexport function isDelegateCtor(typeStr: string): boolean {\n  return ES5_DELEGATE_CTOR.test(typeStr) ||\n      ES2015_INHERITED_CLASS_WITH_DELEGATE_CTOR.test(typeStr) ||\n      (ES2015_INHERITED_CLASS.test(typeStr) && !ES2015_INHERITED_CLASS_WITH_CTOR.test(typeStr));\n}\n\nexport class ReflectionCapabilities implements PlatformReflectionCapabilities {\n  private _reflect: any;\n\n  constructor(reflect?: any) {\n    this._reflect = reflect || global['Reflect'];\n  }\n\n  factory<T>(t: Type<T>): (args: any[]) => T {\n    return (...args: any[]) => new t(...args);\n  }\n\n  /** @internal */\n  _zipTypesAndAnnotations(paramTypes: any[], paramAnnotations: any[]): any[][] {\n    let result: any[][];\n\n    if (typeof paramTypes === 'undefined') {\n      result = newArray(paramAnnotations.length);\n    } else {\n      result = newArray(paramTypes.length);\n    }\n\n    for (let i = 0; i < result.length; i++) {\n      // TS outputs Object for parameters without types, while Traceur omits\n      // the annotations. For now we preserve the Traceur behavior to aid\n      // migration, but this can be revisited.\n      if (typeof paramTypes === 'undefined') {\n        result[i] = [];\n      } else if (paramTypes[i] && paramTypes[i] != Object) {\n        result[i] = [paramTypes[i]];\n      } else {\n        result[i] = [];\n      }\n      if (paramAnnotations && paramAnnotations[i] != null) {\n        result[i] = result[i].concat(paramAnnotations[i]);\n      }\n    }\n    return result;\n  }\n\n  private _ownParameters(type: Type<any>, parentCtor: any): any[][]|null {\n    const typeStr = type.toString();\n    // If we have no decorators, we only have function.length as metadata.\n    // In that case, to detect whether a child class declared an own constructor or not,\n    // we need to look inside of that constructor to check whether it is\n    // just calling the parent.\n    // This also helps to work around for https://github.com/Microsoft/TypeScript/issues/12439\n    // that sets 'design:paramtypes' to []\n    // if a class inherits from another class but has no ctor declared itself.\n    if (isDelegateCtor(typeStr)) {\n      return null;\n    }\n\n    // Prefer the direct API.\n    if ((<any>type).parameters && (<any>type).parameters !== parentCtor.parameters) {\n      return (<any>type).parameters;\n    }\n\n    // API of tsickle for lowering decorators to properties on the class.\n    const tsickleCtorParams = (<any>type).ctorParameters;\n    if (tsickleCtorParams && tsickleCtorParams !== parentCtor.ctorParameters) {\n      // Newer tsickle uses a function closure\n      // Retain the non-function case for compatibility with older tsickle\n      const ctorParameters =\n          typeof tsickleCtorParams === 'function' ? tsickleCtorParams() : tsickleCtorParams;\n      const paramTypes = ctorParameters.map((ctorParam: any) => ctorParam && ctorParam.type);\n      const paramAnnotations = ctorParameters.map(\n          (ctorParam: any) =>\n              ctorParam && convertTsickleDecoratorIntoMetadata(ctorParam.decorators));\n      return this._zipTypesAndAnnotations(paramTypes, paramAnnotations);\n    }\n\n    // API for metadata created by invoking the decorators.\n    const paramAnnotations = type.hasOwnProperty(PARAMETERS) && (type as any)[PARAMETERS];\n    const paramTypes = this._reflect && this._reflect.getOwnMetadata &&\n        this._reflect.getOwnMetadata('design:paramtypes', type);\n    if (paramTypes || paramAnnotations) {\n      return this._zipTypesAndAnnotations(paramTypes, paramAnnotations);\n    }\n\n    // If a class has no decorators, at least create metadata\n    // based on function.length.\n    // Note: We know that this is a real constructor as we checked\n    // the content of the constructor above.\n    return newArray<any[]>(type.length);\n  }\n\n  parameters(type: Type<any>): any[][] {\n    // Note: only report metadata if we have at least one class decorator\n    // to stay in sync with the static reflector.\n    if (!isType(type)) {\n      return [];\n    }\n    const parentCtor = getParentCtor(type);\n    let parameters = this._ownParameters(type, parentCtor);\n    if (!parameters && parentCtor !== Object) {\n      parameters = this.parameters(parentCtor);\n    }\n    return parameters || [];\n  }\n\n  private _ownAnnotations(typeOrFunc: Type<any>, parentCtor: any): any[]|null {\n    // Prefer the direct API.\n    if ((<any>typeOrFunc).annotations && (<any>typeOrFunc).annotations !== parentCtor.annotations) {\n      let annotations = (<any>typeOrFunc).annotations;\n      if (typeof annotations === 'function' && annotations.annotations) {\n        annotations = annotations.annotations;\n      }\n      return annotations;\n    }\n\n    // API of tsickle for lowering decorators to properties on the class.\n    if ((<any>typeOrFunc).decorators && (<any>typeOrFunc).decorators !== parentCtor.decorators) {\n      return convertTsickleDecoratorIntoMetadata((<any>typeOrFunc).decorators);\n    }\n\n    // API for metadata created by invoking the decorators.\n    if (typeOrFunc.hasOwnProperty(ANNOTATIONS)) {\n      return (typeOrFunc as any)[ANNOTATIONS];\n    }\n    return null;\n  }\n\n  annotations(typeOrFunc: Type<any>): any[] {\n    if (!isType(typeOrFunc)) {\n      return [];\n    }\n    const parentCtor = getParentCtor(typeOrFunc);\n    const ownAnnotations = this._ownAnnotations(typeOrFunc, parentCtor) || [];\n    const parentAnnotations = parentCtor !== Object ? this.annotations(parentCtor) : [];\n    return parentAnnotations.concat(ownAnnotations);\n  }\n\n  private _ownPropMetadata(typeOrFunc: any, parentCtor: any): {[key: string]: any[]}|null {\n    // Prefer the direct API.\n    if ((<any>typeOrFunc).propMetadata &&\n        (<any>typeOrFunc).propMetadata !== parentCtor.propMetadata) {\n      let propMetadata = (<any>typeOrFunc).propMetadata;\n      if (typeof propMetadata === 'function' && propMetadata.propMetadata) {\n        propMetadata = propMetadata.propMetadata;\n      }\n      return propMetadata;\n    }\n\n    // API of tsickle for lowering decorators to properties on the class.\n    if ((<any>typeOrFunc).propDecorators &&\n        (<any>typeOrFunc).propDecorators !== parentCtor.propDecorators) {\n      const propDecorators = (<any>typeOrFunc).propDecorators;\n      const propMetadata = <{[key: string]: any[]}>{};\n      Object.keys(propDecorators).forEach(prop => {\n        propMetadata[prop] = convertTsickleDecoratorIntoMetadata(propDecorators[prop]);\n      });\n      return propMetadata;\n    }\n\n    // API for metadata created by invoking the decorators.\n    if (typeOrFunc.hasOwnProperty(PROP_METADATA)) {\n      return (typeOrFunc as any)[PROP_METADATA];\n    }\n    return null;\n  }\n\n  propMetadata(typeOrFunc: any): {[key: string]: any[]} {\n    if (!isType(typeOrFunc)) {\n      return {};\n    }\n    const parentCtor = getParentCtor(typeOrFunc);\n    const propMetadata: {[key: string]: any[]} = {};\n    if (parentCtor !== Object) {\n      const parentPropMetadata = this.propMetadata(parentCtor);\n      Object.keys(parentPropMetadata).forEach((propName) => {\n        propMetadata[propName] = parentPropMetadata[propName];\n      });\n    }\n    const ownPropMetadata = this._ownPropMetadata(typeOrFunc, parentCtor);\n    if (ownPropMetadata) {\n      Object.keys(ownPropMetadata).forEach((propName) => {\n        const decorators: any[] = [];\n        if (propMetadata.hasOwnProperty(propName)) {\n          decorators.push(...propMetadata[propName]);\n        }\n        decorators.push(...ownPropMetadata[propName]);\n        propMetadata[propName] = decorators;\n      });\n    }\n    return propMetadata;\n  }\n\n  ownPropMetadata(typeOrFunc: any): {[key: string]: any[]} {\n    if (!isType(typeOrFunc)) {\n      return {};\n    }\n    return this._ownPropMetadata(typeOrFunc, getParentCtor(typeOrFunc)) || {};\n  }\n\n  hasLifecycleHook(type: any, lcProperty: string): boolean {\n    return type instanceof Type && lcProperty in type.prototype;\n  }\n}\n\nfunction convertTsickleDecoratorIntoMetadata(decoratorInvocations: any[]): any[] {\n  if (!decoratorInvocations) {\n    return [];\n  }\n  return decoratorInvocations.map(decoratorInvocation => {\n    const decoratorType = decoratorInvocation.type;\n    const annotationCls = decoratorType.annotationCls;\n    const annotationArgs = decoratorInvocation.args ? decoratorInvocation.args : [];\n    return new annotationCls(...annotationArgs);\n  });\n}\n\nfunction getParentCtor(ctor: Function): Type<any> {\n  const parentProto = ctor.prototype ? Object.getPrototypeOf(ctor.prototype) : null;\n  const parentCtor = parentProto ? parentProto.constructor : null;\n  // Note: We always use `Object` as the null value\n  // to simplify checking later on.\n  return parentCtor || Object;\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {injectAttribute} from '../render3/instructions/di_attr';\nimport {makeParamDecorator} from '../util/decorators';\n\n\n/**\n * Type of the Attribute decorator / constructor function.\n *\n * @publicApi\n */\nexport interface AttributeDecorator {\n  /**\n   * Parameter decorator for a directive constructor that designates\n   * a host-element attribute whose value is injected as a constant string literal.\n   *\n   * @usageNotes\n   *\n   * Suppose we have an `<input>` element and want to know its `type`.\n   *\n   * ```html\n   * <input type=\"text\">\n   * ```\n   *\n   * The following example uses the decorator to inject the string literal `text` in a directive.\n   *\n   * {@example core/ts/metadata/metadata.ts region='attributeMetadata'}\n   *\n   * The following example uses the decorator in a component constructor.\n   *\n   * {@example core/ts/metadata/metadata.ts region='attributeFactory'}\n   *\n   */\n  (name: string): any;\n  new(name: string): Attribute;\n}\n\n/**\n * Type of the Attribute metadata.\n *\n * @publicApi\n */\nexport interface Attribute {\n  /**\n   * The name of the attribute whose value can be injected.\n   */\n  attributeName: string;\n}\n\n/**\n * Attribute decorator and metadata.\n *\n * @Annotation\n * @publicApi\n */\nexport const Attribute: AttributeDecorator = makeParamDecorator(\n    'Attribute',\n    (attributeName?: string) =>\n        ({attributeName, __NG_ELEMENT_ID__: () => injectAttribute(attributeName!)}));\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {R3DependencyMetadataFacade} from '../../compiler/compiler_facade';\nimport {RuntimeError, RuntimeErrorCode} from '../../errors';\nimport {Type} from '../../interface/type';\nimport {ReflectionCapabilities} from '../../reflection/reflection_capabilities';\nimport {Host, Inject, Optional, Self, SkipSelf} from '../metadata';\nimport {Attribute} from '../metadata_attr';\n\nlet _reflect: ReflectionCapabilities|null = null;\n\nexport function getReflect(): ReflectionCapabilities {\n  return (_reflect = _reflect || new ReflectionCapabilities());\n}\n\nexport function reflectDependencies(type: Type<any>): R3DependencyMetadataFacade[] {\n  return convertDependencies(getReflect().parameters(type));\n}\n\nexport function convertDependencies(deps: any[]): R3DependencyMetadataFacade[] {\n  return deps.map(dep => reflectDependency(dep));\n}\n\nfunction reflectDependency(dep: any|any[]): R3DependencyMetadataFacade {\n  const meta: R3DependencyMetadataFacade = {\n    token: null,\n    attribute: null,\n    host: false,\n    optional: false,\n    self: false,\n    skipSelf: false,\n  };\n\n  if (Array.isArray(dep) && dep.length > 0) {\n    for (let j = 0; j < dep.length; j++) {\n      const param = dep[j];\n      if (param === undefined) {\n        // param may be undefined if type of dep is not set by ngtsc\n        continue;\n      }\n\n      const proto = Object.getPrototypeOf(param);\n\n      if (param instanceof Optional || proto.ngMetadataName === 'Optional') {\n        meta.optional = true;\n      } else if (param instanceof SkipSelf || proto.ngMetadataName === 'SkipSelf') {\n        meta.skipSelf = true;\n      } else if (param instanceof Self || proto.ngMetadataName === 'Self') {\n        meta.self = true;\n      } else if (param instanceof Host || proto.ngMetadataName === 'Host') {\n        meta.host = true;\n      } else if (param instanceof Inject) {\n        meta.token = param.token;\n      } else if (param instanceof Attribute) {\n        if (param.attributeName === undefined) {\n          throw new RuntimeError(\n              RuntimeErrorCode.INVALID_INJECTION_TOKEN,\n              ngDevMode && `Attribute name must be defined.`);\n        }\n        meta.attribute = param.attributeName;\n      } else {\n        meta.token = param;\n      }\n    }\n  } else if (dep === undefined || (Array.isArray(dep) && dep.length === 0)) {\n    meta.token = null;\n  } else {\n    meta.token = dep;\n  }\n  return meta;\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {isForwardRef, resolveForwardRef} from '../../di/forward_ref';\nimport {ModuleWithProviders} from '../../di/interface/provider';\nimport {Type} from '../../interface/type';\nimport {NgModuleDef} from '../../metadata/ng_module_def';\nimport {getComponentDef, getDirectiveDef, getNgModuleDef, getPipeDef} from '../definition';\nimport {ComponentType, DirectiveType, PipeType} from '../interfaces/definition';\nimport {stringifyForError} from '../util/stringify_utils';\n\nexport function isModuleWithProviders(value: any): value is ModuleWithProviders<{}> {\n  return (value as {ngModule?: any}).ngModule !== undefined;\n}\n\nexport function isNgModule<T>(value: Type<T>): value is Type<T>&{mod: NgModuleDef<T>} {\n  return !!getNgModuleDef(value);\n}\n\nexport function isPipe<T>(value: Type<T>): value is PipeType<T> {\n  return !!getPipeDef(value);\n}\n\nexport function isDirective<T>(value: Type<T>): value is DirectiveType<T> {\n  return !!getDirectiveDef(value);\n}\n\nexport function isComponent<T>(value: Type<T>): value is ComponentType<T> {\n  return !!getComponentDef(value);\n}\n\nfunction getDependencyTypeForError(type: Type<any>) {\n  if (getComponentDef(type)) return 'component';\n  if (getDirectiveDef(type)) return 'directive';\n  if (getPipeDef(type)) return 'pipe';\n  return 'type';\n}\n\nexport function verifyStandaloneImport(depType: Type<unknown>, importingType: Type<unknown>) {\n  if (isForwardRef(depType)) {\n    depType = resolveForwardRef(depType);\n    if (!depType) {\n      throw new Error(`Expected forwardRef function, imported from \"${\n          stringifyForError(importingType)}\", to return a standalone entity or NgModule but got \"${\n          stringifyForError(depType) || depType}\".`);\n    }\n  }\n\n  if (getNgModuleDef(depType) == null) {\n    const def = getComponentDef(depType) || getDirectiveDef(depType) || getPipeDef(depType);\n    if (def != null) {\n      // if a component, directive or pipe is imported make sure that it is standalone\n      if (!def.standalone) {\n        throw new Error(`The \"${stringifyForError(depType)}\" ${\n            getDependencyTypeForError(depType)}, imported from \"${\n            stringifyForError(\n                importingType)}\", is not standalone. Did you forget to add the standalone: true flag?`);\n      }\n    } else {\n      // it can be either a module with provider or an unknown (not annotated) type\n      if (isModuleWithProviders(depType)) {\n        throw new Error(`A module with providers was imported from \"${\n            stringifyForError(\n                importingType)}\". Modules with providers are not supported in standalone components imports.`);\n      } else {\n        throw new Error(`The \"${stringifyForError(depType)}\" type, imported from \"${\n            stringifyForError(\n                importingType)}\", must be a standalone component / directive / pipe or an NgModule. Did you forget to add the required @Component / @Directive / @Pipe or @NgModule annotation?`);\n      }\n    }\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {resolveForwardRef} from '../../di';\nimport {RuntimeError, RuntimeErrorCode} from '../../errors';\nimport {Type} from '../../interface/type';\nimport {NgModuleType} from '../../metadata/ng_module_def';\nimport {flatten} from '../../util/array_utils';\nimport {getComponentDef, getNgModuleDef, isStandalone} from '../definition';\nimport {ComponentType, NgModuleScopeInfoFromDecorator, RawScopeInfoFromDecorator} from '../interfaces/definition';\nimport {isComponent, isDirective, isNgModule, isPipe, verifyStandaloneImport} from '../jit/util';\nimport {maybeUnwrapFn} from '../util/misc_utils';\n\nimport {ComponentDependencies, DepsTrackerApi, NgModuleScope, StandaloneComponentScope} from './api';\n\n/**\n * Indicates whether to use the runtime dependency tracker for scope calculation in JIT compilation.\n * The value \"false\" means the old code path based on patching scope info into the types will be\n * used.\n *\n * @deprecated For migration purposes only, to be removed soon.\n */\nexport const USE_RUNTIME_DEPS_TRACKER_FOR_JIT = true;\n\n/**\n * An implementation of DepsTrackerApi which will be used for JIT and local compilation.\n */\nclass DepsTracker implements DepsTrackerApi {\n  private ownerNgModule = new Map<ComponentType<any>, NgModuleType<any>>();\n  private ngModulesWithSomeUnresolvedDecls = new Set<NgModuleType<any>>();\n  private ngModulesScopeCache = new Map<NgModuleType<any>, NgModuleScope>();\n  private standaloneComponentsScopeCache = new Map<ComponentType<any>, StandaloneComponentScope>();\n\n  /**\n   * Attempts to resolve ng module's forward ref declarations as much as possible and add them to\n   * the `ownerNgModule` map. This method normally should be called after the initial parsing when\n   * all the forward refs are resolved (e.g., when trying to render a component)\n   */\n  private resolveNgModulesDecls(): void {\n    if (this.ngModulesWithSomeUnresolvedDecls.size === 0) {\n      return;\n    }\n\n    for (const moduleType of this.ngModulesWithSomeUnresolvedDecls) {\n      const def = getNgModuleDef(moduleType);\n      if (def?.declarations) {\n        for (const decl of maybeUnwrapFn(def.declarations)) {\n          if (isComponent(decl)) {\n            this.ownerNgModule.set(decl, moduleType);\n          }\n        }\n      }\n    }\n\n    this.ngModulesWithSomeUnresolvedDecls.clear();\n  }\n\n  /** @override */\n  getComponentDependencies(type: ComponentType<any>, rawImports?: RawScopeInfoFromDecorator[]):\n      ComponentDependencies {\n    this.resolveNgModulesDecls();\n\n    const def = getComponentDef(type);\n    if (def === null) {\n      throw new Error(\n          `Attempting to get component dependencies for a type that is not a component: ${type}`);\n    }\n\n    if (def.standalone) {\n      const scope = this.getStandaloneComponentScope(type, rawImports);\n\n      if (scope.compilation.isPoisoned) {\n        return {dependencies: []};\n      }\n\n      return {\n        dependencies: [\n          ...scope.compilation.directives,\n          ...scope.compilation.pipes,\n          ...scope.compilation.ngModules,\n        ]\n      };\n    } else {\n      if (!this.ownerNgModule.has(type)) {\n        // This component is orphan! No need to handle the error since the component rendering\n        // pipeline (e.g., view_container_ref) will check for this error based on configs.\n        return {dependencies: []};\n      }\n\n      const scope = this.getNgModuleScope(this.ownerNgModule.get(type)!);\n\n      if (scope.compilation.isPoisoned) {\n        return {dependencies: []};\n      }\n\n      return {\n        dependencies: [\n          ...scope.compilation.directives,\n          ...scope.compilation.pipes,\n        ],\n      };\n    }\n  }\n\n  /**\n   * @override\n   * This implementation does not make use of param scopeInfo since it assumes the scope info is\n   * already added to the type itself through methods like {@link setNgModuleScope}\n   */\n  registerNgModule(type: Type<any>, scopeInfo: NgModuleScopeInfoFromDecorator): void {\n    if (!isNgModule(type)) {\n      throw new Error(`Attempting to register a Type which is not NgModule as NgModule: ${type}`);\n    }\n\n    // Lazily process the NgModules later when needed.\n    this.ngModulesWithSomeUnresolvedDecls.add(type);\n  }\n\n  /** @override */\n  clearScopeCacheFor(type: Type<any>): void {\n    this.ngModulesScopeCache.delete(type as NgModuleType);\n    this.standaloneComponentsScopeCache.delete(type as ComponentType<any>);\n  }\n\n  /** @override */\n  getNgModuleScope(type: NgModuleType<any>): NgModuleScope {\n    if (this.ngModulesScopeCache.has(type)) {\n      return this.ngModulesScopeCache.get(type)!;\n    }\n\n    const scope = this.computeNgModuleScope(type);\n    this.ngModulesScopeCache.set(type, scope);\n\n    return scope;\n  }\n\n  /** Compute NgModule scope afresh. */\n  private computeNgModuleScope(type: NgModuleType<any>): NgModuleScope {\n    const def = getNgModuleDef(type, true);\n    const scope: NgModuleScope = {\n      exported: {directives: new Set(), pipes: new Set()},\n      compilation: {directives: new Set(), pipes: new Set()},\n    };\n\n    // Analyzing imports\n    for (const imported of maybeUnwrapFn(def.imports)) {\n      if (isNgModule(imported)) {\n        const importedScope = this.getNgModuleScope(imported);\n\n        // When this module imports another, the imported module's exported directives and pipes\n        // are added to the compilation scope of this module.\n        addSet(importedScope.exported.directives, scope.compilation.directives);\n        addSet(importedScope.exported.pipes, scope.compilation.pipes);\n      } else if (isStandalone(imported)) {\n        if (isDirective(imported) || isComponent(imported)) {\n          scope.compilation.directives.add(imported);\n        } else if (isPipe(imported)) {\n          scope.compilation.pipes.add(imported);\n        } else {\n          // The standalone thing is neither a component nor a directive nor a pipe ... (what?)\n          throw new RuntimeError(\n              RuntimeErrorCode.RUNTIME_DEPS_INVALID_IMPORTED_TYPE,\n              'The standalone imported type is neither a component nor a directive nor a pipe');\n        }\n      } else {\n        // The import is neither a module nor a module-with-providers nor a standalone thing. This\n        // is going to be an error. So we short circuit.\n        scope.compilation.isPoisoned = true;\n        break;\n      }\n    }\n\n    // Analyzing declarations\n    if (!scope.compilation.isPoisoned) {\n      for (const decl of maybeUnwrapFn(def.declarations)) {\n        // Cannot declare another NgModule or a standalone thing\n        if (isNgModule(decl) || isStandalone(decl)) {\n          scope.compilation.isPoisoned = true;\n          break;\n        }\n\n        if (isPipe(decl)) {\n          scope.compilation.pipes.add(decl);\n        } else {\n          // decl is either a directive or a component. The component may not yet have the cmp due\n          // to async compilation.\n          scope.compilation.directives.add(decl);\n        }\n      }\n    }\n\n    // Analyzing exports\n    for (const exported of maybeUnwrapFn(def.exports)) {\n      if (isNgModule(exported)) {\n        // When this module exports another, the exported module's exported directives and pipes\n        // are added to both the compilation and exported scopes of this module.\n        const exportedScope = this.getNgModuleScope(exported);\n\n        // Based on the current logic there is no way to have poisoned exported scope. So no need to\n        // check for it.\n        addSet(exportedScope.exported.directives, scope.exported.directives);\n        addSet(exportedScope.exported.pipes, scope.exported.pipes);\n\n        // Some test toolings which run in JIT mode depend on this behavior that the exported scope\n        // should also be present in the compilation scope, even though AoT does not support this\n        // and it is also in odds with NgModule metadata definitions. Without this some tests in\n        // Google will fail.\n        addSet(exportedScope.exported.directives, scope.compilation.directives);\n        addSet(exportedScope.exported.pipes, scope.compilation.pipes);\n      } else if (isPipe(exported)) {\n        scope.exported.pipes.add(exported);\n      } else {\n        scope.exported.directives.add(exported);\n      }\n    }\n\n    return scope;\n  }\n\n  /** @override */\n  getStandaloneComponentScope(type: ComponentType<any>, rawImports?: RawScopeInfoFromDecorator[]):\n      StandaloneComponentScope {\n    if (this.standaloneComponentsScopeCache.has(type)) {\n      return this.standaloneComponentsScopeCache.get(type)!;\n    }\n\n    const ans = this.computeStandaloneComponentScope(type, rawImports);\n    this.standaloneComponentsScopeCache.set(type, ans);\n\n    return ans;\n  }\n\n  private computeStandaloneComponentScope(\n      type: ComponentType<any>,\n      rawImports?: RawScopeInfoFromDecorator[]): StandaloneComponentScope {\n    const ans: StandaloneComponentScope = {\n      compilation: {\n        // Standalone components are always able to self-reference.\n        directives: new Set([type]),\n        pipes: new Set(),\n        ngModules: new Set(),\n      },\n    };\n\n    for (const rawImport of flatten(rawImports ?? [])) {\n      const imported = resolveForwardRef(rawImport) as Type<any>;\n\n      try {\n        verifyStandaloneImport(imported, type);\n      } catch (e) {\n        // Short-circuit if an import is not valid\n        ans.compilation.isPoisoned = true;\n        return ans;\n      }\n\n      if (isNgModule(imported)) {\n        ans.compilation.ngModules.add(imported);\n        const importedScope = this.getNgModuleScope(imported);\n\n        // Short-circuit if an imported NgModule has corrupted exported scope.\n        if (importedScope.exported.isPoisoned) {\n          ans.compilation.isPoisoned = true;\n          return ans;\n        }\n\n        addSet(importedScope.exported.directives, ans.compilation.directives);\n        addSet(importedScope.exported.pipes, ans.compilation.pipes);\n      } else if (isPipe(imported)) {\n        ans.compilation.pipes.add(imported);\n      } else if (isDirective(imported) || isComponent(imported)) {\n        ans.compilation.directives.add(imported);\n      } else {\n        // The imported thing is not module/pipe/directive/component, so we error and short-circuit\n        // here\n        ans.compilation.isPoisoned = true;\n        return ans;\n      }\n    }\n\n    return ans;\n  }\n\n  /** @override */\n  isOrphanComponent(cmp: Type<any>): boolean {\n    const def = getComponentDef(cmp);\n\n    if (!def || def.standalone) {\n      return false;\n    }\n\n    this.resolveNgModulesDecls();\n\n    return !this.ownerNgModule.has(cmp as ComponentType<any>);\n  }\n}\n\nfunction addSet<T>(sourceSet: Set<T>, targetSet: Set<T>): void {\n  for (const m of sourceSet) {\n    targetSet.add(m);\n  }\n}\n\n/** The deps tracker to be used in the current Angular app in dev mode. */\nexport const depsTracker = new DepsTracker();\n\nexport const TEST_ONLY = {DepsTracker};\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n\nimport {Type} from '../interface/type';\nimport {NgModuleType} from '../metadata/ng_module_def';\nimport {getNgModuleDef} from '../render3/definition';\nimport {stringify} from '../util/stringify';\n\n/**\n * Map of module-id to the corresponding NgModule.\n */\nconst modules = new Map<string, NgModuleType>();\n\n/**\n * Whether to check for duplicate NgModule registrations.\n *\n * This can be disabled for testing.\n */\nlet checkForDuplicateNgModules = true;\n\nfunction assertSameOrNotExisting(id: string, type: Type<any>|null, incoming: Type<any>): void {\n  if (type && type !== incoming && checkForDuplicateNgModules) {\n    throw new Error(\n        `Duplicate module registered for ${id} - ${stringify(type)} vs ${stringify(type.name)}`);\n  }\n}\n\n/**\n * Adds the given NgModule type to Angular's NgModule registry.\n *\n * This is generated as a side-effect of NgModule compilation. Note that the `id` is passed in\n * explicitly and not read from the NgModule definition. This is for two reasons: it avoids a\n * megamorphic read, and in JIT there's a chicken-and-egg problem where the NgModule may not be\n * fully resolved when it's registered.\n *\n * @codeGenApi\n */\nexport function registerNgModuleType(ngModuleType: NgModuleType, id: string): void {\n  const existing = modules.get(id) || null;\n  assertSameOrNotExisting(id, existing, ngModuleType);\n  modules.set(id, ngModuleType);\n}\n\nexport function clearModulesForTest(): void {\n  modules.clear();\n}\n\nexport function getRegisteredNgModuleType(id: string): NgModuleType|undefined {\n  return modules.get(id);\n}\n\n/**\n * Control whether the NgModule registration system enforces that each NgModule type registered has\n * a unique id.\n *\n * This is useful for testing as the NgModule registry cannot be properly reset between tests with\n * Angular's current API.\n */\nexport function setAllowDuplicateNgModuleIdsForTest(allowDuplicates: boolean): void {\n  checkForDuplicateNgModules = !allowDuplicates;\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport {resolveForwardRef} from '../../di';\nimport {RuntimeError, RuntimeErrorCode} from '../../errors';\nimport {Type} from '../../interface/type';\nimport {assertEqual} from '../../util/assert';\nimport {EMPTY_OBJ} from '../../util/empty';\nimport {getComponentDef, getDirectiveDef} from '../definition';\nimport {DirectiveDef, HostDirectiveBindingMap, HostDirectiveDef, HostDirectiveDefs} from '../interfaces/definition';\n\n/** Values that can be used to define a host directive through the `HostDirectivesFeature`. */\ntype HostDirectiveConfig = Type<unknown>|{\n  directive: Type<unknown>;\n  inputs?: string[];\n  outputs?: string[];\n};\n\n/**\n * This feature adds the host directives behavior to a directive definition by patching a\n * function onto it. The expectation is that the runtime will invoke the function during\n * directive matching.\n *\n * For example:\n * ```ts\n * class ComponentWithHostDirective {\n *   static cmp = defineComponent({\n *    type: ComponentWithHostDirective,\n *    features: [HostDirectivesFeature([\n *      SimpleHostDirective,\n *      {directive: AdvancedHostDirective, inputs: ['foo: alias'], outputs: ['bar']},\n *    ])]\n *  });\n * }\n * ```\n *\n * @codeGenApi\n */\nexport function HostDirectivesFeature(rawHostDirectives: HostDirectiveConfig[]|\n                                        (() => HostDirectiveConfig[])) {\n  return (definition: DirectiveDef<unknown>) => {\n    definition.findHostDirectiveDefs = findHostDirectiveDefs;\n    definition.hostDirectives =\n        (Array.isArray(rawHostDirectives) ? rawHostDirectives : rawHostDirectives()).map(dir => {\n          return typeof dir === 'function' ?\n              {directive: resolveForwardRef(dir), inputs: EMPTY_OBJ, outputs: EMPTY_OBJ} :\n              {\n                directive: resolveForwardRef(dir.directive),\n                inputs: bindingArrayToMap(dir.inputs),\n                outputs: bindingArrayToMap(dir.outputs)\n              };\n        });\n  };\n}\n\nfunction findHostDirectiveDefs(\n    currentDef: DirectiveDef<unknown>, matchedDefs: DirectiveDef<unknown>[],\n    hostDirectiveDefs: HostDirectiveDefs): void {\n  if (currentDef.hostDirectives !== null) {\n    for (const hostDirectiveConfig of currentDef.hostDirectives) {\n      const hostDirectiveDef = getDirectiveDef(hostDirectiveConfig.directive)!;\n\n      if (typeof ngDevMode === 'undefined' || ngDevMode) {\n        validateHostDirective(hostDirectiveConfig, hostDirectiveDef);\n      }\n\n      // We need to patch the `declaredInputs` so that\n      // `ngOnChanges` can map the properties correctly.\n      patchDeclaredInputs(hostDirectiveDef.declaredInputs, hostDirectiveConfig.inputs);\n\n      // Host directives execute before the host so that its host bindings can be overwritten.\n      findHostDirectiveDefs(hostDirectiveDef, matchedDefs, hostDirectiveDefs);\n      hostDirectiveDefs.set(hostDirectiveDef, hostDirectiveConfig);\n      matchedDefs.push(hostDirectiveDef);\n    }\n  }\n}\n\n/**\n * Converts an array in the form of `['publicName', 'alias', 'otherPublicName', 'otherAlias']` into\n * a map in the form of `{publicName: 'alias', otherPublicName: 'otherAlias'}`.\n */\nfunction bindingArrayToMap(bindings: string[]|undefined): HostDirectiveBindingMap {\n  if (bindings === undefined || bindings.length === 0) {\n    return EMPTY_OBJ;\n  }\n\n  const result: HostDirectiveBindingMap = {};\n\n  for (let i = 0; i < bindings.length; i += 2) {\n    result[bindings[i]] = bindings[i + 1];\n  }\n\n  return result;\n}\n\n/**\n * `ngOnChanges` has some leftover legacy ViewEngine behavior where the keys inside the\n * `SimpleChanges` event refer to the *declared* name of the input, not its public name or its\n * minified name. E.g. in `@Input('alias') foo: string`, the name in the `SimpleChanges` object\n * will always be `foo`, and not `alias` or the minified name of `foo` in apps using property\n * minification.\n *\n * This is achieved through the `DirectiveDef.declaredInputs` map that is constructed when the\n * definition is declared. When a property is written to the directive instance, the\n * `NgOnChangesFeature` will try to remap the property name being written to using the\n * `declaredInputs`.\n *\n * Since the host directive input remapping happens during directive matching, `declaredInputs`\n * won't contain the new alias that the input is available under. This function addresses the\n * issue by patching the host directive aliases to the `declaredInputs`. There is *not* a risk of\n * this patching accidentally introducing new inputs to the host directive, because `declaredInputs`\n * is used *only* by the `NgOnChangesFeature` when determining what name is used in the\n * `SimpleChanges` object which won't be reached if an input doesn't exist.\n */\nfunction patchDeclaredInputs(\n    declaredInputs: Record<string, string>, exposedInputs: HostDirectiveBindingMap): void {\n  for (const publicName in exposedInputs) {\n    if (exposedInputs.hasOwnProperty(publicName)) {\n      const remappedPublicName = exposedInputs[publicName];\n      const privateName = declaredInputs[publicName];\n\n      // We *technically* shouldn't be able to hit this case because we can't have multiple\n      // inputs on the same property and we have validations against conflicting aliases in\n      // `validateMappings`. If we somehow did, it would lead to `ngOnChanges` being invoked\n      // with the wrong name so we have a non-user-friendly assertion here just in case.\n      if ((typeof ngDevMode === 'undefined' || ngDevMode) &&\n          declaredInputs.hasOwnProperty(remappedPublicName)) {\n        assertEqual(\n            declaredInputs[remappedPublicName], declaredInputs[publicName],\n            `Conflicting host directive input alias ${publicName}.`);\n      }\n\n      declaredInputs[remappedPublicName] = privateName;\n    }\n  }\n}\n\n/**\n * Verifies that the host directive has been configured correctly.\n * @param hostDirectiveConfig Host directive configuration object.\n * @param directiveDef Directive definition of the host directive.\n */\nfunction validateHostDirective(\n    hostDirectiveConfig: HostDirectiveDef<unknown>,\n    directiveDef: DirectiveDef<any>|null): asserts directiveDef is DirectiveDef<unknown> {\n  const type = hostDirectiveConfig.directive;\n\n  if (directiveDef === null) {\n    if (getComponentDef(type) !== null) {\n      throw new RuntimeError(\n          RuntimeErrorCode.HOST_DIRECTIVE_COMPONENT,\n          `Host directive ${type.name} cannot be a component.`);\n    }\n\n    throw new RuntimeError(\n        RuntimeErrorCode.HOST_DIRECTIVE_UNRESOLVABLE,\n        `Could not resolve metadata for host directive ${type.name}. ` +\n            `Make sure that the ${type.name} class is annotated with an @Directive decorator.`);\n  }\n\n  if (!directiveDef.standalone) {\n    throw new RuntimeError(\n        RuntimeErrorCode.HOST_DIRECTIVE_NOT_STANDALONE,\n        `Host directive ${directiveDef.type.name} must be standalone.`);\n  }\n\n  validateMappings('input', directiveDef, hostDirectiveConfig.inputs);\n  validateMappings('output', directiveDef, hostDirectiveConfig.outputs);\n}\n\n/**\n * Checks that the host directive inputs/outputs configuration is valid.\n * @param bindingType Kind of binding that is being validated. Used in the error message.\n * @param def Definition of the host directive that is being validated against.\n * @param hostDirectiveBindings Host directive mapping object that shold be validated.\n */\nfunction validateMappings(\n    bindingType: 'input'|'output', def: DirectiveDef<unknown>,\n    hostDirectiveBindings: HostDirectiveBindingMap) {\n  const className = def.type.name;\n  const bindings: Record<string, string> = bindingType === 'input' ? def.inputs : def.outputs;\n\n  for (const publicName in hostDirectiveBindings) {\n    if (hostDirectiveBindings.hasOwnProperty(publicName)) {\n      if (!bindings.hasOwnProperty(publicName)) {\n        throw new RuntimeError(\n            RuntimeErrorCode.HOST_DIRECTIVE_UNDEFINED_BINDING,\n            `Directive ${className} does not have an ${bindingType} with a public name of ${\n                publicName}.`);\n      }\n\n      const remappedPublicName = hostDirectiveBindings[publicName];\n\n      if (bindings.hasOwnProperty(remappedPublicName) && remappedPublicName !== publicName &&\n          bindings[remappedPublicName] !== publicName) {\n        throw new RuntimeError(\n            RuntimeErrorCode.HOST_DIRECTIVE_CONFLICTING_ALIAS,\n            `Cannot alias ${bindingType} ${publicName} of host directive ${className} to ${\n                remappedPublicName}, because it already has a different ${\n                bindingType} with the same public name.`);\n      }\n    }\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {ComponentDef, DirectiveDef} from '../interfaces/definition';\nimport {isComponentDef} from '../interfaces/type_checks';\n\nimport {getSuperType} from './inherit_definition_feature';\n\n/**\n * Fields which exist on either directive or component definitions, and need to be copied from\n * parent to child classes by the `CopyDefinitionFeature`.\n */\nconst COPY_DIRECTIVE_FIELDS: (keyof DirectiveDef<unknown>)[] = [\n  // The child class should use the providers of its parent.\n  'providersResolver',\n\n  // Not listed here are any fields which are handled by the `InheritDefinitionFeature`, such\n  // as inputs, outputs, and host binding functions.\n];\n\n/**\n * Fields which exist only on component definitions, and need to be copied from parent to child\n * classes by the `CopyDefinitionFeature`.\n *\n * The type here allows any field of `ComponentDef` which is not also a property of `DirectiveDef`,\n * since those should go in `COPY_DIRECTIVE_FIELDS` above.\n */\nconst COPY_COMPONENT_FIELDS: Exclude<keyof ComponentDef<unknown>, keyof DirectiveDef<unknown>>[] = [\n  // The child class should use the template function of its parent, including all template\n  // semantics.\n  'template',\n  'decls',\n  'consts',\n  'vars',\n  'onPush',\n  'ngContentSelectors',\n\n  // The child class should use the CSS styles of its parent, including all styling semantics.\n  'styles',\n  'encapsulation',\n\n  // The child class should be checked by the runtime in the same way as its parent.\n  'schemas',\n];\n\n/**\n * Copies the fields not handled by the `InheritDefinitionFeature` from the supertype of a\n * definition.\n *\n * This exists primarily to support ngcc migration of an existing View Engine pattern, where an\n * entire decorator is inherited from a parent to a child class. When ngcc detects this case, it\n * generates a skeleton definition on the child class, and applies this feature.\n *\n * The `CopyDefinitionFeature` then copies any needed fields from the parent class' definition,\n * including things like the component template function.\n *\n * @param definition The definition of a child class which inherits from a parent class with its\n * own definition.\n *\n * @codeGenApi\n */\nexport function CopyDefinitionFeature(definition: DirectiveDef<any>|ComponentDef<any>): void {\n  let superType = getSuperType(definition.type)!;\n\n  let superDef: DirectiveDef<any>|ComponentDef<any>|undefined = undefined;\n  if (isComponentDef(definition)) {\n    // Don't use getComponentDef/getDirectiveDef. This logic relies on inheritance.\n    superDef = superType.cmp!;\n  } else {\n    // Don't use getComponentDef/getDirectiveDef. This logic relies on inheritance.\n    superDef = superType.dir!;\n  }\n\n  // Needed because `definition` fields are readonly.\n  const defAny = (definition as any);\n\n  // Copy over any fields that apply to either directives or components.\n  for (const field of COPY_DIRECTIVE_FIELDS) {\n    defAny[field] = superDef[field];\n  }\n\n  if (isComponentDef(superDef)) {\n    // Copy over any component-specific fields.\n    for (const field of COPY_COMPONENT_FIELDS) {\n      defAny[field] = superDef[field];\n    }\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {formatRuntimeError, RuntimeError, RuntimeErrorCode} from '../../errors';\nimport {Type} from '../../interface/type';\nimport {CUSTOM_ELEMENTS_SCHEMA, NO_ERRORS_SCHEMA, SchemaMetadata} from '../../metadata/schema';\nimport {throwError} from '../../util/assert';\nimport {getComponentDef} from '../definition';\nimport {ComponentDef} from '../interfaces/definition';\nimport {TNodeType} from '../interfaces/node';\nimport {RComment, RElement} from '../interfaces/renderer_dom';\nimport {CONTEXT, DECLARATION_COMPONENT_VIEW, LView} from '../interfaces/view';\nimport {isAnimationProp} from '../util/attrs_utils';\n\nlet shouldThrowErrorOnUnknownElement = false;\n\n/**\n * Sets a strict mode for JIT-compiled components to throw an error on unknown elements,\n * instead of just logging the error.\n * (for AOT-compiled ones this check happens at build time).\n */\nexport function setUnknownElementStrictMode(shouldThrow: boolean) {\n  shouldThrowErrorOnUnknownElement = shouldThrow;\n}\n\n/**\n * Gets the current value of the strict mode.\n */\nexport function getUnknownElementStrictMode() {\n  return shouldThrowErrorOnUnknownElement;\n}\n\nlet shouldThrowErrorOnUnknownProperty = false;\n\n/**\n * Sets a strict mode for JIT-compiled components to throw an error on unknown properties,\n * instead of just logging the error.\n * (for AOT-compiled ones this check happens at build time).\n */\nexport function setUnknownPropertyStrictMode(shouldThrow: boolean) {\n  shouldThrowErrorOnUnknownProperty = shouldThrow;\n}\n\n/**\n * Gets the current value of the strict mode.\n */\nexport function getUnknownPropertyStrictMode() {\n  return shouldThrowErrorOnUnknownProperty;\n}\n\n/**\n * Validates that the element is known at runtime and produces\n * an error if it's not the case.\n * This check is relevant for JIT-compiled components (for AOT-compiled\n * ones this check happens at build time).\n *\n * The element is considered known if either:\n * - it's a known HTML element\n * - it's a known custom element\n * - the element matches any directive\n * - the element is allowed by one of the schemas\n *\n * @param element Element to validate\n * @param lView An `LView` that represents a current component that is being rendered\n * @param tagName Name of the tag to check\n * @param schemas Array of schemas\n * @param hasDirectives Boolean indicating that the element matches any directive\n */\nexport function validateElementIsKnown(\n    element: RElement, lView: LView, tagName: string|null, schemas: SchemaMetadata[]|null,\n    hasDirectives: boolean): void {\n  // If `schemas` is set to `null`, that's an indication that this Component was compiled in AOT\n  // mode where this check happens at compile time. In JIT mode, `schemas` is always present and\n  // defined as an array (as an empty array in case `schemas` field is not defined) and we should\n  // execute the check below.\n  if (schemas === null) return;\n\n  // If the element matches any directive, it's considered as valid.\n  if (!hasDirectives && tagName !== null) {\n    // The element is unknown if it's an instance of HTMLUnknownElement, or it isn't registered\n    // as a custom element. Note that unknown elements with a dash in their name won't be instances\n    // of HTMLUnknownElement in browsers that support web components.\n    const isUnknown =\n        // Note that we can't check for `typeof HTMLUnknownElement === 'function'` because\n        // Domino doesn't expose HTMLUnknownElement globally.\n        (typeof HTMLUnknownElement !== 'undefined' && HTMLUnknownElement &&\n         element instanceof HTMLUnknownElement) ||\n        (typeof customElements !== 'undefined' && tagName.indexOf('-') > -1 &&\n         !customElements.get(tagName));\n\n    if (isUnknown && !matchingSchemas(schemas, tagName)) {\n      const isHostStandalone = isHostComponentStandalone(lView);\n      const templateLocation = getTemplateLocationDetails(lView);\n      const schemas = `'${isHostStandalone ? '@Component' : '@NgModule'}.schemas'`;\n\n      let message = `'${tagName}' is not a known element${templateLocation}:\\n`;\n      message += `1. If '${tagName}' is an Angular component, then verify that it is ${\n          isHostStandalone ? 'included in the \\'@Component.imports\\' of this component' :\n                             'a part of an @NgModule where this component is declared'}.\\n`;\n      if (tagName && tagName.indexOf('-') > -1) {\n        message +=\n            `2. If '${tagName}' is a Web Component then add 'CUSTOM_ELEMENTS_SCHEMA' to the ${\n                schemas} of this component to suppress this message.`;\n      } else {\n        message +=\n            `2. To allow any element add 'NO_ERRORS_SCHEMA' to the ${schemas} of this component.`;\n      }\n      if (shouldThrowErrorOnUnknownElement) {\n        throw new RuntimeError(RuntimeErrorCode.UNKNOWN_ELEMENT, message);\n      } else {\n        console.error(formatRuntimeError(RuntimeErrorCode.UNKNOWN_ELEMENT, message));\n      }\n    }\n  }\n}\n\n/**\n * Validates that the property of the element is known at runtime and returns\n * false if it's not the case.\n * This check is relevant for JIT-compiled components (for AOT-compiled\n * ones this check happens at build time).\n *\n * The property is considered known if either:\n * - it's a known property of the element\n * - the element is allowed by one of the schemas\n * - the property is used for animations\n *\n * @param element Element to validate\n * @param propName Name of the property to check\n * @param tagName Name of the tag hosting the property\n * @param schemas Array of schemas\n */\nexport function isPropertyValid(\n    element: RElement|RComment, propName: string, tagName: string|null,\n    schemas: SchemaMetadata[]|null): boolean {\n  // If `schemas` is set to `null`, that's an indication that this Component was compiled in AOT\n  // mode where this check happens at compile time. In JIT mode, `schemas` is always present and\n  // defined as an array (as an empty array in case `schemas` field is not defined) and we should\n  // execute the check below.\n  if (schemas === null) return true;\n\n  // The property is considered valid if the element matches the schema, it exists on the element,\n  // or it is synthetic.\n  if (matchingSchemas(schemas, tagName) || propName in element || isAnimationProp(propName)) {\n    return true;\n  }\n\n  // Note: `typeof Node` returns 'function' in most browsers, but is undefined with domino.\n  return typeof Node === 'undefined' || Node === null || !(element instanceof Node);\n}\n\n/**\n * Logs or throws an error that a property is not supported on an element.\n *\n * @param propName Name of the invalid property\n * @param tagName Name of the tag hosting the property\n * @param nodeType Type of the node hosting the property\n * @param lView An `LView` that represents a current component\n */\nexport function handleUnknownPropertyError(\n    propName: string, tagName: string|null, nodeType: TNodeType, lView: LView): void {\n  // Special-case a situation when a structural directive is applied to\n  // an `<ng-template>` element, for example: `<ng-template *ngIf=\"true\">`.\n  // In this case the compiler generates the `template` instruction with\n  // the `null` as the tagName. The directive matching logic at runtime relies\n  // on this effect (see `isInlineTemplate`), thus using the 'ng-template' as\n  // a default value of the `tNode.value` is not feasible at this moment.\n  if (!tagName && nodeType === TNodeType.Container) {\n    tagName = 'ng-template';\n  }\n\n  const isHostStandalone = isHostComponentStandalone(lView);\n  const templateLocation = getTemplateLocationDetails(lView);\n\n  let message = `Can't bind to '${propName}' since it isn't a known property of '${tagName}'${\n      templateLocation}.`;\n\n  const schemas = `'${isHostStandalone ? '@Component' : '@NgModule'}.schemas'`;\n  const importLocation = isHostStandalone ?\n      'included in the \\'@Component.imports\\' of this component' :\n      'a part of an @NgModule where this component is declared';\n  if (KNOWN_CONTROL_FLOW_DIRECTIVES.has(propName)) {\n    // Most likely this is a control flow directive (such as `*ngIf`) used in\n    // a template, but the directive or the `CommonModule` is not imported.\n    const correspondingImport = KNOWN_CONTROL_FLOW_DIRECTIVES.get(propName);\n    message += `\\nIf the '${propName}' is an Angular control flow directive, ` +\n        `please make sure that either the '${\n                   correspondingImport}' directive or the 'CommonModule' is ${importLocation}.`;\n  } else {\n    // May be an Angular component, which is not imported/declared?\n    message += `\\n1. If '${tagName}' is an Angular component and it has the ` +\n        `'${propName}' input, then verify that it is ${importLocation}.`;\n    // May be a Web Component?\n    if (tagName && tagName.indexOf('-') > -1) {\n      message += `\\n2. If '${tagName}' is a Web Component then add 'CUSTOM_ELEMENTS_SCHEMA' ` +\n          `to the ${schemas} of this component to suppress this message.`;\n      message += `\\n3. To allow any property add 'NO_ERRORS_SCHEMA' to ` +\n          `the ${schemas} of this component.`;\n    } else {\n      // If it's expected, the error can be suppressed by the `NO_ERRORS_SCHEMA` schema.\n      message += `\\n2. To allow any property add 'NO_ERRORS_SCHEMA' to ` +\n          `the ${schemas} of this component.`;\n    }\n  }\n\n  reportUnknownPropertyError(message);\n}\n\nexport function reportUnknownPropertyError(message: string) {\n  if (shouldThrowErrorOnUnknownProperty) {\n    throw new RuntimeError(RuntimeErrorCode.UNKNOWN_BINDING, message);\n  } else {\n    console.error(formatRuntimeError(RuntimeErrorCode.UNKNOWN_BINDING, message));\n  }\n}\n\n/**\n * WARNING: this is a **dev-mode only** function (thus should always be guarded by the `ngDevMode`)\n * and must **not** be used in production bundles. The function makes megamorphic reads, which might\n * be too slow for production mode and also it relies on the constructor function being available.\n *\n * Gets a reference to the host component def (where a current component is declared).\n *\n * @param lView An `LView` that represents a current component that is being rendered.\n */\nexport function getDeclarationComponentDef(lView: LView): ComponentDef<unknown>|null {\n  !ngDevMode && throwError('Must never be called in production mode');\n\n  const declarationLView = lView[DECLARATION_COMPONENT_VIEW] as LView<Type<unknown>>;\n  const context = declarationLView[CONTEXT];\n\n  // Unable to obtain a context.\n  if (!context) return null;\n\n  return context.constructor ? getComponentDef(context.constructor) : null;\n}\n\n/**\n * WARNING: this is a **dev-mode only** function (thus should always be guarded by the `ngDevMode`)\n * and must **not** be used in production bundles. The function makes megamorphic reads, which might\n * be too slow for production mode.\n *\n * Checks if the current component is declared inside of a standalone component template.\n *\n * @param lView An `LView` that represents a current component that is being rendered.\n */\nexport function isHostComponentStandalone(lView: LView): boolean {\n  !ngDevMode && throwError('Must never be called in production mode');\n\n  const componentDef = getDeclarationComponentDef(lView);\n  // Treat host component as non-standalone if we can't obtain the def.\n  return !!componentDef?.standalone;\n}\n\n/**\n * WARNING: this is a **dev-mode only** function (thus should always be guarded by the `ngDevMode`)\n * and must **not** be used in production bundles. The function makes megamorphic reads, which might\n * be too slow for production mode.\n *\n * Constructs a string describing the location of the host component template. The function is used\n * in dev mode to produce error messages.\n *\n * @param lView An `LView` that represents a current component that is being rendered.\n */\nexport function getTemplateLocationDetails(lView: LView): string {\n  !ngDevMode && throwError('Must never be called in production mode');\n\n  const hostComponentDef = getDeclarationComponentDef(lView);\n  const componentClassName = hostComponentDef?.type?.name;\n  return componentClassName ? ` (used in the '${componentClassName}' component template)` : '';\n}\n\n/**\n * The set of known control flow directives and their corresponding imports.\n * We use this set to produce a more precises error message with a note\n * that the `CommonModule` should also be included.\n */\nexport const KNOWN_CONTROL_FLOW_DIRECTIVES = new Map([\n  ['ngIf', 'NgIf'], ['ngFor', 'NgFor'], ['ngSwitchCase', 'NgSwitchCase'],\n  ['ngSwitchDefault', 'NgSwitchDefault']\n]);\n/**\n * Returns true if the tag name is allowed by specified schemas.\n * @param schemas Array of schemas\n * @param tagName Name of the tag\n */\nexport function matchingSchemas(schemas: SchemaMetadata[]|null, tagName: string|null): boolean {\n  if (schemas !== null) {\n    for (let i = 0; i < schemas.length; i++) {\n      const schema = schemas[i];\n      if (schema === NO_ERRORS_SCHEMA ||\n          schema === CUSTOM_ELEMENTS_SCHEMA && tagName && tagName.indexOf('-') > -1) {\n        return true;\n      }\n    }\n  }\n\n  return false;\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport type {DependencyType} from '../render3/interfaces/definition';\n\n/**\n * Describes the shape of a function generated by the compiler\n * to download dependencies that can be defer-loaded.\n */\nexport type DependencyResolverFn = () => Array<Promise<DependencyType>>;\n\n/**\n * Defines types of defer block triggers.\n */\nexport const enum TriggerType {\n  /**\n   * Represents regular triggers (e.g. `@defer (on idle) { ... }`).\n   */\n  Regular,\n\n  /**\n   * Represents prefetch triggers (e.g. `@defer (prefetch on idle) { ... }`).\n   */\n  Prefetch,\n}\n\n/**\n * Describes the state of defer block dependency loading.\n */\nexport enum DeferDependenciesLoadingState {\n  /** Initial state, dependency loading is not yet triggered */\n  NOT_STARTED,\n\n  /** Dependency loading is in progress */\n  IN_PROGRESS,\n\n  /** Dependency loading has completed successfully */\n  COMPLETE,\n\n  /** Dependency loading has failed */\n  FAILED,\n}\n\n/** Slot index where `minimum` parameter value is stored. */\nexport const MINIMUM_SLOT = 0;\n\n/** Slot index where `after` parameter value is stored. */\nexport const LOADING_AFTER_SLOT = 1;\n\n/** Configuration object for a loading block as it is stored in the component constants. */\nexport type DeferredLoadingBlockConfig = [minimumTime: number|null, afterTime: number|null];\n\n/** Configuration object for a placeholder block as it is stored in the component constants. */\nexport type DeferredPlaceholderBlockConfig = [minimumTime: number|null];\n\n/**\n * Describes the data shared across all instances of a defer block.\n */\nexport interface TDeferBlockDetails {\n  /**\n   * Index in an LView and TData arrays where a template for the primary content\n   * can be found.\n   */\n  primaryTmplIndex: number;\n\n  /**\n   * Index in an LView and TData arrays where a template for the loading block can be found.\n   */\n  loadingTmplIndex: number|null;\n\n  /**\n   * Extra configuration parameters (such as `after` and `minimum`) for the loading block.\n   */\n  loadingBlockConfig: DeferredLoadingBlockConfig|null;\n\n  /**\n   * Index in an LView and TData arrays where a template for the placeholder block can be found.\n   */\n  placeholderTmplIndex: number|null;\n\n  /**\n   * Extra configuration parameters (such as `after` and `minimum`) for the placeholder block.\n   */\n  placeholderBlockConfig: DeferredPlaceholderBlockConfig|null;\n\n  /**\n   * Index in an LView and TData arrays where a template for the error block can be found.\n   */\n  errorTmplIndex: number|null;\n\n  /**\n   * Compiler-generated function that loads all dependencies for a defer block.\n   */\n  dependencyResolverFn: DependencyResolverFn|null;\n\n  /**\n   * Keeps track of the current loading state of defer block dependencies.\n   */\n  loadingState: DeferDependenciesLoadingState;\n\n  /**\n   * Dependency loading Promise. This Promise is helpful for cases when there\n   * are multiple instances of a defer block (e.g. if it was used inside of an *ngFor),\n   * which all await the same set of dependencies.\n   */\n  loadingPromise: Promise<unknown>|null;\n}\n\n/**\n * Describes the current state of this defer block instance.\n *\n * @publicApi\n * @developerPreview\n */\nexport enum DeferBlockState {\n  /** The placeholder block content is rendered */\n  Placeholder = 0,\n\n  /** The loading block content is rendered */\n  Loading = 1,\n\n  /** The main content block content is rendered */\n  Complete = 2,\n\n  /** The error block content is rendered */\n  Error = 3,\n}\n\n/**\n * Describes the initial state of this defer block instance.\n *\n * Note: this state is internal only and *must* be represented\n * with a number lower than any value in the `DeferBlockState` enum.\n */\nexport enum DeferBlockInternalState {\n  /** Initial state. Nothing is rendered yet. */\n  Initial = -1,\n}\n\nexport const NEXT_DEFER_BLOCK_STATE = 0;\n// Note: it's *important* to keep the state in this slot, because this slot\n// is used by runtime logic to differentiate between LViews, LContainers and\n// other types (see `isLView` and `isLContainer` functions). In case of defer\n// blocks, this slot would always be a number.\nexport const DEFER_BLOCK_STATE = 1;\nexport const STATE_IS_FROZEN_UNTIL = 2;\nexport const LOADING_AFTER_CLEANUP_FN = 3;\nexport const TRIGGER_CLEANUP_FNS = 4;\nexport const PREFETCH_TRIGGER_CLEANUP_FNS = 5;\n\n/**\n * Describes instance-specific defer block data.\n *\n * Note: currently there is only the `state` slot, but more slots\n * would be added later to keep track of `after` and `maximum` features\n * (which would require per-instance state).\n */\nexport interface LDeferBlockDetails extends Array<unknown> {\n  /**\n   * Currently rendered block state.\n   */\n  [DEFER_BLOCK_STATE]: DeferBlockState|DeferBlockInternalState;\n\n  /**\n   * Block state that was requested when another state was rendered.\n   */\n  [NEXT_DEFER_BLOCK_STATE]: DeferBlockState|null;\n\n  /**\n   * Timestamp indicating when the current state can be switched to\n   * the next one, in case teh current state has `minimum` parameter.\n   */\n  [STATE_IS_FROZEN_UNTIL]: number|null;\n\n  /**\n   * Contains a reference to a cleanup function which cancels a timeout\n   * when Angular waits before rendering loading state. This is used when\n   * the loading block has the `after` parameter configured.\n   */\n  [LOADING_AFTER_CLEANUP_FN]: VoidFunction|null;\n\n  /**\n   * List of cleanup functions for regular triggers.\n   */\n  [TRIGGER_CLEANUP_FNS]: VoidFunction[]|null;\n\n  /**\n   * List of cleanup functions for prefetch triggers.\n   */\n  [PREFETCH_TRIGGER_CLEANUP_FNS]: VoidFunction[]|null;\n}\n\n/**\n * Internal structure used for configuration of defer block behavior.\n * */\nexport interface DeferBlockConfig {\n  behavior: DeferBlockBehavior;\n}\n\n/**\n * Options for configuring defer blocks behavior.\n * @publicApi\n * @developerPreview\n */\nexport enum DeferBlockBehavior {\n  /**\n   * Manual triggering mode for defer blocks. Provides control over when defer blocks render\n   * and which state they render. This is the default behavior in test environments.\n   */\n  Manual,\n\n  /**\n   * Playthrough mode for defer blocks. This mode behaves like defer blocks would in a browser.\n   */\n  Playthrough,\n}\n\n/**\n * **INTERNAL**, avoid referencing it in application code.\n *\n * Describes a helper class that allows to intercept a call to retrieve current\n * dependency loading function and replace it with a different implementation.\n * This interceptor class is needed to allow testing blocks in different states\n * by simulating loading response.\n */\nexport interface DeferBlockDependencyInterceptor {\n  /**\n   * Invoked for each defer block when dependency loading function is accessed.\n   */\n  intercept(dependencyFn: DependencyResolverFn|null): DependencyResolverFn|null;\n\n  /**\n   * Allows to configure an interceptor function.\n   */\n  setInterceptor(interceptorFn: (current: DependencyResolverFn) => DependencyResolverFn): void;\n}\n","/*!\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {LDeferBlockDetails, PREFETCH_TRIGGER_CLEANUP_FNS, TRIGGER_CLEANUP_FNS, TriggerType} from './interfaces';\n\n/**\n * Registers a cleanup function associated with a prefetching trigger\n * or a regular trigger of a defer block.\n */\nexport function storeTriggerCleanupFn(\n    type: TriggerType, lDetails: LDeferBlockDetails, cleanupFn: VoidFunction) {\n  const key = type === TriggerType.Prefetch ? PREFETCH_TRIGGER_CLEANUP_FNS : TRIGGER_CLEANUP_FNS;\n  if (lDetails[key] === null) {\n    lDetails[key] = [];\n  }\n  lDetails[key]!.push(cleanupFn);\n}\n\n/**\n * Invokes registered cleanup functions either for prefetch or for regular triggers.\n */\nexport function invokeTriggerCleanupFns(type: TriggerType, lDetails: LDeferBlockDetails) {\n  const key = type === TriggerType.Prefetch ? PREFETCH_TRIGGER_CLEANUP_FNS : TRIGGER_CLEANUP_FNS;\n  const cleanupFns = lDetails[key];\n  if (cleanupFns !== null) {\n    for (const cleanupFn of cleanupFns) {\n      cleanupFn();\n    }\n    lDetails[key] = null;\n  }\n}\n\n/**\n * Invokes registered cleanup functions for both prefetch and regular triggers.\n */\nexport function invokeAllTriggerCleanupFns(lDetails: LDeferBlockDetails) {\n  invokeTriggerCleanupFns(TriggerType.Prefetch, lDetails);\n  invokeTriggerCleanupFns(TriggerType.Regular, lDetails);\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {assertIndexInDeclRange} from '../render3/assert';\nimport {DependencyDef} from '../render3/interfaces/definition';\nimport {TContainerNode, TNode} from '../render3/interfaces/node';\nimport {HEADER_OFFSET, LView, TVIEW, TView} from '../render3/interfaces/view';\nimport {getTNode} from '../render3/util/view_utils';\nimport {assertEqual, throwError} from '../util/assert';\n\nimport {DeferBlockState, DeferDependenciesLoadingState, LDeferBlockDetails, LOADING_AFTER_SLOT, MINIMUM_SLOT, TDeferBlockDetails} from './interfaces';\n\n\n/**\n * Calculates a data slot index for defer block info (either static or\n * instance-specific), given an index of a defer instruction.\n */\nexport function getDeferBlockDataIndex(deferBlockIndex: number) {\n  // Instance state is located at the *next* position\n  // after the defer block slot in an LView or TView.data.\n  return deferBlockIndex + 1;\n}\n\n/** Retrieves a defer block state from an LView, given a TNode that represents a block. */\nexport function getLDeferBlockDetails(lView: LView, tNode: TNode): LDeferBlockDetails {\n  const tView = lView[TVIEW];\n  const slotIndex = getDeferBlockDataIndex(tNode.index);\n  ngDevMode && assertIndexInDeclRange(tView, slotIndex);\n  return lView[slotIndex];\n}\n\n/** Stores a defer block instance state in LView. */\nexport function setLDeferBlockDetails(\n    lView: LView, deferBlockIndex: number, lDetails: LDeferBlockDetails) {\n  const tView = lView[TVIEW];\n  const slotIndex = getDeferBlockDataIndex(deferBlockIndex);\n  ngDevMode && assertIndexInDeclRange(tView, slotIndex);\n  lView[slotIndex] = lDetails;\n}\n\n/** Retrieves static info about a defer block, given a TView and a TNode that represents a block. */\nexport function getTDeferBlockDetails(tView: TView, tNode: TNode): TDeferBlockDetails {\n  const slotIndex = getDeferBlockDataIndex(tNode.index);\n  ngDevMode && assertIndexInDeclRange(tView, slotIndex);\n  return tView.data[slotIndex] as TDeferBlockDetails;\n}\n\n/** Stores a defer block static info in `TView.data`. */\nexport function setTDeferBlockDetails(\n    tView: TView, deferBlockIndex: number, deferBlockConfig: TDeferBlockDetails) {\n  const slotIndex = getDeferBlockDataIndex(deferBlockIndex);\n  ngDevMode && assertIndexInDeclRange(tView, slotIndex);\n  tView.data[slotIndex] = deferBlockConfig;\n}\n\nexport function getTemplateIndexForState(\n    newState: DeferBlockState, hostLView: LView, tNode: TNode): number|null {\n  const tView = hostLView[TVIEW];\n  const tDetails = getTDeferBlockDetails(tView, tNode);\n\n  switch (newState) {\n    case DeferBlockState.Complete:\n      return tDetails.primaryTmplIndex;\n    case DeferBlockState.Loading:\n      return tDetails.loadingTmplIndex;\n    case DeferBlockState.Error:\n      return tDetails.errorTmplIndex;\n    case DeferBlockState.Placeholder:\n      return tDetails.placeholderTmplIndex;\n    default:\n      ngDevMode && throwError(`Unexpected defer block state: ${newState}`);\n      return null;\n  }\n}\n\n/**\n * Returns a minimum amount of time that a given state should be rendered for,\n * taking into account `minimum` parameter value. If the `minimum` value is\n * not specified - returns `null`.\n */\nexport function getMinimumDurationForState(\n    tDetails: TDeferBlockDetails, currentState: DeferBlockState): number|null {\n  if (currentState === DeferBlockState.Placeholder) {\n    return tDetails.placeholderBlockConfig?.[MINIMUM_SLOT] ?? null;\n  } else if (currentState === DeferBlockState.Loading) {\n    return tDetails.loadingBlockConfig?.[MINIMUM_SLOT] ?? null;\n  }\n  return null;\n}\n\n/** Retrieves the value of the `after` parameter on the @loading block. */\nexport function getLoadingBlockAfter(tDetails: TDeferBlockDetails): number|null {\n  return tDetails.loadingBlockConfig?.[LOADING_AFTER_SLOT] ?? null;\n}\n\n/**\n * Adds downloaded dependencies into a directive or a pipe registry,\n * making sure that a dependency doesn't yet exist in the registry.\n */\nexport function addDepsToRegistry<T extends DependencyDef[]>(currentDeps: T|null, newDeps: T): T {\n  if (!currentDeps || currentDeps.length === 0) {\n    return newDeps;\n  }\n\n  const currentDepSet = new Set(currentDeps);\n  for (const dep of newDeps) {\n    currentDepSet.add(dep);\n  }\n\n  // If `currentDeps` is the same length, there were no new deps and can\n  // return the original array.\n  return (currentDeps.length === currentDepSet.size) ? currentDeps : Array.from(currentDepSet) as T;\n}\n\n/** Retrieves a TNode that represents main content of a defer block. */\nexport function getPrimaryBlockTNode(tView: TView, tDetails: TDeferBlockDetails): TContainerNode {\n  const adjustedIndex = tDetails.primaryTmplIndex + HEADER_OFFSET;\n  return getTNode(tView, adjustedIndex) as TContainerNode;\n}\n\n/**\n * Asserts whether all dependencies for a defer block are loaded.\n * Always run this function (in dev mode) before rendering a defer\n * block in completed state.\n */\nexport function assertDeferredDependenciesLoaded(tDetails: TDeferBlockDetails) {\n  assertEqual(\n      tDetails.loadingState, DeferDependenciesLoadingState.COMPLETE,\n      'Expecting all deferred dependencies to be loaded.');\n}\n\n/**\n * Determines if a given value matches the expected structure of a defer block\n *\n * We can safely rely on the primaryTmplIndex because every defer block requires\n * that a primary template exists. All the other template options are optional.\n */\nexport function isTDeferBlockDetails(value: unknown): value is TDeferBlockDetails {\n  return value !== null && (typeof value === 'object') &&\n      (typeof (value as TDeferBlockDetails).primaryTmplIndex === 'number');\n}\n","/*!\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport type {Injector} from '../di';\nimport {internalAfterNextRender} from '../render3/after_render_hooks';\nimport {assertLContainer, assertLView} from '../render3/assert';\nimport {CONTAINER_HEADER_OFFSET} from '../render3/interfaces/container';\nimport {TNode} from '../render3/interfaces/node';\nimport {isDestroyed} from '../render3/interfaces/type_checks';\nimport {HEADER_OFFSET, INJECTOR, LView} from '../render3/interfaces/view';\nimport {getNativeByIndex, removeLViewOnDestroy, storeLViewOnDestroy, walkUpViews} from '../render3/util/view_utils';\nimport {assertElement, assertEqual} from '../util/assert';\nimport {NgZone} from '../zone';\nimport {storeTriggerCleanupFn} from './cleanup';\n\nimport {DEFER_BLOCK_STATE, DeferBlockInternalState, DeferBlockState, TriggerType} from './interfaces';\nimport {getLDeferBlockDetails} from './utils';\n\n/** Configuration object used to register passive and capturing events. */\nconst eventListenerOptions: AddEventListenerOptions = {\n  passive: true,\n  capture: true\n};\n\n/** Keeps track of the currently-registered `on hover` triggers. */\nconst hoverTriggers = new WeakMap<Element, DeferEventEntry>();\n\n/** Keeps track of the currently-registered `on interaction` triggers. */\nconst interactionTriggers = new WeakMap<Element, DeferEventEntry>();\n\n/** Currently-registered `viewport` triggers. */\nconst viewportTriggers = new WeakMap<Element, DeferEventEntry>();\n\n/** Names of the events considered as interaction events. */\nconst interactionEventNames = ['click', 'keydown'] as const;\n\n/** Names of the events considered as hover events. */\nconst hoverEventNames = ['mouseenter', 'focusin'] as const;\n\n/** `IntersectionObserver` used to observe `viewport` triggers. */\nlet intersectionObserver: IntersectionObserver|null = null;\n\n/** Number of elements currently observed with `viewport` triggers. */\nlet observedViewportElements = 0;\n\n/** Object keeping track of registered callbacks for a deferred block trigger. */\nclass DeferEventEntry {\n  callbacks = new Set<VoidFunction>();\n\n  listener = () => {\n    for (const callback of this.callbacks) {\n      callback();\n    }\n  }\n}\n\n/**\n * Registers an interaction trigger.\n * @param trigger Element that is the trigger.\n * @param callback Callback to be invoked when the trigger is interacted with.\n */\nexport function onInteraction(trigger: Element, callback: VoidFunction): VoidFunction {\n  let entry = interactionTriggers.get(trigger);\n\n  // If this is the first entry for this element, add the listeners.\n  if (!entry) {\n    // Note that managing events centrally like this lends itself well to using global\n    // event delegation. It currently does delegation at the element level, rather than the\n    // document level, because:\n    // 1. Global delegation is the most effective when there are a lot of events being registered\n    // at the same time. Deferred blocks are unlikely to be used in such a way.\n    // 2. Matching events to their target isn't free. For each `click` and `keydown` event we\n    // would have look through all the triggers and check if the target either is the element\n    // itself or it's contained within the element. Given that `click` and `keydown` are some\n    // of the most common events, this may end up introducing a lot of runtime overhead.\n    // 3. We're still registering only two events per element, no matter how many deferred blocks\n    // are referencing it.\n    entry = new DeferEventEntry();\n    interactionTriggers.set(trigger, entry);\n\n    // Ensure that the handler runs in the NgZone\n    ngDevMode && NgZone.assertInAngularZone();\n\n    for (const name of interactionEventNames) {\n      trigger.addEventListener(name, entry!.listener, eventListenerOptions);\n    }\n  }\n\n  entry.callbacks.add(callback);\n\n  return () => {\n    const {callbacks, listener} = entry!;\n    callbacks.delete(callback);\n\n    if (callbacks.size === 0) {\n      interactionTriggers.delete(trigger);\n\n      for (const name of interactionEventNames) {\n        trigger.removeEventListener(name, listener, eventListenerOptions);\n      }\n    }\n  };\n}\n\n/**\n * Registers a hover trigger.\n * @param trigger Element that is the trigger.\n * @param callback Callback to be invoked when the trigger is hovered over.\n */\nexport function onHover(trigger: Element, callback: VoidFunction): VoidFunction {\n  let entry = hoverTriggers.get(trigger);\n\n  // If this is the first entry for this element, add the listener.\n  if (!entry) {\n    entry = new DeferEventEntry();\n    hoverTriggers.set(trigger, entry);\n\n    // Ensure that the handler runs in the NgZone\n    ngDevMode && NgZone.assertInAngularZone();\n\n    for (const name of hoverEventNames) {\n      trigger.addEventListener(name, entry!.listener, eventListenerOptions);\n    }\n  }\n\n  entry.callbacks.add(callback);\n\n  return () => {\n    const {callbacks, listener} = entry!;\n    callbacks.delete(callback);\n\n    if (callbacks.size === 0) {\n      for (const name of hoverEventNames) {\n        trigger.removeEventListener(name, listener, eventListenerOptions);\n      }\n      hoverTriggers.delete(trigger);\n    }\n  };\n}\n\n/**\n * Registers a viewport trigger.\n * @param trigger Element that is the trigger.\n * @param callback Callback to be invoked when the trigger comes into the viewport.\n * @param injector Injector that can be used by the trigger to resolve DI tokens.\n */\nexport function onViewport(\n    trigger: Element, callback: VoidFunction, injector: Injector): VoidFunction {\n  const ngZone = injector.get(NgZone);\n  let entry = viewportTriggers.get(trigger);\n\n  intersectionObserver = intersectionObserver || ngZone.runOutsideAngular(() => {\n    return new IntersectionObserver(entries => {\n      for (const current of entries) {\n        // Only invoke the callbacks if the specific element is intersecting.\n        if (current.isIntersecting && viewportTriggers.has(current.target)) {\n          ngZone.run(viewportTriggers.get(current.target)!.listener);\n        }\n      }\n    });\n  });\n\n  if (!entry) {\n    entry = new DeferEventEntry();\n    ngZone.runOutsideAngular(() => intersectionObserver!.observe(trigger));\n    viewportTriggers.set(trigger, entry);\n    observedViewportElements++;\n  }\n\n  entry.callbacks.add(callback);\n\n  return () => {\n    // It's possible that a different cleanup callback fully removed this element already.\n    if (!viewportTriggers.has(trigger)) {\n      return;\n    }\n\n    entry!.callbacks.delete(callback);\n\n    if (entry!.callbacks.size === 0) {\n      intersectionObserver?.unobserve(trigger);\n      viewportTriggers.delete(trigger);\n      observedViewportElements--;\n    }\n\n    if (observedViewportElements === 0) {\n      intersectionObserver?.disconnect();\n      intersectionObserver = null;\n    }\n  };\n}\n\n/**\n * Helper function to get the LView in which a deferred block's trigger is rendered.\n * @param deferredHostLView LView in which the deferred block is defined.\n * @param deferredTNode TNode defining the deferred block.\n * @param walkUpTimes Number of times to go up in the view hierarchy to find the trigger's view.\n *   A negative value means that the trigger is inside the block's placeholder, while an undefined\n *   value means that the trigger is in the same LView as the deferred block.\n */\nexport function getTriggerLView(\n    deferredHostLView: LView, deferredTNode: TNode, walkUpTimes: number|undefined): LView|null {\n  // The trigger is in the same view, we don't need to traverse.\n  if (walkUpTimes == null) {\n    return deferredHostLView;\n  }\n\n  // A positive value or zero means that the trigger is in a parent view.\n  if (walkUpTimes >= 0) {\n    return walkUpViews(walkUpTimes, deferredHostLView);\n  }\n\n  // If the value is negative, it means that the trigger is inside the placeholder.\n  const deferredContainer = deferredHostLView[deferredTNode.index];\n  ngDevMode && assertLContainer(deferredContainer);\n  const triggerLView = deferredContainer[CONTAINER_HEADER_OFFSET] ?? null;\n\n  // We need to null check, because the placeholder might not have been rendered yet.\n  if (ngDevMode && triggerLView !== null) {\n    const lDetails = getLDeferBlockDetails(deferredHostLView, deferredTNode);\n    const renderedState = lDetails[DEFER_BLOCK_STATE];\n    assertEqual(\n        renderedState, DeferBlockState.Placeholder,\n        'Expected a placeholder to be rendered in this defer block.');\n    assertLView(triggerLView);\n  }\n\n  return triggerLView;\n}\n\n/**\n * Gets the element that a deferred block's trigger is pointing to.\n * @param triggerLView LView in which the trigger is defined.\n * @param triggerIndex Index at which the trigger element should've been rendered.\n */\nexport function getTriggerElement(triggerLView: LView, triggerIndex: number): Element {\n  const element = getNativeByIndex(HEADER_OFFSET + triggerIndex, triggerLView);\n  ngDevMode && assertElement(element);\n  return element as Element;\n}\n\n/**\n * Registers a DOM-node based trigger.\n * @param initialLView LView in which the defer block is rendered.\n * @param tNode TNode representing the defer block.\n * @param triggerIndex Index at which to find the trigger element.\n * @param walkUpTimes Number of times to go up/down in the view hierarchy to find the trigger.\n * @param registerFn Function that will register the DOM events.\n * @param callback Callback to be invoked when the trigger receives the event that should render\n *     the deferred block.\n * @param type Trigger type to distinguish between regular and prefetch triggers.\n */\nexport function registerDomTrigger(\n    initialLView: LView, tNode: TNode, triggerIndex: number, walkUpTimes: number|undefined,\n    registerFn: (element: Element, callback: VoidFunction, injector: Injector) => VoidFunction,\n    callback: VoidFunction, type: TriggerType) {\n  const injector = initialLView[INJECTOR]!;\n  function pollDomTrigger() {\n    // If the initial view was destroyed, we don't need to do anything.\n    if (isDestroyed(initialLView)) {\n      return;\n    }\n\n    const lDetails = getLDeferBlockDetails(initialLView, tNode);\n    const renderedState = lDetails[DEFER_BLOCK_STATE];\n\n    // If the block was loaded before the trigger was resolved, we don't need to do anything.\n    if (renderedState !== DeferBlockInternalState.Initial &&\n        renderedState !== DeferBlockState.Placeholder) {\n      return;\n    }\n\n    const triggerLView = getTriggerLView(initialLView, tNode, walkUpTimes);\n\n    // Keep polling until we resolve the trigger's LView.\n    if (!triggerLView) {\n      internalAfterNextRender(pollDomTrigger, {injector});\n      return;\n    }\n\n    // It's possible that the trigger's view was destroyed before we resolved the trigger element.\n    if (isDestroyed(triggerLView)) {\n      return;\n    }\n\n    const element = getTriggerElement(triggerLView, triggerIndex);\n    const cleanup = registerFn(element, () => {\n      if (initialLView !== triggerLView) {\n        removeLViewOnDestroy(triggerLView, cleanup);\n      }\n      callback();\n    }, injector);\n\n    // The trigger and deferred block might be in different LViews.\n    // For the main LView the cleanup would happen as a part of\n    // `storeTriggerCleanupFn` logic. For trigger LView we register\n    // a cleanup function there to remove event handlers in case an\n    // LView gets destroyed before a trigger is invoked.\n    if (initialLView !== triggerLView) {\n      storeLViewOnDestroy(triggerLView, cleanup);\n    }\n\n    storeTriggerCleanupFn(type, lDetails, cleanup);\n  }\n\n  // Begin polling for the trigger.\n  internalAfterNextRender(pollDomTrigger, {injector});\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {inject, defineInjectable} from '../di';\nimport {INJECTOR, LView} from '../render3/interfaces/view';\nimport {NgZone} from '../zone';\n\n/**\n * Helper function to schedule a callback to be invoked when a browser becomes idle.\n *\n * @param callback A function to be invoked when a browser becomes idle.\n * @param lView LView that hosts an instance of a defer block.\n */\nexport function onIdle(callback: VoidFunction, lView: LView) {\n  const injector = lView[INJECTOR]!;\n  const scheduler = injector.get(IdleScheduler);\n  const cleanupFn = () => scheduler.remove(callback);\n  scheduler.add(callback);\n  return cleanupFn;\n}\n\n/**\n * Use shims for the `requestIdleCallback` and `cancelIdleCallback` functions for\n * environments where those functions are not available (e.g. Node.js and Safari).\n *\n * Note: we wrap the `requestIdleCallback` call into a function, so that it can be\n * overridden/mocked in test environment and picked up by the runtime code.\n */\nconst _requestIdleCallback = () =>\n    typeof requestIdleCallback !== 'undefined' ? requestIdleCallback : setTimeout;\nconst _cancelIdleCallback = () =>\n    typeof requestIdleCallback !== 'undefined' ? cancelIdleCallback : clearTimeout;\n\n/**\n * Helper service to schedule `requestIdleCallback`s for batches of defer blocks,\n * to avoid calling `requestIdleCallback` for each defer block (e.g. if\n * defer blocks are defined inside a for loop).\n */\nexport class IdleScheduler {\n  // Indicates whether current callbacks are being invoked.\n  executingCallbacks = false;\n\n  // Currently scheduled idle callback id.\n  idleId: number|null = null;\n\n  // Set of callbacks to be invoked next.\n  current = new Set<VoidFunction>();\n\n  // Set of callbacks collected while invoking current set of callbacks.\n  // Those callbacks are scheduled for the next idle period.\n  deferred = new Set<VoidFunction>();\n\n  ngZone = inject(NgZone);\n\n  requestIdleCallbackFn = _requestIdleCallback().bind(globalThis);\n  cancelIdleCallbackFn = _cancelIdleCallback().bind(globalThis);\n\n  add(callback: VoidFunction) {\n    const target = this.executingCallbacks ? this.deferred : this.current;\n    target.add(callback);\n    if (this.idleId === null) {\n      this.scheduleIdleCallback();\n    }\n  }\n\n  remove(callback: VoidFunction) {\n    const {current, deferred} = this;\n\n    current.delete(callback);\n    deferred.delete(callback);\n\n    // If the last callback was removed and there is a pending\n    // idle callback - cancel it.\n    if (current.size === 0 && deferred.size === 0) {\n      this.cancelIdleCallback();\n    }\n  }\n\n  private scheduleIdleCallback() {\n    const callback = () => {\n      this.cancelIdleCallback();\n\n      this.executingCallbacks = true;\n\n      for (const callback of this.current) {\n        callback();\n      }\n      this.current.clear();\n\n      this.executingCallbacks = false;\n\n      // If there are any callbacks added during an invocation\n      // of the current ones - make them \"current\" and schedule\n      // a new idle callback.\n      if (this.deferred.size > 0) {\n        for (const callback of this.deferred) {\n          this.current.add(callback);\n        }\n        this.deferred.clear();\n        this.scheduleIdleCallback();\n      }\n    };\n    // Ensure that the callback runs in the NgZone since\n    // the `requestIdleCallback` is not currently patched by Zone.js.\n    this.idleId = this.requestIdleCallbackFn(() => this.ngZone.run(callback)) as number;\n  }\n\n  private cancelIdleCallback() {\n    if (this.idleId !== null) {\n      this.cancelIdleCallbackFn(this.idleId);\n      this.idleId = null;\n    }\n  }\n\n  ngOnDestroy() {\n    this.cancelIdleCallback();\n    this.current.clear();\n    this.deferred.clear();\n  }\n\n  /** @nocollapse */\n  static prov = /** @pureOrBreakMyCode */ defineInjectable({\n    token: IdleScheduler,\n    providedIn: 'root',\n    factory: () => new IdleScheduler(),\n  });\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {defineInjectable} from '../di';\nimport {INJECTOR, LView} from '../render3/interfaces/view';\nimport {arrayInsert2, arraySplice} from '../util/array_utils';\n\n/**\n * Returns a function that captures a provided delay.\n * Invoking the returned function schedules a trigger.\n */\nexport function onTimer(delay: number) {\n  return (callback: VoidFunction, lView: LView) => scheduleTimerTrigger(delay, callback, lView);\n}\n\n/**\n * Schedules a callback to be invoked after a given timeout.\n *\n * @param delay A number of ms to wait until firing a callback.\n * @param callback A function to be invoked after a timeout.\n * @param lView LView that hosts an instance of a defer block.\n */\nexport function scheduleTimerTrigger(delay: number, callback: VoidFunction, lView: LView) {\n  const injector = lView[INJECTOR]!;\n  const scheduler = injector.get(TimerScheduler);\n  const cleanupFn = () => scheduler.remove(callback);\n  scheduler.add(delay, callback);\n  return cleanupFn;\n}\n\n/**\n * Helper service to schedule `setTimeout`s for batches of defer blocks,\n * to avoid calling `setTimeout` for each defer block (e.g. if defer blocks\n * are created inside a for loop).\n */\nexport class TimerScheduler {\n  // Indicates whether current callbacks are being invoked.\n  executingCallbacks = false;\n\n  // Currently scheduled `setTimeout` id.\n  timeoutId: number|null = null;\n\n  // When currently scheduled timer would fire.\n  invokeTimerAt: number|null = null;\n\n  // List of callbacks to be invoked.\n  // For each callback we also store a timestamp on when the callback\n  // should be invoked. We store timestamps and callback functions\n  // in a flat array to avoid creating new objects for each entry.\n  // [timestamp1, callback1, timestamp2, callback2, ...]\n  current: Array<number|VoidFunction> = [];\n\n  // List of callbacks collected while invoking current set of callbacks.\n  // Those callbacks are added to the \"current\" queue at the end of\n  // the current callback invocation. The shape of this list is the same\n  // as the shape of the `current` list.\n  deferred: Array<number|VoidFunction> = [];\n\n  add(delay: number, callback: VoidFunction) {\n    const target = this.executingCallbacks ? this.deferred : this.current;\n    this.addToQueue(target, Date.now() + delay, callback);\n    this.scheduleTimer();\n  }\n\n  remove(callback: VoidFunction) {\n    const {current, deferred} = this;\n    const callbackIndex = this.removeFromQueue(current, callback);\n    if (callbackIndex === -1) {\n      // Try cleaning up deferred queue only in case\n      // we didn't find a callback in the \"current\" queue.\n      this.removeFromQueue(deferred, callback);\n    }\n    // If the last callback was removed and there is a pending timeout - cancel it.\n    if (current.length === 0 && deferred.length === 0) {\n      this.clearTimeout();\n    }\n  }\n\n  private addToQueue(target: Array<number|VoidFunction>, invokeAt: number, callback: VoidFunction) {\n    let insertAtIndex = target.length;\n    for (let i = 0; i < target.length; i += 2) {\n      const invokeQueuedCallbackAt = target[i] as number;\n      if (invokeQueuedCallbackAt > invokeAt) {\n        // We've reached a first timer that is scheduled\n        // for a later time than what we are trying to insert.\n        // This is the location at which we need to insert,\n        // no need to iterate further.\n        insertAtIndex = i;\n        break;\n      }\n    }\n    arrayInsert2(target, insertAtIndex, invokeAt, callback);\n  }\n\n  private removeFromQueue(target: Array<number|VoidFunction>, callback: VoidFunction) {\n    let index = -1;\n    for (let i = 0; i < target.length; i += 2) {\n      const queuedCallback = target[i + 1];\n      if (queuedCallback === callback) {\n        index = i;\n        break;\n      }\n    }\n    if (index > -1) {\n      // Remove 2 elements: a timestamp slot and\n      // the following slot with a callback function.\n      arraySplice(target, index, 2);\n    }\n    return index;\n  }\n\n  private scheduleTimer() {\n    const callback = () => {\n      this.clearTimeout();\n\n      this.executingCallbacks = true;\n\n      // Clone the current state of the queue, since it might be altered\n      // as we invoke callbacks.\n      const current = [...this.current];\n\n      // Invoke callbacks that were scheduled to run before the current time.\n      const now = Date.now();\n      for (let i = 0; i < current.length; i += 2) {\n        const invokeAt = current[i] as number;\n        const callback = current[i + 1] as VoidFunction;\n        if (invokeAt <= now) {\n          callback();\n        } else {\n          // We've reached a timer that should not be invoked yet.\n          break;\n        }\n      }\n      // The state of the queue might've changed after callbacks invocation,\n      // run the cleanup logic based on the *current* state of the queue.\n      let lastCallbackIndex = -1;\n      for (let i = 0; i < this.current.length; i += 2) {\n        const invokeAt = this.current[i] as number;\n        if (invokeAt <= now) {\n          // Add +1 to account for a callback function that\n          // goes after the timestamp in events array.\n          lastCallbackIndex = i + 1;\n        } else {\n          // We've reached a timer that should not be invoked yet.\n          break;\n        }\n      }\n      if (lastCallbackIndex >= 0) {\n        arraySplice(this.current, 0, lastCallbackIndex + 1);\n      }\n\n      this.executingCallbacks = false;\n\n      // If there are any callbacks added during an invocation\n      // of the current ones - move them over to the \"current\"\n      // queue.\n      if (this.deferred.length > 0) {\n        for (let i = 0; i < this.deferred.length; i += 2) {\n          const invokeAt = this.deferred[i] as number;\n          const callback = this.deferred[i + 1] as VoidFunction;\n          this.addToQueue(this.current, invokeAt, callback);\n        }\n        this.deferred.length = 0;\n      }\n      this.scheduleTimer();\n    };\n\n    // Avoid running timer callbacks more than once per\n    // average frame duration. This is needed for better\n    // batching and to avoid kicking off excessive change\n    // detection cycles.\n    const FRAME_DURATION_MS = 16;  // 1000ms / 60fps\n\n    if (this.current.length > 0) {\n      const now = Date.now();\n      // First element in the queue points at the timestamp\n      // of the first (earliest) event.\n      const invokeAt = this.current[0] as number;\n      if (this.timeoutId === null ||\n          // Reschedule a timer in case a queue contains an item with\n          // an earlier timestamp and the delta is more than an average\n          // frame duration.\n          (this.invokeTimerAt && (this.invokeTimerAt - invokeAt > FRAME_DURATION_MS))) {\n        // There was a timeout already, but an earlier event was added\n        // into the queue. In this case we drop an old timer and setup\n        // a new one with an updated (smaller) timeout.\n        this.clearTimeout();\n\n        const timeout = Math.max(invokeAt - now, FRAME_DURATION_MS);\n        this.invokeTimerAt = invokeAt;\n        this.timeoutId = setTimeout(callback, timeout) as unknown as number;\n      }\n    }\n  }\n\n  private clearTimeout() {\n    if (this.timeoutId !== null) {\n      clearTimeout(this.timeoutId);\n      this.timeoutId = null;\n    }\n  }\n\n  ngOnDestroy() {\n    this.clearTimeout();\n    this.current.length = 0;\n    this.deferred.length = 0;\n  }\n\n  /** @nocollapse */\n  static prov = /** @pureOrBreakMyCode */ defineInjectable({\n    token: TimerScheduler,\n    providedIn: 'root',\n    factory: () => new TimerScheduler(),\n  });\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {setActiveConsumer} from '@angular/core/primitives/signals';\n\nimport {InjectionToken, Injector} from '../di';\nimport {RuntimeError, RuntimeErrorCode} from '../errors';\nimport {findMatchingDehydratedView} from '../hydration/views';\nimport {populateDehydratedViewsInLContainer} from '../linker/view_container_ref';\nimport {assertLContainer, assertTNodeForLView} from '../render3/assert';\nimport {bindingUpdated} from '../render3/bindings';\nimport {getComponentDef, getDirectiveDef, getPipeDef} from '../render3/definition';\nimport {getTemplateLocationDetails} from '../render3/instructions/element_validation';\nimport {markViewDirty} from '../render3/instructions/mark_view_dirty';\nimport {handleError} from '../render3/instructions/shared';\nimport {template} from '../render3/instructions/template';\nimport {LContainer} from '../render3/interfaces/container';\nimport {DirectiveDefList, PipeDefList} from '../render3/interfaces/definition';\nimport {TContainerNode, TNode} from '../render3/interfaces/node';\nimport {isDestroyed} from '../render3/interfaces/type_checks';\nimport {HEADER_OFFSET, INJECTOR, LView, PARENT, TVIEW, TView} from '../render3/interfaces/view';\nimport {getCurrentTNode, getLView, getSelectedTNode, getTView, nextBindingIndex} from '../render3/state';\nimport {isPlatformBrowser} from '../render3/util/misc_utils';\nimport {getConstant, getTNode, removeLViewOnDestroy, storeLViewOnDestroy} from '../render3/util/view_utils';\nimport {addLViewToLContainer, createAndRenderEmbeddedLView, removeLViewFromLContainer, shouldAddViewToDom} from '../render3/view_manipulation';\nimport {assertDefined, throwError} from '../util/assert';\nimport {performanceMarkFeature} from '../util/performance';\n\nimport {invokeAllTriggerCleanupFns, invokeTriggerCleanupFns, storeTriggerCleanupFn} from './cleanup';\nimport {onHover, onInteraction, onViewport, registerDomTrigger} from './dom_triggers';\nimport {onIdle} from './idle_scheduler';\nimport {DEFER_BLOCK_STATE, DeferBlockBehavior, DeferBlockConfig, DeferBlockDependencyInterceptor, DeferBlockInternalState, DeferBlockState, DeferDependenciesLoadingState, DeferredLoadingBlockConfig, DeferredPlaceholderBlockConfig, DependencyResolverFn, LDeferBlockDetails, LOADING_AFTER_CLEANUP_FN, NEXT_DEFER_BLOCK_STATE, STATE_IS_FROZEN_UNTIL, TDeferBlockDetails, TriggerType} from './interfaces';\nimport {onTimer, scheduleTimerTrigger} from './timer_scheduler';\nimport {addDepsToRegistry, assertDeferredDependenciesLoaded, getLDeferBlockDetails, getLoadingBlockAfter, getMinimumDurationForState, getPrimaryBlockTNode, getTDeferBlockDetails, getTemplateIndexForState, setLDeferBlockDetails, setTDeferBlockDetails} from './utils';\n\n/**\n * **INTERNAL**, avoid referencing it in application code.\n *\n * Injector token that allows to provide `DeferBlockDependencyInterceptor` class\n * implementation.\n */\nexport const DEFER_BLOCK_DEPENDENCY_INTERCEPTOR =\n    new InjectionToken<DeferBlockDependencyInterceptor>('DEFER_BLOCK_DEPENDENCY_INTERCEPTOR');\n\n/**\n * **INTERNAL**, token used for configuring defer block behavior.\n */\nexport const DEFER_BLOCK_CONFIG =\n    new InjectionToken<DeferBlockConfig>(ngDevMode ? 'DEFER_BLOCK_CONFIG' : '');\n\n/**\n * Returns whether defer blocks should be triggered.\n *\n * Currently, defer blocks are not triggered on the server,\n * only placeholder content is rendered (if provided).\n */\nfunction shouldTriggerDeferBlock(injector: Injector): boolean {\n  const config = injector.get(DEFER_BLOCK_CONFIG, null, {optional: true});\n  if (config?.behavior === DeferBlockBehavior.Manual) {\n    return false;\n  }\n  return isPlatformBrowser(injector);\n}\n\n/**\n * Reference to the timer-based scheduler implementation of defer block state\n * rendering method. It's used to make timer-based scheduling tree-shakable.\n * If `minimum` or `after` parameters are used, compiler generates an extra\n * argument for the `defer` instruction, which references a timer-based\n * implementation.\n */\nlet applyDeferBlockStateWithSchedulingImpl: (typeof applyDeferBlockState)|null = null;\n\n/**\n * Enables timer-related scheduling if `after` or `minimum` parameters are setup\n * on the `@loading` or `@placeholder` blocks.\n */\nexport function deferEnableTimerScheduling(\n    tView: TView, tDetails: TDeferBlockDetails, placeholderConfigIndex?: number|null,\n    loadingConfigIndex?: number|null) {\n  const tViewConsts = tView.consts;\n  if (placeholderConfigIndex != null) {\n    tDetails.placeholderBlockConfig =\n        getConstant<DeferredPlaceholderBlockConfig>(tViewConsts, placeholderConfigIndex);\n  }\n  if (loadingConfigIndex != null) {\n    tDetails.loadingBlockConfig =\n        getConstant<DeferredLoadingBlockConfig>(tViewConsts, loadingConfigIndex);\n  }\n\n  // Enable implementation that supports timer-based scheduling.\n  if (applyDeferBlockStateWithSchedulingImpl === null) {\n    applyDeferBlockStateWithSchedulingImpl = applyDeferBlockStateWithScheduling;\n  }\n}\n\n/**\n * Creates runtime data structures for defer blocks.\n *\n * @param index Index of the `defer` instruction.\n * @param primaryTmplIndex Index of the template with the primary block content.\n * @param dependencyResolverFn Function that contains dependencies for this defer block.\n * @param loadingTmplIndex Index of the template with the loading block content.\n * @param placeholderTmplIndex Index of the template with the placeholder block content.\n * @param errorTmplIndex Index of the template with the error block content.\n * @param loadingConfigIndex Index in the constants array of the configuration of the loading.\n *     block.\n * @param placeholderConfigIndex Index in the constants array of the configuration of the\n *     placeholder block.\n * @param enableTimerScheduling Function that enables timer-related scheduling if `after`\n *     or `minimum` parameters are setup on the `@loading` or `@placeholder` blocks.\n *\n * @codeGenApi\n */\nexport function defer(\n    index: number, primaryTmplIndex: number, dependencyResolverFn?: DependencyResolverFn|null,\n    loadingTmplIndex?: number|null, placeholderTmplIndex?: number|null,\n    errorTmplIndex?: number|null, loadingConfigIndex?: number|null,\n    placeholderConfigIndex?: number|null,\n    enableTimerScheduling?: typeof deferEnableTimerScheduling) {\n  const lView = getLView();\n  const tView = getTView();\n  const adjustedIndex = index + HEADER_OFFSET;\n\n  template(index, null, 0, 0);\n\n  if (tView.firstCreatePass) {\n    performanceMarkFeature('NgDefer');\n\n    const tDetails: TDeferBlockDetails = {\n      primaryTmplIndex,\n      loadingTmplIndex: loadingTmplIndex ?? null,\n      placeholderTmplIndex: placeholderTmplIndex ?? null,\n      errorTmplIndex: errorTmplIndex ?? null,\n      placeholderBlockConfig: null,\n      loadingBlockConfig: null,\n      dependencyResolverFn: dependencyResolverFn ?? null,\n      loadingState: DeferDependenciesLoadingState.NOT_STARTED,\n      loadingPromise: null,\n    };\n    enableTimerScheduling?.(tView, tDetails, placeholderConfigIndex, loadingConfigIndex);\n    setTDeferBlockDetails(tView, adjustedIndex, tDetails);\n  }\n\n  const tNode = getCurrentTNode()!;\n  const lContainer = lView[adjustedIndex];\n\n  // If hydration is enabled, looks up dehydrated views in the DOM\n  // using hydration annotation info and stores those views on LContainer.\n  // In client-only mode, this function is a noop.\n  populateDehydratedViewsInLContainer(lContainer, tNode, lView);\n\n  // Init instance-specific defer details and store it.\n  const lDetails: LDeferBlockDetails = [\n    null,                             // NEXT_DEFER_BLOCK_STATE\n    DeferBlockInternalState.Initial,  // DEFER_BLOCK_STATE\n    null,                             // STATE_IS_FROZEN_UNTIL\n    null,                             // LOADING_AFTER_CLEANUP_FN\n    null,                             // TRIGGER_CLEANUP_FNS\n    null                              // PREFETCH_TRIGGER_CLEANUP_FNS\n  ];\n  setLDeferBlockDetails(lView, adjustedIndex, lDetails);\n\n  const cleanupTriggersFn = () => invokeAllTriggerCleanupFns(lDetails);\n\n  // When defer block is triggered - unsubscribe from LView destroy cleanup.\n  storeTriggerCleanupFn(\n      TriggerType.Regular, lDetails, () => removeLViewOnDestroy(lView, cleanupTriggersFn));\n  storeLViewOnDestroy(lView, cleanupTriggersFn);\n}\n\n/**\n * Loads defer block dependencies when a trigger value becomes truthy.\n * @codeGenApi\n */\nexport function deferWhen(rawValue: unknown) {\n  const lView = getLView();\n  const bindingIndex = nextBindingIndex();\n  if (bindingUpdated(lView, bindingIndex, rawValue)) {\n    const prevConsumer = setActiveConsumer(null);\n    try {\n      const value = Boolean(rawValue);  // handle truthy or falsy values\n      const tNode = getSelectedTNode();\n      const lDetails = getLDeferBlockDetails(lView, tNode);\n      const renderedState = lDetails[DEFER_BLOCK_STATE];\n      if (value === false && renderedState === DeferBlockInternalState.Initial) {\n        // If nothing is rendered yet, render a placeholder (if defined).\n        renderPlaceholder(lView, tNode);\n      } else if (\n          value === true &&\n          (renderedState === DeferBlockInternalState.Initial ||\n           renderedState === DeferBlockState.Placeholder)) {\n        // The `when` condition has changed to `true`, trigger defer block loading\n        // if the block is either in initial (nothing is rendered) or a placeholder\n        // state.\n        triggerDeferBlock(lView, tNode);\n      }\n    } finally {\n      setActiveConsumer(prevConsumer);\n    }\n  }\n}\n\n/**\n * Prefetches the deferred content when a value becomes truthy.\n * @codeGenApi\n */\nexport function deferPrefetchWhen(rawValue: unknown) {\n  const lView = getLView();\n  const bindingIndex = nextBindingIndex();\n\n  if (bindingUpdated(lView, bindingIndex, rawValue)) {\n    const prevConsumer = setActiveConsumer(null);\n    try {\n      const value = Boolean(rawValue);  // handle truthy or falsy values\n      const tView = lView[TVIEW];\n      const tNode = getSelectedTNode();\n      const tDetails = getTDeferBlockDetails(tView, tNode);\n      if (value === true && tDetails.loadingState === DeferDependenciesLoadingState.NOT_STARTED) {\n        // If loading has not been started yet, trigger it now.\n        triggerPrefetching(tDetails, lView, tNode);\n      }\n    } finally {\n      setActiveConsumer(prevConsumer);\n    }\n  }\n}\n\n/**\n * Sets up logic to handle the `on idle` deferred trigger.\n * @codeGenApi\n */\nexport function deferOnIdle() {\n  scheduleDelayedTrigger(onIdle);\n}\n\n/**\n * Sets up logic to handle the `prefetch on idle` deferred trigger.\n * @codeGenApi\n */\nexport function deferPrefetchOnIdle() {\n  scheduleDelayedPrefetching(onIdle);\n}\n\n/**\n * Sets up logic to handle the `on immediate` deferred trigger.\n * @codeGenApi\n */\nexport function deferOnImmediate() {\n  const lView = getLView();\n  const tNode = getCurrentTNode()!;\n  const tView = lView[TVIEW];\n  const tDetails = getTDeferBlockDetails(tView, tNode);\n\n  // Render placeholder block only if loading template is not present\n  // to avoid content flickering, since it would be immediately replaced\n  // by the loading block.\n  if (tDetails.loadingTmplIndex === null) {\n    renderPlaceholder(lView, tNode);\n  }\n  triggerDeferBlock(lView, tNode);\n}\n\n\n/**\n * Sets up logic to handle the `prefetch on immediate` deferred trigger.\n * @codeGenApi\n */\nexport function deferPrefetchOnImmediate() {\n  const lView = getLView();\n  const tNode = getCurrentTNode()!;\n  const tView = lView[TVIEW];\n  const tDetails = getTDeferBlockDetails(tView, tNode);\n\n  if (tDetails.loadingState === DeferDependenciesLoadingState.NOT_STARTED) {\n    triggerResourceLoading(tDetails, lView, tNode);\n  }\n}\n\n/**\n * Creates runtime data structures for the `on timer` deferred trigger.\n * @param delay Amount of time to wait before loading the content.\n * @codeGenApi\n */\nexport function deferOnTimer(delay: number) {\n  scheduleDelayedTrigger(onTimer(delay));\n}\n\n/**\n * Creates runtime data structures for the `prefetch on timer` deferred trigger.\n * @param delay Amount of time to wait before prefetching the content.\n * @codeGenApi\n */\nexport function deferPrefetchOnTimer(delay: number) {\n  scheduleDelayedPrefetching(onTimer(delay));\n}\n\n/**\n * Creates runtime data structures for the `on hover` deferred trigger.\n * @param triggerIndex Index at which to find the trigger element.\n * @param walkUpTimes Number of times to walk up/down the tree hierarchy to find the trigger.\n * @codeGenApi\n */\nexport function deferOnHover(triggerIndex: number, walkUpTimes?: number) {\n  const lView = getLView();\n  const tNode = getCurrentTNode()!;\n\n  renderPlaceholder(lView, tNode);\n  registerDomTrigger(\n      lView, tNode, triggerIndex, walkUpTimes, onHover, () => triggerDeferBlock(lView, tNode),\n      TriggerType.Regular);\n}\n\n/**\n * Creates runtime data structures for the `prefetch on hover` deferred trigger.\n * @param triggerIndex Index at which to find the trigger element.\n * @param walkUpTimes Number of times to walk up/down the tree hierarchy to find the trigger.\n * @codeGenApi\n */\nexport function deferPrefetchOnHover(triggerIndex: number, walkUpTimes?: number) {\n  const lView = getLView();\n  const tNode = getCurrentTNode()!;\n  const tView = lView[TVIEW];\n  const tDetails = getTDeferBlockDetails(tView, tNode);\n\n  if (tDetails.loadingState === DeferDependenciesLoadingState.NOT_STARTED) {\n    registerDomTrigger(\n        lView, tNode, triggerIndex, walkUpTimes, onHover,\n        () => triggerPrefetching(tDetails, lView, tNode), TriggerType.Prefetch);\n  }\n}\n\n/**\n * Creates runtime data structures for the `on interaction` deferred trigger.\n * @param triggerIndex Index at which to find the trigger element.\n * @param walkUpTimes Number of times to walk up/down the tree hierarchy to find the trigger.\n * @codeGenApi\n */\nexport function deferOnInteraction(triggerIndex: number, walkUpTimes?: number) {\n  const lView = getLView();\n  const tNode = getCurrentTNode()!;\n\n  renderPlaceholder(lView, tNode);\n  registerDomTrigger(\n      lView, tNode, triggerIndex, walkUpTimes, onInteraction, () => triggerDeferBlock(lView, tNode),\n      TriggerType.Regular);\n}\n\n/**\n * Creates runtime data structures for the `prefetch on interaction` deferred trigger.\n * @param triggerIndex Index at which to find the trigger element.\n * @param walkUpTimes Number of times to walk up/down the tree hierarchy to find the trigger.\n * @codeGenApi\n */\nexport function deferPrefetchOnInteraction(triggerIndex: number, walkUpTimes?: number) {\n  const lView = getLView();\n  const tNode = getCurrentTNode()!;\n  const tView = lView[TVIEW];\n  const tDetails = getTDeferBlockDetails(tView, tNode);\n\n  if (tDetails.loadingState === DeferDependenciesLoadingState.NOT_STARTED) {\n    registerDomTrigger(\n        lView, tNode, triggerIndex, walkUpTimes, onInteraction,\n        () => triggerPrefetching(tDetails, lView, tNode), TriggerType.Prefetch);\n  }\n}\n\n/**\n * Creates runtime data structures for the `on viewport` deferred trigger.\n * @param triggerIndex Index at which to find the trigger element.\n * @param walkUpTimes Number of times to walk up/down the tree hierarchy to find the trigger.\n * @codeGenApi\n */\nexport function deferOnViewport(triggerIndex: number, walkUpTimes?: number) {\n  const lView = getLView();\n  const tNode = getCurrentTNode()!;\n\n  renderPlaceholder(lView, tNode);\n  registerDomTrigger(\n      lView, tNode, triggerIndex, walkUpTimes, onViewport, () => triggerDeferBlock(lView, tNode),\n      TriggerType.Regular);\n}\n\n/**\n * Creates runtime data structures for the `prefetch on viewport` deferred trigger.\n * @param triggerIndex Index at which to find the trigger element.\n * @param walkUpTimes Number of times to walk up/down the tree hierarchy to find the trigger.\n * @codeGenApi\n */\nexport function deferPrefetchOnViewport(triggerIndex: number, walkUpTimes?: number) {\n  const lView = getLView();\n  const tNode = getCurrentTNode()!;\n  const tView = lView[TVIEW];\n  const tDetails = getTDeferBlockDetails(tView, tNode);\n\n  if (tDetails.loadingState === DeferDependenciesLoadingState.NOT_STARTED) {\n    registerDomTrigger(\n        lView, tNode, triggerIndex, walkUpTimes, onViewport,\n        () => triggerPrefetching(tDetails, lView, tNode), TriggerType.Prefetch);\n  }\n}\n\n/********** Helper functions **********/\n\n/**\n * Schedules triggering of a defer block for `on idle` and `on timer` conditions.\n */\nfunction scheduleDelayedTrigger(\n    scheduleFn: (callback: VoidFunction, lView: LView) => VoidFunction) {\n  const lView = getLView();\n  const tNode = getCurrentTNode()!;\n\n  renderPlaceholder(lView, tNode);\n  const cleanupFn = scheduleFn(() => triggerDeferBlock(lView, tNode), lView);\n  const lDetails = getLDeferBlockDetails(lView, tNode);\n  storeTriggerCleanupFn(TriggerType.Regular, lDetails, cleanupFn);\n}\n\n/**\n * Schedules prefetching for `on idle` and `on timer` triggers.\n *\n * @param scheduleFn A function that does the scheduling.\n */\nfunction scheduleDelayedPrefetching(\n    scheduleFn: (callback: VoidFunction, lView: LView) => VoidFunction) {\n  const lView = getLView();\n  const tNode = getCurrentTNode()!;\n  const tView = lView[TVIEW];\n  const tDetails = getTDeferBlockDetails(tView, tNode);\n\n  if (tDetails.loadingState === DeferDependenciesLoadingState.NOT_STARTED) {\n    const lDetails = getLDeferBlockDetails(lView, tNode);\n    const prefetch = () => triggerPrefetching(tDetails, lView, tNode);\n    const cleanupFn = scheduleFn(prefetch, lView);\n    storeTriggerCleanupFn(TriggerType.Prefetch, lDetails, cleanupFn);\n  }\n}\n\n/**\n * Transitions a defer block to the new state. Updates the  necessary\n * data structures and renders corresponding block.\n *\n * @param newState New state that should be applied to the defer block.\n * @param tNode TNode that represents a defer block.\n * @param lContainer Represents an instance of a defer block.\n * @param skipTimerScheduling Indicates that `@loading` and `@placeholder` block\n *   should be rendered immediately, even if they have `after` or `minimum` config\n *   options setup. This flag to needed for testing APIs to transition defer block\n *   between states via `DeferFixture.render` method.\n */\nexport function renderDeferBlockState(\n    newState: DeferBlockState, tNode: TNode, lContainer: LContainer,\n    skipTimerScheduling = false): void {\n  const hostLView = lContainer[PARENT];\n  const hostTView = hostLView[TVIEW];\n\n  // Check if this view is not destroyed. Since the loading process was async,\n  // the view might end up being destroyed by the time rendering happens.\n  if (isDestroyed(hostLView)) return;\n\n  // Make sure this TNode belongs to TView that represents host LView.\n  ngDevMode && assertTNodeForLView(tNode, hostLView);\n\n  const lDetails = getLDeferBlockDetails(hostLView, tNode);\n\n  ngDevMode && assertDefined(lDetails, 'Expected a defer block state defined');\n\n  const currentState = lDetails[DEFER_BLOCK_STATE];\n\n  if (isValidStateChange(currentState, newState) &&\n      isValidStateChange(lDetails[NEXT_DEFER_BLOCK_STATE] ?? -1, newState)) {\n    const tDetails = getTDeferBlockDetails(hostTView, tNode);\n    const needsScheduling = !skipTimerScheduling &&\n        (getLoadingBlockAfter(tDetails) !== null ||\n         getMinimumDurationForState(tDetails, DeferBlockState.Loading) !== null ||\n         getMinimumDurationForState(tDetails, DeferBlockState.Placeholder));\n\n    if (ngDevMode && needsScheduling) {\n      assertDefined(\n          applyDeferBlockStateWithSchedulingImpl, 'Expected scheduling function to be defined');\n    }\n\n    const applyStateFn =\n        needsScheduling ? applyDeferBlockStateWithSchedulingImpl! : applyDeferBlockState;\n    try {\n      applyStateFn(newState, lDetails, lContainer, tNode, hostLView);\n    } catch (error: unknown) {\n      handleError(hostLView, error);\n    }\n  }\n}\n\n/**\n * Applies changes to the DOM to reflect a given state.\n */\nfunction applyDeferBlockState(\n    newState: DeferBlockState, lDetails: LDeferBlockDetails, lContainer: LContainer, tNode: TNode,\n    hostLView: LView<unknown>) {\n  const stateTmplIndex = getTemplateIndexForState(newState, hostLView, tNode);\n\n  if (stateTmplIndex !== null) {\n    lDetails[DEFER_BLOCK_STATE] = newState;\n    const hostTView = hostLView[TVIEW];\n    const adjustedIndex = stateTmplIndex + HEADER_OFFSET;\n    const tNode = getTNode(hostTView, adjustedIndex) as TContainerNode;\n\n    // There is only 1 view that can be present in an LContainer that\n    // represents a defer block, so always refer to the first one.\n    const viewIndex = 0;\n\n    removeLViewFromLContainer(lContainer, viewIndex);\n    const dehydratedView = findMatchingDehydratedView(lContainer, tNode.tView!.ssrId);\n    const embeddedLView = createAndRenderEmbeddedLView(hostLView, tNode, null, {dehydratedView});\n    addLViewToLContainer(\n        lContainer, embeddedLView, viewIndex, shouldAddViewToDom(tNode, dehydratedView));\n    markViewDirty(embeddedLView);\n  }\n}\n\n/**\n * Extends the `applyDeferBlockState` with timer-based scheduling.\n * This function becomes available on a page if there are defer blocks\n * that use `after` or `minimum` parameters in the `@loading` or\n * `@placeholder` blocks.\n */\nfunction applyDeferBlockStateWithScheduling(\n    newState: DeferBlockState, lDetails: LDeferBlockDetails, lContainer: LContainer, tNode: TNode,\n    hostLView: LView<unknown>) {\n  const now = Date.now();\n  const hostTView = hostLView[TVIEW];\n  const tDetails = getTDeferBlockDetails(hostTView, tNode);\n\n  if (lDetails[STATE_IS_FROZEN_UNTIL] === null || lDetails[STATE_IS_FROZEN_UNTIL] <= now) {\n    lDetails[STATE_IS_FROZEN_UNTIL] = null;\n\n    const loadingAfter = getLoadingBlockAfter(tDetails);\n    const inLoadingAfterPhase = lDetails[LOADING_AFTER_CLEANUP_FN] !== null;\n    if (newState === DeferBlockState.Loading && loadingAfter !== null && !inLoadingAfterPhase) {\n      // Trying to render loading, but it has an `after` config,\n      // so schedule an update action after a timeout.\n      lDetails[NEXT_DEFER_BLOCK_STATE] = newState;\n      const cleanupFn =\n          scheduleDeferBlockUpdate(loadingAfter, lDetails, tNode, lContainer, hostLView);\n      lDetails[LOADING_AFTER_CLEANUP_FN] = cleanupFn;\n    } else {\n      // If we transition to a complete or an error state and there is a pending\n      // operation to render loading after a timeout - invoke a cleanup operation,\n      // which stops the timer.\n      if (newState > DeferBlockState.Loading && inLoadingAfterPhase) {\n        lDetails[LOADING_AFTER_CLEANUP_FN]!();\n        lDetails[LOADING_AFTER_CLEANUP_FN] = null;\n        lDetails[NEXT_DEFER_BLOCK_STATE] = null;\n      }\n\n      applyDeferBlockState(newState, lDetails, lContainer, tNode, hostLView);\n\n      const duration = getMinimumDurationForState(tDetails, newState);\n      if (duration !== null) {\n        lDetails[STATE_IS_FROZEN_UNTIL] = now + duration;\n        scheduleDeferBlockUpdate(duration, lDetails, tNode, lContainer, hostLView);\n      }\n    }\n  } else {\n    // We are still rendering the previous state.\n    // Update the `NEXT_DEFER_BLOCK_STATE`, which would be\n    // picked up once it's time to transition to the next state.\n    lDetails[NEXT_DEFER_BLOCK_STATE] = newState;\n  }\n}\n\n/**\n * Schedules an update operation after a specified timeout.\n */\nfunction scheduleDeferBlockUpdate(\n    timeout: number, lDetails: LDeferBlockDetails, tNode: TNode, lContainer: LContainer,\n    hostLView: LView<unknown>): VoidFunction {\n  const callback = () => {\n    const nextState = lDetails[NEXT_DEFER_BLOCK_STATE];\n    lDetails[STATE_IS_FROZEN_UNTIL] = null;\n    lDetails[NEXT_DEFER_BLOCK_STATE] = null;\n    if (nextState !== null) {\n      renderDeferBlockState(nextState, tNode, lContainer);\n    }\n  };\n  return scheduleTimerTrigger(timeout, callback, hostLView);\n}\n\n/**\n * Checks whether we can transition to the next state.\n *\n * We transition to the next state if the previous state was represented\n * with a number that is less than the next state. For example, if the current\n * state is \"loading\" (represented as `1`), we should not show a placeholder\n * (represented as `0`), but we can show a completed state (represented as `2`)\n * or an error state (represented as `3`).\n */\nfunction isValidStateChange(\n    currentState: DeferBlockState|DeferBlockInternalState, newState: DeferBlockState): boolean {\n  return currentState < newState;\n}\n\n/**\n * Trigger prefetching of dependencies for a defer block.\n *\n * @param tDetails Static information about this defer block.\n * @param lView LView of a host view.\n */\nexport function triggerPrefetching(tDetails: TDeferBlockDetails, lView: LView, tNode: TNode) {\n  if (lView[INJECTOR] && shouldTriggerDeferBlock(lView[INJECTOR]!)) {\n    triggerResourceLoading(tDetails, lView, tNode);\n  }\n}\n\n/**\n * Trigger loading of defer block dependencies if the process hasn't started yet.\n *\n * @param tDetails Static information about this defer block.\n * @param lView LView of a host view.\n */\nexport function triggerResourceLoading(tDetails: TDeferBlockDetails, lView: LView, tNode: TNode) {\n  const injector = lView[INJECTOR]!;\n  const tView = lView[TVIEW];\n\n  if (tDetails.loadingState !== DeferDependenciesLoadingState.NOT_STARTED) {\n    // If the loading status is different from initial one, it means that\n    // the loading of dependencies is in progress and there is nothing to do\n    // in this function. All details can be obtained from the `tDetails` object.\n    return;\n  }\n\n  const lDetails = getLDeferBlockDetails(lView, tNode);\n  const primaryBlockTNode = getPrimaryBlockTNode(tView, tDetails);\n\n  // Switch from NOT_STARTED -> IN_PROGRESS state.\n  tDetails.loadingState = DeferDependenciesLoadingState.IN_PROGRESS;\n\n  // Prefetching is triggered, cleanup all registered prefetch triggers.\n  invokeTriggerCleanupFns(TriggerType.Prefetch, lDetails);\n\n  let dependenciesFn = tDetails.dependencyResolverFn;\n\n  if (ngDevMode) {\n    // Check if dependency function interceptor is configured.\n    const deferDependencyInterceptor =\n        injector.get(DEFER_BLOCK_DEPENDENCY_INTERCEPTOR, null, {optional: true});\n\n    if (deferDependencyInterceptor) {\n      dependenciesFn = deferDependencyInterceptor.intercept(dependenciesFn);\n    }\n  }\n\n  // The `dependenciesFn` might be `null` when all dependencies within\n  // a given defer block were eagerly referenced elsewhere in a file,\n  // thus no dynamic `import()`s were produced.\n  if (!dependenciesFn) {\n    tDetails.loadingPromise = Promise.resolve().then(() => {\n      tDetails.loadingPromise = null;\n      tDetails.loadingState = DeferDependenciesLoadingState.COMPLETE;\n    });\n    return;\n  }\n\n  // Start downloading of defer block dependencies.\n  tDetails.loadingPromise = Promise.allSettled(dependenciesFn()).then(results => {\n    let failed = false;\n    const directiveDefs: DirectiveDefList = [];\n    const pipeDefs: PipeDefList = [];\n\n    for (const result of results) {\n      if (result.status === 'fulfilled') {\n        const dependency = result.value;\n        const directiveDef = getComponentDef(dependency) || getDirectiveDef(dependency);\n        if (directiveDef) {\n          directiveDefs.push(directiveDef);\n        } else {\n          const pipeDef = getPipeDef(dependency);\n          if (pipeDef) {\n            pipeDefs.push(pipeDef);\n          }\n        }\n      } else {\n        failed = true;\n        break;\n      }\n    }\n\n    // Loading is completed, we no longer need this Promise.\n    tDetails.loadingPromise = null;\n\n    if (failed) {\n      tDetails.loadingState = DeferDependenciesLoadingState.FAILED;\n\n      if (tDetails.errorTmplIndex === null) {\n        const templateLocation = getTemplateLocationDetails(lView);\n        const error = new RuntimeError(\n            RuntimeErrorCode.DEFER_LOADING_FAILED,\n            ngDevMode &&\n                'Loading dependencies for `@defer` block failed, ' +\n                    `but no \\`@error\\` block was configured${templateLocation}. ` +\n                    'Consider using the `@error` block to render an error state.');\n        handleError(lView, error);\n      }\n    } else {\n      tDetails.loadingState = DeferDependenciesLoadingState.COMPLETE;\n\n      // Update directive and pipe registries to add newly downloaded dependencies.\n      const primaryBlockTView = primaryBlockTNode.tView!;\n      if (directiveDefs.length > 0) {\n        primaryBlockTView.directiveRegistry =\n            addDepsToRegistry<DirectiveDefList>(primaryBlockTView.directiveRegistry, directiveDefs);\n      }\n      if (pipeDefs.length > 0) {\n        primaryBlockTView.pipeRegistry =\n            addDepsToRegistry<PipeDefList>(primaryBlockTView.pipeRegistry, pipeDefs);\n      }\n    }\n  });\n}\n\n/** Utility function to render placeholder content (if present) */\nfunction renderPlaceholder(lView: LView, tNode: TNode) {\n  const lContainer = lView[tNode.index];\n  ngDevMode && assertLContainer(lContainer);\n\n  renderDeferBlockState(DeferBlockState.Placeholder, tNode, lContainer);\n}\n\n/**\n * Subscribes to the \"loading\" Promise and renders corresponding defer sub-block,\n * based on the loading results.\n *\n * @param lContainer Represents an instance of a defer block.\n * @param tNode Represents defer block info shared across all instances.\n */\nfunction renderDeferStateAfterResourceLoading(\n    tDetails: TDeferBlockDetails, tNode: TNode, lContainer: LContainer) {\n  ngDevMode &&\n      assertDefined(\n          tDetails.loadingPromise, 'Expected loading Promise to exist on this defer block');\n\n  tDetails.loadingPromise!.then(() => {\n    if (tDetails.loadingState === DeferDependenciesLoadingState.COMPLETE) {\n      ngDevMode && assertDeferredDependenciesLoaded(tDetails);\n\n      // Everything is loaded, show the primary block content\n      renderDeferBlockState(DeferBlockState.Complete, tNode, lContainer);\n\n    } else if (tDetails.loadingState === DeferDependenciesLoadingState.FAILED) {\n      renderDeferBlockState(DeferBlockState.Error, tNode, lContainer);\n    }\n  });\n}\n\n/**\n * Attempts to trigger loading of defer block dependencies.\n * If the block is already in a loading, completed or an error state -\n * no additional actions are taken.\n */\nfunction triggerDeferBlock(lView: LView, tNode: TNode) {\n  const tView = lView[TVIEW];\n  const lContainer = lView[tNode.index];\n  const injector = lView[INJECTOR]!;\n  ngDevMode && assertLContainer(lContainer);\n\n  if (!shouldTriggerDeferBlock(injector)) return;\n\n  const lDetails = getLDeferBlockDetails(lView, tNode);\n  const tDetails = getTDeferBlockDetails(tView, tNode);\n\n  // Defer block is triggered, cleanup all registered trigger functions.\n  invokeAllTriggerCleanupFns(lDetails);\n\n  switch (tDetails.loadingState) {\n    case DeferDependenciesLoadingState.NOT_STARTED:\n      renderDeferBlockState(DeferBlockState.Loading, tNode, lContainer);\n      triggerResourceLoading(tDetails, lView, tNode);\n\n      // The `loadingState` might have changed to \"loading\".\n      if ((tDetails.loadingState as DeferDependenciesLoadingState) ===\n          DeferDependenciesLoadingState.IN_PROGRESS) {\n        renderDeferStateAfterResourceLoading(tDetails, tNode, lContainer);\n      }\n      break;\n    case DeferDependenciesLoadingState.IN_PROGRESS:\n      renderDeferBlockState(DeferBlockState.Loading, tNode, lContainer);\n      renderDeferStateAfterResourceLoading(tDetails, tNode, lContainer);\n      break;\n    case DeferDependenciesLoadingState.COMPLETE:\n      ngDevMode && assertDeferredDependenciesLoaded(tDetails);\n      renderDeferBlockState(DeferBlockState.Complete, tNode, lContainer);\n      break;\n    case DeferDependenciesLoadingState.FAILED:\n      renderDeferBlockState(DeferBlockState.Error, tNode, lContainer);\n      break;\n    default:\n      if (ngDevMode) {\n        throwError('Unknown defer block state');\n      }\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {SanitizerFn} from './sanitization';\n\n\n/**\n * Stores a list of nodes which need to be removed.\n *\n * Numbers are indexes into the `LView`\n * - index > 0: `removeRNode(lView[0])`\n * - index < 0: `removeICU(~lView[0])`\n */\nexport interface I18nRemoveOpCodes extends Array<number> {\n  __brand__: 'I18nRemoveOpCodes';\n}\n\n/**\n * `I18nMutateOpCode` defines OpCodes for `I18nMutateOpCodes` array.\n *\n * OpCodes are efficient operations which can be applied to the DOM to update it. (For example to\n * update to a new ICU case requires that we clean up previous elements and create new ones.)\n *\n * OpCodes contain three parts:\n *  1) Parent node index offset. (p)\n *  2) Reference node index offset. (r)\n *  3) The instruction to execute. (i)\n *\n * pppp pppp pppp pppp rrrr rrrr rrrr riii\n * 3322 2222 2222 1111 1111 1110 0000 0000\n * 1098 7654 3210 9876 5432 1098 7654 3210\n *\n * ```\n * var parent = lView[opCode >>> SHIFT_PARENT];\n * var refNode = lView[((opCode & MASK_REF) >>> SHIFT_REF)];\n * var instruction = opCode & MASK_OPCODE;\n * ```\n *\n * See: `I18nCreateOpCodes` for example of usage.\n */\nexport const enum IcuCreateOpCode {\n  /**\n   * Stores shift amount for bits 17-3 that contain reference index.\n   */\n  SHIFT_REF = 1,\n  /**\n   * Stores shift amount for bits 31-17 that contain parent index.\n   */\n  SHIFT_PARENT = 17,\n  /**\n   * Mask for OpCode\n   */\n  MASK_INSTRUCTION = 0b1,\n\n  /**\n   * Mask for the Reference node (bits 16-3)\n   */\n  MASK_REF = 0b11111111111111110,\n  //           11111110000000000\n  //           65432109876543210\n\n  /**\n   * Instruction to append the current node to `PARENT`.\n   */\n  AppendChild = 0b0,\n\n  /**\n   * Instruction to set the attribute of a node.\n   */\n  Attr = 0b1,\n}\n\n\n/**\n * Array storing OpCode for dynamically creating `i18n` blocks.\n *\n * Example:\n * ```ts\n * <I18nCreateOpCode>[\n *   // For adding text nodes\n *   // ---------------------\n *   // Equivalent to:\n *   //   lView[1].appendChild(lView[0] = document.createTextNode('xyz'));\n *   'xyz', 0, 1 << SHIFT_PARENT | 0 << SHIFT_REF | AppendChild,\n *\n *   // For adding element nodes\n *   // ---------------------\n *   // Equivalent to:\n *   //   lView[1].appendChild(lView[0] = document.createElement('div'));\n *   ELEMENT_MARKER, 'div', 0, 1 << SHIFT_PARENT | 0 << SHIFT_REF | AppendChild,\n *\n *   // For adding comment nodes\n *   // ---------------------\n *   // Equivalent to:\n *   //   lView[1].appendChild(lView[0] = document.createComment(''));\n *   ICU_MARKER, '', 0, 1 << SHIFT_PARENT | 0 << SHIFT_REF | AppendChild,\n *\n *   // For moving existing nodes to a different location\n *   // --------------------------------------------------\n *   // Equivalent to:\n *   //   const node = lView[1];\n *   //   lView[2].appendChild(node);\n *   1 << SHIFT_REF | Select, 2 << SHIFT_PARENT | 0 << SHIFT_REF | AppendChild,\n *\n *   // For removing existing nodes\n *   // --------------------------------------------------\n *   //   const node = lView[1];\n *   //   removeChild(tView.data(1), node, lView);\n *   1 << SHIFT_REF | Remove,\n *\n *   // For writing attributes\n *   // --------------------------------------------------\n *   //   const node = lView[1];\n *   //   node.setAttribute('attr', 'value');\n *   1 << SHIFT_REF | Attr, 'attr', 'value'\n * ];\n * ```\n */\nexport interface IcuCreateOpCodes extends Array<number|string|ELEMENT_MARKER|ICU_MARKER|null>,\n                                          I18nDebug {\n  __brand__: 'I18nCreateOpCodes';\n}\n\nexport const enum I18nUpdateOpCode {\n  /**\n   * Stores shift amount for bits 17-2 that contain reference index.\n   */\n  SHIFT_REF = 2,\n  /**\n   * Mask for OpCode\n   */\n  MASK_OPCODE = 0b11,\n\n  /**\n   * Instruction to update a text node.\n   */\n  Text = 0b00,\n  /**\n   * Instruction to update a attribute of a node.\n   */\n  Attr = 0b01,\n  /**\n   * Instruction to switch the current ICU case.\n   */\n  IcuSwitch = 0b10,\n  /**\n   * Instruction to update the current ICU case.\n   */\n  IcuUpdate = 0b11,\n}\n\n/**\n * Marks that the next string is an element name.\n *\n * See `I18nMutateOpCodes` documentation.\n */\nexport const ELEMENT_MARKER: ELEMENT_MARKER = {\n  marker: 'element'\n};\nexport interface ELEMENT_MARKER {\n  marker: 'element';\n}\n\n/**\n * Marks that the next string is comment text need for ICU.\n *\n * See `I18nMutateOpCodes` documentation.\n */\nexport const ICU_MARKER: ICU_MARKER = {\n  marker: 'ICU'\n};\n\nexport interface ICU_MARKER {\n  marker: 'ICU';\n}\n\nexport interface I18nDebug {\n  /**\n   * Human readable representation of the OpCode arrays.\n   *\n   * NOTE: This property only exists if `ngDevMode` is set to `true` and it is not present in\n   * production. Its presence is purely to help debug issue in development, and should not be relied\n   * on in production application.\n   */\n  debug?: string[];\n}\n\n/**\n * Array storing OpCode for dynamically creating `i18n` translation DOM elements.\n *\n * This array creates a sequence of `Text` and `Comment` (as ICU anchor) DOM elements. It consists\n * of a pair of `number` and `string` pairs which encode the operations for the creation of the\n * translated block.\n *\n * The number is shifted and encoded according to `I18nCreateOpCode`\n *\n * Pseudocode:\n * ```\n * const i18nCreateOpCodes = [\n *   10 << I18nCreateOpCode.SHIFT, \"Text Node add to DOM\",\n *   11 << I18nCreateOpCode.SHIFT | I18nCreateOpCode.COMMENT, \"Comment Node add to DOM\",\n *   12 << I18nCreateOpCode.SHIFT | I18nCreateOpCode.APPEND_LATER, \"Text Node added later\"\n * ];\n *\n * for(var i=0; i<i18nCreateOpCodes.length; i++) {\n *   const opcode = i18NCreateOpCodes[i++];\n *   const index = opcode >> I18nCreateOpCode.SHIFT;\n *   const text = i18NCreateOpCodes[i];\n *   let node: Text|Comment;\n *   if (opcode & I18nCreateOpCode.COMMENT === I18nCreateOpCode.COMMENT) {\n *     node = lView[~index] = document.createComment(text);\n *   } else {\n *     node = lView[index] = document.createText(text);\n *   }\n *   if (opcode & I18nCreateOpCode.APPEND_EAGERLY !== I18nCreateOpCode.APPEND_EAGERLY) {\n *     parentNode.appendChild(node);\n *   }\n * }\n * ```\n */\nexport interface I18nCreateOpCodes extends Array<number|string>, I18nDebug {\n  __brand__: 'I18nCreateOpCodes';\n}\n\n/**\n * See `I18nCreateOpCodes`\n */\nexport enum I18nCreateOpCode {\n  /**\n   * Number of bits to shift index so that it can be combined with the `APPEND_EAGERLY` and\n   * `COMMENT`.\n   */\n  SHIFT = 2,\n\n  /**\n   * Should the node be appended to parent immediately after creation.\n   */\n  APPEND_EAGERLY = 0b01,\n\n  /**\n   * If set the node should be comment (rather than a text) node.\n   */\n  COMMENT = 0b10,\n}\n\n\n/**\n * Stores DOM operations which need to be applied to update DOM render tree due to changes in\n * expressions.\n *\n * The basic idea is that `i18nExp` OpCodes capture expression changes and update a change\n * mask bit. (Bit 1 for expression 1, bit 2 for expression 2 etc..., bit 32 for expression 32 and\n * higher.) The OpCodes then compare its own change mask against the expression change mask to\n * determine if the OpCodes should execute.\n *\n * NOTE: 32nd bit is special as it says 32nd or higher. This way if we have more than 32 bindings\n * the code still works, but with lower efficiency. (it is unlikely that a translation would have\n * more than 32 bindings.)\n *\n * These OpCodes can be used by both the i18n block as well as ICU sub-block.\n *\n * ## Example\n *\n * Assume\n * ```ts\n *   if (rf & RenderFlags.Update) {\n *    i18nExp(ctx.exp1); // If changed set mask bit 1\n *    i18nExp(ctx.exp2); // If changed set mask bit 2\n *    i18nExp(ctx.exp3); // If changed set mask bit 3\n *    i18nExp(ctx.exp4); // If changed set mask bit 4\n *    i18nApply(0);            // Apply all changes by executing the OpCodes.\n *  }\n * ```\n * We can assume that each call to `i18nExp` sets an internal `changeMask` bit depending on the\n * index of `i18nExp`.\n *\n * ### OpCodes\n * ```ts\n * <I18nUpdateOpCodes>[\n *   // The following OpCodes represent: `<div i18n-title=\"pre{{exp1}}in{{exp2}}post\">`\n *   // If `changeMask & 0b11`\n *   //        has changed then execute update OpCodes.\n *   //        has NOT changed then skip `8` values and start processing next OpCodes.\n *   0b11, 8,\n *   // Concatenate `newValue = 'pre'+lView[bindIndex-4]+'in'+lView[bindIndex-3]+'post';`.\n *   'pre', -4, 'in', -3, 'post',\n *   // Update attribute: `elementAttribute(1, 'title', sanitizerFn(newValue));`\n *   1 << SHIFT_REF | Attr, 'title', sanitizerFn,\n *\n *   // The following OpCodes represent: `<div i18n>Hello {{exp3}}!\">`\n *   // If `changeMask & 0b100`\n *   //        has changed then execute update OpCodes.\n *   //        has NOT changed then skip `4` values and start processing next OpCodes.\n *   0b100, 4,\n *   // Concatenate `newValue = 'Hello ' + lView[bindIndex -2] + '!';`.\n *   'Hello ', -2, '!',\n *   // Update text: `lView[1].textContent = newValue;`\n *   1 << SHIFT_REF | Text,\n *\n *   // The following OpCodes represent: `<div i18n>{exp4, plural, ... }\">`\n *   // If `changeMask & 0b1000`\n *   //        has changed then execute update OpCodes.\n *   //        has NOT changed then skip `2` values and start processing next OpCodes.\n *   0b1000, 2,\n *   // Concatenate `newValue = lView[bindIndex -1];`.\n *   -1,\n *   // Switch ICU: `icuSwitchCase(lView[1], 0, newValue);`\n *   0 << SHIFT_ICU | 1 << SHIFT_REF | IcuSwitch,\n *\n *   // Note `changeMask & -1` is always true, so the IcuUpdate will always execute.\n *   -1, 1,\n *   // Update ICU: `icuUpdateCase(lView[1], 0);`\n *   0 << SHIFT_ICU | 1 << SHIFT_REF | IcuUpdate,\n *\n * ];\n * ```\n *\n */\nexport interface I18nUpdateOpCodes extends Array<string|number|SanitizerFn|null>, I18nDebug {\n  __brand__: 'I18nUpdateOpCodes';\n}\n\n/**\n * Store information for the i18n translation block.\n */\nexport interface TI18n {\n  /**\n   * A set of OpCodes which will create the Text Nodes and ICU anchors for the translation blocks.\n   *\n   * NOTE: The ICU anchors are filled in with ICU Update OpCode.\n   */\n  create: I18nCreateOpCodes;\n\n  /**\n   * A set of OpCodes which will be executed on each change detection to determine if any changes to\n   * DOM are required.\n   */\n  update: I18nUpdateOpCodes;\n}\n\n/**\n * Defines the ICU type of `select` or `plural`\n */\nexport const enum IcuType {\n  select = 0,\n  plural = 1,\n}\n\nexport interface TIcu {\n  /**\n   * Defines the ICU type of `select` or `plural`\n   */\n  type: IcuType;\n\n  /**\n   * Index in `LView` where the anchor node is stored. `<!-- ICU 0:0 -->`\n   */\n  anchorIdx: number;\n\n  /**\n   * Currently selected ICU case pointer.\n   *\n   * `lView[currentCaseLViewIndex]` stores the currently selected case. This is needed to know how\n   * to clean up the current case when transitioning no the new case.\n   *\n   * If the value stored is:\n   * `null`: No current case selected.\n   *   `<0`: A flag which means that the ICU just switched and that `icuUpdate` must be executed\n   *         regardless of the `mask`. (After the execution the flag is cleared)\n   *   `>=0` A currently selected case index.\n   */\n  currentCaseLViewIndex: number;\n\n  /**\n   * A list of case values which the current ICU will try to match.\n   *\n   * The last value is `other`\n   */\n  cases: any[];\n\n  /**\n   * A set of OpCodes to apply in order to build up the DOM render tree for the ICU\n   */\n  create: IcuCreateOpCodes[];\n\n  /**\n   * A set of OpCodes to apply in order to destroy the DOM render tree for the ICU.\n   */\n  remove: I18nRemoveOpCodes[];\n\n  /**\n   * A set of OpCodes to apply in order to update the DOM render tree for the ICU bindings.\n   */\n  update: I18nUpdateOpCodes[];\n}\n\n/**\n * Parsed ICU expression\n */\nexport interface IcuExpression {\n  type: IcuType;\n  mainBinding: number;\n  cases: string[];\n  values: (string|IcuExpression)[][];\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {assertDomNode, assertIndexInRange} from '../util/assert';\n\nimport {TNode, TNodeFlags, TNodeType} from './interfaces/node';\nimport {Renderer} from './interfaces/renderer';\nimport {RElement, RNode} from './interfaces/renderer_dom';\nimport {LView} from './interfaces/view';\nimport {getInsertInFrontOfRNodeWithNoI18n, nativeInsertBefore} from './node_manipulation';\nimport {unwrapRNode} from './util/view_utils';\n\n\n/**\n * Find a node in front of which `currentTNode` should be inserted (takes i18n into account).\n *\n * This method determines the `RNode` in front of which we should insert the `currentRNode`. This\n * takes `TNode.insertBeforeIndex` into account.\n *\n * @param parentTNode parent `TNode`\n * @param currentTNode current `TNode` (The node which we would like to insert into the DOM)\n * @param lView current `LView`\n */\nexport function getInsertInFrontOfRNodeWithI18n(\n    parentTNode: TNode, currentTNode: TNode, lView: LView): RNode|null {\n  const tNodeInsertBeforeIndex = currentTNode.insertBeforeIndex;\n  const insertBeforeIndex =\n      Array.isArray(tNodeInsertBeforeIndex) ? tNodeInsertBeforeIndex[0] : tNodeInsertBeforeIndex;\n  if (insertBeforeIndex === null) {\n    return getInsertInFrontOfRNodeWithNoI18n(parentTNode, currentTNode, lView);\n  } else {\n    ngDevMode && assertIndexInRange(lView, insertBeforeIndex);\n    return unwrapRNode(lView[insertBeforeIndex]);\n  }\n}\n\n\n/**\n * Process `TNode.insertBeforeIndex` by adding i18n text nodes.\n *\n * See `TNode.insertBeforeIndex`\n */\nexport function processI18nInsertBefore(\n    renderer: Renderer, childTNode: TNode, lView: LView, childRNode: RNode|RNode[],\n    parentRElement: RElement|null): void {\n  const tNodeInsertBeforeIndex = childTNode.insertBeforeIndex;\n  if (Array.isArray(tNodeInsertBeforeIndex)) {\n    // An array indicates that there are i18n nodes that need to be added as children of this\n    // `childRNode`. These i18n nodes were created before this `childRNode` was available and so\n    // only now can be added. The first element of the array is the normal index where we should\n    // insert the `childRNode`. Additional elements are the extra nodes to be added as children of\n    // `childRNode`.\n    ngDevMode && assertDomNode(childRNode);\n    let i18nParent: RElement|null = childRNode as RElement;\n    let anchorRNode: RNode|null = null;\n    if (!(childTNode.type & TNodeType.AnyRNode)) {\n      anchorRNode = i18nParent;\n      i18nParent = parentRElement;\n    }\n    if (i18nParent !== null && childTNode.componentOffset === -1) {\n      for (let i = 1; i < tNodeInsertBeforeIndex.length; i++) {\n        // No need to `unwrapRNode` because all of the indexes point to i18n text nodes.\n        // see `assertDomNode` below.\n        const i18nChild = lView[tNodeInsertBeforeIndex[i]];\n        nativeInsertBefore(renderer, i18nParent, i18nChild, anchorRNode, false);\n      }\n    }\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {assertEqual} from '../../util/assert';\nimport {TNode, TNodeType} from '../interfaces/node';\nimport {setI18nHandling} from '../node_manipulation';\nimport {getInsertInFrontOfRNodeWithI18n, processI18nInsertBefore} from '../node_manipulation_i18n';\n\n/**\n * Add `tNode` to `previousTNodes` list and update relevant `TNode`s in `previousTNodes` list\n * `tNode.insertBeforeIndex`.\n *\n * Things to keep in mind:\n * 1. All i18n text nodes are encoded as `TNodeType.Element` and are created eagerly by the\n *    `i18nStart` instruction.\n * 2. All `TNodeType.Placeholder` `TNodes` are elements which will be created later by\n *    `elementStart` instruction.\n * 3. `elementStart` instruction will create `TNode`s in the ascending `TNode.index` order. (So a\n *    smaller index `TNode` is guaranteed to be created before a larger one)\n *\n * We use the above three invariants to determine `TNode.insertBeforeIndex`.\n *\n * In an ideal world `TNode.insertBeforeIndex` would always be `TNode.next.index`. However,\n * this will not work because `TNode.next.index` may be larger than `TNode.index` which means that\n * the next node is not yet created and therefore we can't insert in front of it.\n *\n * Rule1: `TNode.insertBeforeIndex = null` if `TNode.next === null` (Initial condition, as we don't\n *        know if there will be further `TNode`s inserted after.)\n * Rule2: If `previousTNode` is created after the `tNode` being inserted, then\n *        `previousTNode.insertBeforeNode = tNode.index` (So when a new `tNode` is added we check\n *        previous to see if we can update its `insertBeforeTNode`)\n *\n * See `TNode.insertBeforeIndex` for more context.\n *\n * @param previousTNodes A list of previous TNodes so that we can easily traverse `TNode`s in\n *     reverse order. (If `TNode` would have `previous` this would not be necessary.)\n * @param newTNode A TNode to add to the `previousTNodes` list.\n */\nexport function addTNodeAndUpdateInsertBeforeIndex(previousTNodes: TNode[], newTNode: TNode) {\n  // Start with Rule1\n  ngDevMode &&\n      assertEqual(newTNode.insertBeforeIndex, null, 'We expect that insertBeforeIndex is not set');\n\n  previousTNodes.push(newTNode);\n  if (previousTNodes.length > 1) {\n    for (let i = previousTNodes.length - 2; i >= 0; i--) {\n      const existingTNode = previousTNodes[i];\n      // Text nodes are created eagerly and so they don't need their `indexBeforeIndex` updated.\n      // It is safe to ignore them.\n      if (!isI18nText(existingTNode)) {\n        if (isNewTNodeCreatedBefore(existingTNode, newTNode) &&\n            getInsertBeforeIndex(existingTNode) === null) {\n          // If it was created before us in time, (and it does not yet have `insertBeforeIndex`)\n          // then add the `insertBeforeIndex`.\n          setInsertBeforeIndex(existingTNode, newTNode.index);\n        }\n      }\n    }\n  }\n}\n\nfunction isI18nText(tNode: TNode): boolean {\n  return !(tNode.type & TNodeType.Placeholder);\n}\n\nfunction isNewTNodeCreatedBefore(existingTNode: TNode, newTNode: TNode): boolean {\n  return isI18nText(newTNode) || existingTNode.index > newTNode.index;\n}\n\nfunction getInsertBeforeIndex(tNode: TNode): number|null {\n  const index = tNode.insertBeforeIndex;\n  return Array.isArray(index) ? index[0] : index;\n}\n\nfunction setInsertBeforeIndex(tNode: TNode, value: number): void {\n  const index = tNode.insertBeforeIndex;\n  if (Array.isArray(index)) {\n    // Array is stored if we have to insert child nodes. See `TNode.insertBeforeIndex`\n    index[0] = value;\n  } else {\n    setI18nHandling(getInsertInFrontOfRNodeWithI18n, processI18nInsertBefore);\n    tNode.insertBeforeIndex = value;\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {assertEqual, assertGreaterThan, assertGreaterThanOrEqual, throwError} from '../../util/assert';\nimport {assertTIcu, assertTNode} from '../assert';\nimport {createTNodeAtIndex} from '../instructions/shared';\nimport {IcuCreateOpCode, TIcu} from '../interfaces/i18n';\nimport {TIcuContainerNode, TNode, TNodeType} from '../interfaces/node';\nimport {LView, TView} from '../interfaces/view';\nimport {assertTNodeType} from '../node_assert';\nimport {setI18nHandling} from '../node_manipulation';\nimport {getInsertInFrontOfRNodeWithI18n, processI18nInsertBefore} from '../node_manipulation_i18n';\n\nimport {addTNodeAndUpdateInsertBeforeIndex} from './i18n_insert_before_index';\n\n\n/**\n * Retrieve `TIcu` at a given `index`.\n *\n * The `TIcu` can be stored either directly (if it is nested ICU) OR\n * it is stored inside tho `TIcuContainer` if it is top level ICU.\n *\n * The reason for this is that the top level ICU need a `TNode` so that they are part of the render\n * tree, but nested ICU's have no TNode, because we don't know ahead of time if the nested ICU is\n * expressed (parent ICU may have selected a case which does not contain it.)\n *\n * @param tView Current `TView`.\n * @param index Index where the value should be read from.\n */\nexport function getTIcu(tView: TView, index: number): TIcu|null {\n  const value = tView.data[index] as null | TIcu | TIcuContainerNode | string;\n  if (value === null || typeof value === 'string') return null;\n  if (ngDevMode &&\n      !(value.hasOwnProperty('tView') || value.hasOwnProperty('currentCaseLViewIndex'))) {\n    throwError('We expect to get \\'null\\'|\\'TIcu\\'|\\'TIcuContainer\\', but got: ' + value);\n  }\n  // Here the `value.hasOwnProperty('currentCaseLViewIndex')` is a polymorphic read as it can be\n  // either TIcu or TIcuContainerNode. This is not ideal, but we still think it is OK because it\n  // will be just two cases which fits into the browser inline cache (inline cache can take up to\n  // 4)\n  const tIcu = value.hasOwnProperty('currentCaseLViewIndex') ? value as TIcu :\n                                                               (value as TIcuContainerNode).value;\n  ngDevMode && assertTIcu(tIcu);\n  return tIcu;\n}\n\n/**\n * Store `TIcu` at a give `index`.\n *\n * The `TIcu` can be stored either directly (if it is nested ICU) OR\n * it is stored inside tho `TIcuContainer` if it is top level ICU.\n *\n * The reason for this is that the top level ICU need a `TNode` so that they are part of the render\n * tree, but nested ICU's have no TNode, because we don't know ahead of time if the nested ICU is\n * expressed (parent ICU may have selected a case which does not contain it.)\n *\n * @param tView Current `TView`.\n * @param index Index where the value should be stored at in `Tview.data`\n * @param tIcu The TIcu to store.\n */\nexport function setTIcu(tView: TView, index: number, tIcu: TIcu): void {\n  const tNode = tView.data[index] as null | TIcuContainerNode;\n  ngDevMode &&\n      assertEqual(\n          tNode === null || tNode.hasOwnProperty('tView'), true,\n          'We expect to get \\'null\\'|\\'TIcuContainer\\'');\n  if (tNode === null) {\n    tView.data[index] = tIcu;\n  } else {\n    ngDevMode && assertTNodeType(tNode, TNodeType.Icu);\n    tNode.value = tIcu;\n  }\n}\n\n/**\n * Set `TNode.insertBeforeIndex` taking the `Array` into account.\n *\n * See `TNode.insertBeforeIndex`\n */\nexport function setTNodeInsertBeforeIndex(tNode: TNode, index: number) {\n  ngDevMode && assertTNode(tNode);\n  let insertBeforeIndex = tNode.insertBeforeIndex;\n  if (insertBeforeIndex === null) {\n    setI18nHandling(getInsertInFrontOfRNodeWithI18n, processI18nInsertBefore);\n    insertBeforeIndex = tNode.insertBeforeIndex =\n        [null!/* may be updated to number later */, index];\n  } else {\n    assertEqual(Array.isArray(insertBeforeIndex), true, 'Expecting array here');\n    (insertBeforeIndex as number[]).push(index);\n  }\n}\n\n/**\n * Create `TNode.type=TNodeType.Placeholder` node.\n *\n * See `TNodeType.Placeholder` for more information.\n */\nexport function createTNodePlaceholder(\n    tView: TView, previousTNodes: TNode[], index: number): TNode {\n  const tNode = createTNodeAtIndex(tView, index, TNodeType.Placeholder, null, null);\n  addTNodeAndUpdateInsertBeforeIndex(previousTNodes, tNode);\n  return tNode;\n}\n\n\n/**\n * Returns current ICU case.\n *\n * ICU cases are stored as index into the `TIcu.cases`.\n * At times it is necessary to communicate that the ICU case just switched and that next ICU update\n * should update all bindings regardless of the mask. In such a case the we store negative numbers\n * for cases which have just been switched. This function removes the negative flag.\n */\nexport function getCurrentICUCaseIndex(tIcu: TIcu, lView: LView) {\n  const currentCase: number|null = lView[tIcu.currentCaseLViewIndex];\n  return currentCase === null ? currentCase : (currentCase < 0 ? ~currentCase : currentCase);\n}\n\nexport function getParentFromIcuCreateOpCode(mergedCode: number): number {\n  return mergedCode >>> IcuCreateOpCode.SHIFT_PARENT;\n}\n\nexport function getRefFromIcuCreateOpCode(mergedCode: number): number {\n  return (mergedCode & IcuCreateOpCode.MASK_REF) >>> IcuCreateOpCode.SHIFT_REF;\n}\n\nexport function getInstructionFromIcuCreateOpCode(mergedCode: number): number {\n  return mergedCode & IcuCreateOpCode.MASK_INSTRUCTION;\n}\n\nexport function icuCreateOpCode(opCode: IcuCreateOpCode, parentIdx: number, refIdx: number) {\n  ngDevMode && assertGreaterThanOrEqual(parentIdx, 0, 'Missing parent index');\n  ngDevMode && assertGreaterThan(refIdx, 0, 'Missing ref index');\n  return opCode | parentIdx << IcuCreateOpCode.SHIFT_PARENT | refIdx << IcuCreateOpCode.SHIFT_REF;\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {RuntimeError, RuntimeErrorCode} from '../../errors';\nimport {getPluralCase} from '../../i18n/localization';\nimport {assertDefined, assertDomNode, assertEqual, assertGreaterThan, assertIndexInRange, throwError} from '../../util/assert';\nimport {assertIndexInExpandoRange, assertTIcu} from '../assert';\nimport {attachPatchData} from '../context_discovery';\nimport {elementPropertyInternal, setElementAttribute} from '../instructions/shared';\nimport {ELEMENT_MARKER, I18nCreateOpCode, I18nCreateOpCodes, I18nUpdateOpCode, I18nUpdateOpCodes, ICU_MARKER, IcuCreateOpCode, IcuCreateOpCodes, IcuType, TI18n, TIcu} from '../interfaces/i18n';\nimport {TNode} from '../interfaces/node';\nimport {RElement, RNode, RText} from '../interfaces/renderer_dom';\nimport {SanitizerFn} from '../interfaces/sanitization';\nimport {HEADER_OFFSET, LView, RENDERER, TView} from '../interfaces/view';\nimport {createCommentNode, createElementNode, createTextNode, nativeInsertBefore, nativeParentNode, nativeRemoveNode, updateTextNode} from '../node_manipulation';\nimport {getBindingIndex} from '../state';\nimport {renderStringify} from '../util/stringify_utils';\nimport {getNativeByIndex, unwrapRNode} from '../util/view_utils';\n\nimport {getLocaleId} from './i18n_locale_id';\nimport {getCurrentICUCaseIndex, getParentFromIcuCreateOpCode, getRefFromIcuCreateOpCode, getTIcu} from './i18n_util';\n\n\n\n/**\n * Keep track of which input bindings in `i18nExp` have changed.\n *\n * This is used to efficiently update expressions in i18n only when the corresponding input has\n * changed.\n *\n * 1) Each bit represents which of the `i18nExp` has changed.\n * 2) There are 32 bits allowed in JS.\n * 3) Bit 32 is special as it is shared for all changes past 32. (In other words if you have more\n * than 32 `i18nExp` then all changes past 32nd `i18nExp` will be mapped to same bit. This means\n * that we may end up changing more than we need to. But i18n expressions with 32 bindings is rare\n * so in practice it should not be an issue.)\n */\nlet changeMask = 0b0;\n\n/**\n * Keeps track of which bit needs to be updated in `changeMask`\n *\n * This value gets incremented on every call to `i18nExp`\n */\nlet changeMaskCounter = 0;\n\n/**\n * Keep track of which input bindings in `i18nExp` have changed.\n *\n * `setMaskBit` gets invoked by each call to `i18nExp`.\n *\n * @param hasChange did `i18nExp` detect a change.\n */\nexport function setMaskBit(hasChange: boolean) {\n  if (hasChange) {\n    changeMask = changeMask | (1 << Math.min(changeMaskCounter, 31));\n  }\n  changeMaskCounter++;\n}\n\nexport function applyI18n(tView: TView, lView: LView, index: number) {\n  if (changeMaskCounter > 0) {\n    ngDevMode && assertDefined(tView, `tView should be defined`);\n    const tI18n = tView.data[index] as TI18n | I18nUpdateOpCodes;\n    // When `index` points to an `i18nAttributes` then we have an array otherwise `TI18n`\n    const updateOpCodes: I18nUpdateOpCodes =\n        Array.isArray(tI18n) ? tI18n as I18nUpdateOpCodes : (tI18n as TI18n).update;\n    const bindingsStartIndex = getBindingIndex() - changeMaskCounter - 1;\n    applyUpdateOpCodes(tView, lView, updateOpCodes, bindingsStartIndex, changeMask);\n  }\n  // Reset changeMask & maskBit to default for the next update cycle\n  changeMask = 0b0;\n  changeMaskCounter = 0;\n}\n\n\n/**\n * Apply `I18nCreateOpCodes` op-codes as stored in `TI18n.create`.\n *\n * Creates text (and comment) nodes which are internationalized.\n *\n * @param lView Current lView\n * @param createOpCodes Set of op-codes to apply\n * @param parentRNode Parent node (so that direct children can be added eagerly) or `null` if it is\n *     a root node.\n * @param insertInFrontOf DOM node that should be used as an anchor.\n */\nexport function applyCreateOpCodes(\n    lView: LView, createOpCodes: I18nCreateOpCodes, parentRNode: RElement|null,\n    insertInFrontOf: RElement|null): void {\n  const renderer = lView[RENDERER];\n  for (let i = 0; i < createOpCodes.length; i++) {\n    const opCode = createOpCodes[i++] as any;\n    const text = createOpCodes[i] as string;\n    const isComment = (opCode & I18nCreateOpCode.COMMENT) === I18nCreateOpCode.COMMENT;\n    const appendNow =\n        (opCode & I18nCreateOpCode.APPEND_EAGERLY) === I18nCreateOpCode.APPEND_EAGERLY;\n    const index = opCode >>> I18nCreateOpCode.SHIFT;\n    let rNode = lView[index];\n    if (rNode === null) {\n      // We only create new DOM nodes if they don't already exist: If ICU switches case back to a\n      // case which was already instantiated, no need to create new DOM nodes.\n      rNode = lView[index] =\n          isComment ? renderer.createComment(text) : createTextNode(renderer, text);\n    }\n    if (appendNow && parentRNode !== null) {\n      nativeInsertBefore(renderer, parentRNode, rNode, insertInFrontOf, false);\n    }\n  }\n}\n\n/**\n * Apply `I18nMutateOpCodes` OpCodes.\n *\n * @param tView Current `TView`\n * @param mutableOpCodes Mutable OpCodes to process\n * @param lView Current `LView`\n * @param anchorRNode place where the i18n node should be inserted.\n */\nexport function applyMutableOpCodes(\n    tView: TView, mutableOpCodes: IcuCreateOpCodes, lView: LView, anchorRNode: RNode): void {\n  ngDevMode && assertDomNode(anchorRNode);\n  const renderer = lView[RENDERER];\n  // `rootIdx` represents the node into which all inserts happen.\n  let rootIdx: number|null = null;\n  // `rootRNode` represents the real node into which we insert. This can be different from\n  // `lView[rootIdx]` if we have projection.\n  //  - null we don't have a parent (as can be the case in when we are inserting into a root of\n  //    LView which has no parent.)\n  //  - `RElement` The element representing the root after taking projection into account.\n  let rootRNode!: RElement|null;\n  for (let i = 0; i < mutableOpCodes.length; i++) {\n    const opCode = mutableOpCodes[i];\n    if (typeof opCode == 'string') {\n      const textNodeIndex = mutableOpCodes[++i] as number;\n      if (lView[textNodeIndex] === null) {\n        ngDevMode && ngDevMode.rendererCreateTextNode++;\n        ngDevMode && assertIndexInRange(lView, textNodeIndex);\n        lView[textNodeIndex] = createTextNode(renderer, opCode);\n      }\n    } else if (typeof opCode == 'number') {\n      switch (opCode & IcuCreateOpCode.MASK_INSTRUCTION) {\n        case IcuCreateOpCode.AppendChild:\n          const parentIdx = getParentFromIcuCreateOpCode(opCode);\n          if (rootIdx === null) {\n            // The first operation should save the `rootIdx` because the first operation\n            // must insert into the root. (Only subsequent operations can insert into a dynamic\n            // parent)\n            rootIdx = parentIdx;\n            rootRNode = nativeParentNode(renderer, anchorRNode);\n          }\n          let insertInFrontOf: RNode|null;\n          let parentRNode: RElement|null;\n          if (parentIdx === rootIdx) {\n            insertInFrontOf = anchorRNode;\n            parentRNode = rootRNode;\n          } else {\n            insertInFrontOf = null;\n            parentRNode = unwrapRNode(lView[parentIdx]) as RElement;\n          }\n          // FIXME(misko): Refactor with `processI18nText`\n          if (parentRNode !== null) {\n            // This can happen if the `LView` we are adding to is not attached to a parent `LView`.\n            // In such a case there is no \"root\" we can attach to. This is fine, as we still need to\n            // create the elements. When the `LView` gets later added to a parent these \"root\" nodes\n            // get picked up and added.\n            ngDevMode && assertDomNode(parentRNode);\n            const refIdx = getRefFromIcuCreateOpCode(opCode);\n            ngDevMode && assertGreaterThan(refIdx, HEADER_OFFSET, 'Missing ref');\n            // `unwrapRNode` is not needed here as all of these point to RNodes as part of the i18n\n            // which can't have components.\n            const child = lView[refIdx] as RElement;\n            ngDevMode && assertDomNode(child);\n            nativeInsertBefore(renderer, parentRNode, child, insertInFrontOf, false);\n            const tIcu = getTIcu(tView, refIdx);\n            if (tIcu !== null && typeof tIcu === 'object') {\n              // If we just added a comment node which has ICU then that ICU may have already been\n              // rendered and therefore we need to re-add it here.\n              ngDevMode && assertTIcu(tIcu);\n              const caseIndex = getCurrentICUCaseIndex(tIcu, lView);\n              if (caseIndex !== null) {\n                applyMutableOpCodes(tView, tIcu.create[caseIndex], lView, lView[tIcu.anchorIdx]);\n              }\n            }\n          }\n          break;\n        case IcuCreateOpCode.Attr:\n          const elementNodeIndex = opCode >>> IcuCreateOpCode.SHIFT_REF;\n          const attrName = mutableOpCodes[++i] as string;\n          const attrValue = mutableOpCodes[++i] as string;\n          // This code is used for ICU expressions only, since we don't support\n          // directives/components in ICUs, we don't need to worry about inputs here\n          setElementAttribute(\n              renderer, getNativeByIndex(elementNodeIndex, lView) as RElement, null, null, attrName,\n              attrValue, null);\n          break;\n        default:\n          if (ngDevMode) {\n            throw new RuntimeError(\n                RuntimeErrorCode.INVALID_I18N_STRUCTURE,\n                `Unable to determine the type of mutate operation for \"${opCode}\"`);\n          }\n      }\n    } else {\n      switch (opCode) {\n        case ICU_MARKER:\n          const commentValue = mutableOpCodes[++i] as string;\n          const commentNodeIndex = mutableOpCodes[++i] as number;\n          if (lView[commentNodeIndex] === null) {\n            ngDevMode &&\n                assertEqual(\n                    typeof commentValue, 'string',\n                    `Expected \"${commentValue}\" to be a comment node value`);\n            ngDevMode && ngDevMode.rendererCreateComment++;\n            ngDevMode && assertIndexInExpandoRange(lView, commentNodeIndex);\n            const commentRNode = lView[commentNodeIndex] =\n                createCommentNode(renderer, commentValue);\n            // FIXME(misko): Attaching patch data is only needed for the root (Also add tests)\n            attachPatchData(commentRNode, lView);\n          }\n          break;\n        case ELEMENT_MARKER:\n          const tagName = mutableOpCodes[++i] as string;\n          const elementNodeIndex = mutableOpCodes[++i] as number;\n          if (lView[elementNodeIndex] === null) {\n            ngDevMode &&\n                assertEqual(\n                    typeof tagName, 'string',\n                    `Expected \"${tagName}\" to be an element node tag name`);\n\n            ngDevMode && ngDevMode.rendererCreateElement++;\n            ngDevMode && assertIndexInExpandoRange(lView, elementNodeIndex);\n            const elementRNode = lView[elementNodeIndex] =\n                createElementNode(renderer, tagName, null);\n            // FIXME(misko): Attaching patch data is only needed for the root (Also add tests)\n            attachPatchData(elementRNode, lView);\n          }\n          break;\n        default:\n          ngDevMode &&\n              throwError(`Unable to determine the type of mutate operation for \"${opCode}\"`);\n      }\n    }\n  }\n}\n\n\n/**\n * Apply `I18nUpdateOpCodes` OpCodes\n *\n * @param tView Current `TView`\n * @param lView Current `LView`\n * @param updateOpCodes OpCodes to process\n * @param bindingsStartIndex Location of the first `i18nApply`\n * @param changeMask Each bit corresponds to a `i18nExp` (Counting backwards from\n *     `bindingsStartIndex`)\n */\nexport function applyUpdateOpCodes(\n    tView: TView, lView: LView, updateOpCodes: I18nUpdateOpCodes, bindingsStartIndex: number,\n    changeMask: number) {\n  for (let i = 0; i < updateOpCodes.length; i++) {\n    // bit code to check if we should apply the next update\n    const checkBit = updateOpCodes[i] as number;\n    // Number of opCodes to skip until next set of update codes\n    const skipCodes = updateOpCodes[++i] as number;\n    if (checkBit & changeMask) {\n      // The value has been updated since last checked\n      let value = '';\n      for (let j = i + 1; j <= (i + skipCodes); j++) {\n        const opCode = updateOpCodes[j];\n        if (typeof opCode == 'string') {\n          value += opCode;\n        } else if (typeof opCode == 'number') {\n          if (opCode < 0) {\n            // Negative opCode represent `i18nExp` values offset.\n            value += renderStringify(lView[bindingsStartIndex - opCode]);\n          } else {\n            const nodeIndex = (opCode >>> I18nUpdateOpCode.SHIFT_REF);\n            switch (opCode & I18nUpdateOpCode.MASK_OPCODE) {\n              case I18nUpdateOpCode.Attr:\n                const propName = updateOpCodes[++j] as string;\n                const sanitizeFn = updateOpCodes[++j] as SanitizerFn | null;\n                const tNodeOrTagName = tView.data[nodeIndex] as TNode | string;\n                ngDevMode && assertDefined(tNodeOrTagName, 'Experting TNode or string');\n                if (typeof tNodeOrTagName === 'string') {\n                  // IF we don't have a `TNode`, then we are an element in ICU (as ICU content does\n                  // not have TNode), in which case we know that there are no directives, and hence\n                  // we use attribute setting.\n                  setElementAttribute(\n                      lView[RENDERER], lView[nodeIndex], null, tNodeOrTagName, propName, value,\n                      sanitizeFn);\n                } else {\n                  elementPropertyInternal(\n                      tView, tNodeOrTagName, lView, propName, value, lView[RENDERER], sanitizeFn,\n                      false);\n                }\n                break;\n              case I18nUpdateOpCode.Text:\n                const rText = lView[nodeIndex] as RText | null;\n                rText !== null && updateTextNode(lView[RENDERER], rText, value);\n                break;\n              case I18nUpdateOpCode.IcuSwitch:\n                applyIcuSwitchCase(tView, getTIcu(tView, nodeIndex)!, lView, value);\n                break;\n              case I18nUpdateOpCode.IcuUpdate:\n                applyIcuUpdateCase(tView, getTIcu(tView, nodeIndex)!, bindingsStartIndex, lView);\n                break;\n            }\n          }\n        }\n      }\n    } else {\n      const opCode = updateOpCodes[i + 1] as number;\n      if (opCode > 0 && (opCode & I18nUpdateOpCode.MASK_OPCODE) === I18nUpdateOpCode.IcuUpdate) {\n        // Special case for the `icuUpdateCase`. It could be that the mask did not match, but\n        // we still need to execute `icuUpdateCase` because the case has changed recently due to\n        // previous `icuSwitchCase` instruction. (`icuSwitchCase` and `icuUpdateCase` always come in\n        // pairs.)\n        const nodeIndex = (opCode >>> I18nUpdateOpCode.SHIFT_REF);\n        const tIcu = getTIcu(tView, nodeIndex)!;\n        const currentIndex = lView[tIcu.currentCaseLViewIndex];\n        if (currentIndex < 0) {\n          applyIcuUpdateCase(tView, tIcu, bindingsStartIndex, lView);\n        }\n      }\n    }\n    i += skipCodes;\n  }\n}\n\n/**\n * Apply OpCodes associated with updating an existing ICU.\n *\n * @param tView Current `TView`\n * @param tIcu Current `TIcu`\n * @param bindingsStartIndex Location of the first `i18nApply`\n * @param lView Current `LView`\n */\nfunction applyIcuUpdateCase(tView: TView, tIcu: TIcu, bindingsStartIndex: number, lView: LView) {\n  ngDevMode && assertIndexInRange(lView, tIcu.currentCaseLViewIndex);\n  let activeCaseIndex = lView[tIcu.currentCaseLViewIndex];\n  if (activeCaseIndex !== null) {\n    let mask = changeMask;\n    if (activeCaseIndex < 0) {\n      // Clear the flag.\n      // Negative number means that the ICU was freshly created and we need to force the update.\n      activeCaseIndex = lView[tIcu.currentCaseLViewIndex] = ~activeCaseIndex;\n      // -1 is same as all bits on, which simulates creation since it marks all bits dirty\n      mask = -1;\n    }\n    applyUpdateOpCodes(tView, lView, tIcu.update[activeCaseIndex], bindingsStartIndex, mask);\n  }\n}\n\n/**\n * Apply OpCodes associated with switching a case on ICU.\n *\n * This involves tearing down existing case and than building up a new case.\n *\n * @param tView Current `TView`\n * @param tIcu Current `TIcu`\n * @param lView Current `LView`\n * @param value Value of the case to update to.\n */\nfunction applyIcuSwitchCase(tView: TView, tIcu: TIcu, lView: LView, value: string) {\n  // Rebuild a new case for this ICU\n  const caseIndex = getCaseIndex(tIcu, value);\n  let activeCaseIndex = getCurrentICUCaseIndex(tIcu, lView);\n  if (activeCaseIndex !== caseIndex) {\n    applyIcuSwitchCaseRemove(tView, tIcu, lView);\n    lView[tIcu.currentCaseLViewIndex] = caseIndex === null ? null : ~caseIndex;\n    if (caseIndex !== null) {\n      // Add the nodes for the new case\n      const anchorRNode = lView[tIcu.anchorIdx];\n      if (anchorRNode) {\n        ngDevMode && assertDomNode(anchorRNode);\n        applyMutableOpCodes(tView, tIcu.create[caseIndex], lView, anchorRNode);\n      }\n    }\n  }\n}\n\n/**\n * Apply OpCodes associated with tearing ICU case.\n *\n * This involves tearing down existing case and than building up a new case.\n *\n * @param tView Current `TView`\n * @param tIcu Current `TIcu`\n * @param lView Current `LView`\n */\nfunction applyIcuSwitchCaseRemove(tView: TView, tIcu: TIcu, lView: LView) {\n  let activeCaseIndex = getCurrentICUCaseIndex(tIcu, lView);\n  if (activeCaseIndex !== null) {\n    const removeCodes = tIcu.remove[activeCaseIndex];\n    for (let i = 0; i < removeCodes.length; i++) {\n      const nodeOrIcuIndex = removeCodes[i] as number;\n      if (nodeOrIcuIndex > 0) {\n        // Positive numbers are `RNode`s.\n        const rNode = getNativeByIndex(nodeOrIcuIndex, lView);\n        rNode !== null && nativeRemoveNode(lView[RENDERER], rNode);\n      } else {\n        // Negative numbers are ICUs\n        applyIcuSwitchCaseRemove(tView, getTIcu(tView, ~nodeOrIcuIndex)!, lView);\n      }\n    }\n  }\n}\n\n\n/**\n * Returns the index of the current case of an ICU expression depending on the main binding value\n *\n * @param icuExpression\n * @param bindingValue The value of the main binding used by this ICU expression\n */\nfunction getCaseIndex(icuExpression: TIcu, bindingValue: string): number|null {\n  let index = icuExpression.cases.indexOf(bindingValue);\n  if (index === -1) {\n    switch (icuExpression.type) {\n      case IcuType.plural: {\n        const resolvedCase = getPluralCase(bindingValue, getLocaleId());\n        index = icuExpression.cases.indexOf(resolvedCase);\n        if (index === -1 && resolvedCase !== 'other') {\n          index = icuExpression.cases.indexOf('other');\n        }\n        break;\n      }\n      case IcuType.select: {\n        index = icuExpression.cases.indexOf('other');\n        break;\n      }\n    }\n  }\n  return index === -1 ? null : index;\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {assertDomNode, assertNumber, assertNumberInRange} from '../../util/assert';\nimport {EMPTY_ARRAY} from '../../util/empty';\nimport {assertTIcu, assertTNodeForLView} from '../assert';\nimport {getCurrentICUCaseIndex} from '../i18n/i18n_util';\nimport {I18nRemoveOpCodes, TIcu} from '../interfaces/i18n';\nimport {TIcuContainerNode} from '../interfaces/node';\nimport {RNode} from '../interfaces/renderer_dom';\nimport {LView, TVIEW} from '../interfaces/view';\n\nexport function loadIcuContainerVisitor() {\n  const _stack: any[] = [];\n  let _index: number = -1;\n  let _lView: LView;\n  let _removes: I18nRemoveOpCodes;\n\n  /**\n   * Retrieves a set of root nodes from `TIcu.remove`. Used by `TNodeType.ICUContainer`\n   * to determine which root belong to the ICU.\n   *\n   * Example of usage.\n   * ```\n   * const nextRNode = icuContainerIteratorStart(tIcuContainerNode, lView);\n   * let rNode: RNode|null;\n   * while(rNode = nextRNode()) {\n   *   console.log(rNode);\n   * }\n   * ```\n   *\n   * @param tIcuContainerNode Current `TIcuContainerNode`\n   * @param lView `LView` where the `RNode`s should be looked up.\n   */\n  function icuContainerIteratorStart(tIcuContainerNode: TIcuContainerNode, lView: LView): () =>\n      RNode | null {\n    _lView = lView;\n    while (_stack.length) _stack.pop();\n    ngDevMode && assertTNodeForLView(tIcuContainerNode, lView);\n    enterIcu(tIcuContainerNode.value, lView);\n    return icuContainerIteratorNext;\n  }\n\n  function enterIcu(tIcu: TIcu, lView: LView) {\n    _index = 0;\n    const currentCase = getCurrentICUCaseIndex(tIcu, lView);\n    if (currentCase !== null) {\n      ngDevMode && assertNumberInRange(currentCase, 0, tIcu.cases.length - 1);\n      _removes = tIcu.remove[currentCase];\n    } else {\n      _removes = EMPTY_ARRAY as any;\n    }\n  }\n\n\n  function icuContainerIteratorNext(): RNode|null {\n    if (_index < _removes.length) {\n      const removeOpCode = _removes[_index++] as number;\n      ngDevMode && assertNumber(removeOpCode, 'Expecting OpCode number');\n      if (removeOpCode > 0) {\n        const rNode = _lView[removeOpCode];\n        ngDevMode && assertDomNode(rNode);\n        return rNode;\n      } else {\n        _stack.push(_index, _removes);\n        // ICUs are represented by negative indices\n        const tIcuIndex = ~removeOpCode;\n        const tIcu = _lView[TVIEW].data[tIcuIndex] as TIcu;\n        ngDevMode && assertTIcu(tIcu);\n        enterIcu(tIcu, _lView);\n        return icuContainerIteratorNext();\n      }\n    } else {\n      if (_stack.length === 0) {\n        return null;\n      } else {\n        _removes = _stack.pop();\n        _index = _stack.pop();\n        return icuContainerIteratorNext();\n      }\n    }\n  }\n\n  return icuContainerIteratorStart;\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport '../../util/ng_dev_mode';\nimport '../../util/ng_i18n_closure_mode';\n\nimport {XSS_SECURITY_URL} from '../../error_details_base_url';\nimport {getTemplateContent, URI_ATTRS, VALID_ATTRS, VALID_ELEMENTS} from '../../sanitization/html_sanitizer';\nimport {getInertBodyHelper} from '../../sanitization/inert_body';\nimport {_sanitizeUrl} from '../../sanitization/url_sanitizer';\nimport {assertDefined, assertEqual, assertGreaterThanOrEqual, assertOneOf, assertString} from '../../util/assert';\nimport {CharCode} from '../../util/char_code';\nimport {loadIcuContainerVisitor} from '../instructions/i18n_icu_container_visitor';\nimport {allocExpando, createTNodeAtIndex} from '../instructions/shared';\nimport {getDocument} from '../interfaces/document';\nimport {ELEMENT_MARKER, I18nCreateOpCode, I18nCreateOpCodes, I18nRemoveOpCodes, I18nUpdateOpCode, I18nUpdateOpCodes, ICU_MARKER, IcuCreateOpCode, IcuCreateOpCodes, IcuExpression, IcuType, TI18n, TIcu} from '../interfaces/i18n';\nimport {TNode, TNodeType} from '../interfaces/node';\nimport {SanitizerFn} from '../interfaces/sanitization';\nimport {HEADER_OFFSET, LView, TView} from '../interfaces/view';\nimport {getCurrentParentTNode, getCurrentTNode, setCurrentTNode} from '../state';\n\nimport {i18nCreateOpCodesToString, i18nRemoveOpCodesToString, i18nUpdateOpCodesToString, icuCreateOpCodesToString} from './i18n_debug';\nimport {addTNodeAndUpdateInsertBeforeIndex} from './i18n_insert_before_index';\nimport {ensureIcuContainerVisitorLoaded} from './i18n_tree_shaking';\nimport {createTNodePlaceholder, icuCreateOpCode, setTIcu, setTNodeInsertBeforeIndex} from './i18n_util';\n\n\n\nconst BINDING_REGEXP = /(\\d+):?\\d*/gi;\nconst ICU_REGEXP = /({\\s*\\d+:?\\d*\\s*,\\s*\\S{6}\\s*,[\\s\\S]*})/gi;\nconst NESTED_ICU = /(\\d+)/;\nconst ICU_BLOCK_REGEXP = /^\\s*(\\d+:?\\d*)\\s*,\\s*(select|plural)\\s*,/;\n\nconst MARKER = ``;\nconst SUBTEMPLATE_REGEXP = /\\/?\\*(\\d+:\\d+)/gi;\nconst PH_REGEXP = /(\\/?[#*]\\d+):?\\d*/gi;\n\n/**\n * Angular uses the special entity &ngsp; as a placeholder for non-removable space.\n * It's replaced by the 0xE500 PUA (Private Use Areas) unicode character and later on replaced by a\n * space.\n * We are re-implementing the same idea since translations might contain this special character.\n */\nconst NGSP_UNICODE_REGEXP = /\\uE500/g;\nfunction replaceNgsp(value: string): string {\n  return value.replace(NGSP_UNICODE_REGEXP, ' ');\n}\n\n/**\n * Patch a `debug` property getter on top of the existing object.\n *\n * NOTE: always call this method with `ngDevMode && attachDebugObject(...)`\n *\n * @param obj Object to patch\n * @param debugGetter Getter returning a value to patch\n */\nfunction attachDebugGetter<T>(obj: T, debugGetter: (this: T) => any): void {\n  if (ngDevMode) {\n    Object.defineProperty(obj, 'debug', {get: debugGetter, enumerable: false});\n  } else {\n    throw new Error(\n        'This method should be guarded with `ngDevMode` so that it can be tree shaken in production!');\n  }\n}\n\n/**\n * Create dynamic nodes from i18n translation block.\n *\n * - Text nodes are created synchronously\n * - TNodes are linked into tree lazily\n *\n * @param tView Current `TView`\n * @parentTNodeIndex index to the parent TNode of this i18n block\n * @param lView Current `LView`\n * @param index Index of `i18nStart` instruction.\n * @param message Message to translate.\n * @param subTemplateIndex Index into the sub template of message translation. (ie in case of\n *     `ngIf`) (-1 otherwise)\n */\nexport function i18nStartFirstCreatePass(\n    tView: TView, parentTNodeIndex: number, lView: LView, index: number, message: string,\n    subTemplateIndex: number) {\n  const rootTNode = getCurrentParentTNode();\n  const createOpCodes: I18nCreateOpCodes = [] as any;\n  const updateOpCodes: I18nUpdateOpCodes = [] as any;\n  const existingTNodeStack: TNode[][] = [[]];\n  if (ngDevMode) {\n    attachDebugGetter(createOpCodes, i18nCreateOpCodesToString);\n    attachDebugGetter(updateOpCodes, i18nUpdateOpCodesToString);\n  }\n\n  message = getTranslationForTemplate(message, subTemplateIndex);\n  const msgParts = replaceNgsp(message).split(PH_REGEXP);\n  for (let i = 0; i < msgParts.length; i++) {\n    let value = msgParts[i];\n    if ((i & 1) === 0) {\n      // Even indexes are text (including bindings & ICU expressions)\n      const parts = i18nParseTextIntoPartsAndICU(value);\n      for (let j = 0; j < parts.length; j++) {\n        let part = parts[j];\n        if ((j & 1) === 0) {\n          // `j` is odd therefore `part` is string\n          const text = part as string;\n          ngDevMode && assertString(text, 'Parsed ICU part should be string');\n          if (text !== '') {\n            i18nStartFirstCreatePassProcessTextNode(\n                tView, rootTNode, existingTNodeStack[0], createOpCodes, updateOpCodes, lView, text);\n          }\n        } else {\n          // `j` is Even therefor `part` is an `ICUExpression`\n          const icuExpression: IcuExpression = part as IcuExpression;\n          // Verify that ICU expression has the right shape. Translations might contain invalid\n          // constructions (while original messages were correct), so ICU parsing at runtime may\n          // not succeed (thus `icuExpression` remains a string).\n          // Note: we intentionally retain the error here by not using `ngDevMode`, because\n          // the value can change based on the locale and users aren't guaranteed to hit\n          // an invalid string while they're developing.\n          if (typeof icuExpression !== 'object') {\n            throw new Error(`Unable to parse ICU expression in \"${message}\" message.`);\n          }\n          const icuContainerTNode = createTNodeAndAddOpCode(\n              tView, rootTNode, existingTNodeStack[0], lView, createOpCodes,\n              ngDevMode ? `ICU ${index}:${icuExpression.mainBinding}` : '', true);\n          const icuNodeIndex = icuContainerTNode.index;\n          ngDevMode &&\n              assertGreaterThanOrEqual(\n                  icuNodeIndex, HEADER_OFFSET, 'Index must be in absolute LView offset');\n          icuStart(tView, lView, updateOpCodes, parentTNodeIndex, icuExpression, icuNodeIndex);\n        }\n      }\n    } else {\n      // Odd indexes are placeholders (elements and sub-templates)\n      // At this point value is something like: '/#1:2' (originally coming from '/#1:2')\n      const isClosing = value.charCodeAt(0) === CharCode.SLASH;\n      const type = value.charCodeAt(isClosing ? 1 : 0);\n      ngDevMode && assertOneOf(type, CharCode.STAR, CharCode.HASH);\n      const index = HEADER_OFFSET + Number.parseInt(value.substring((isClosing ? 2 : 1)));\n      if (isClosing) {\n        existingTNodeStack.shift();\n        setCurrentTNode(getCurrentParentTNode()!, false);\n      } else {\n        const tNode = createTNodePlaceholder(tView, existingTNodeStack[0], index);\n        existingTNodeStack.unshift([]);\n        setCurrentTNode(tNode, true);\n      }\n    }\n  }\n\n  tView.data[index] = <TI18n>{\n    create: createOpCodes,\n    update: updateOpCodes,\n  };\n}\n\n/**\n * Allocate space in i18n Range add create OpCode instruction to create a text or comment node.\n *\n * @param tView Current `TView` needed to allocate space in i18n range.\n * @param rootTNode Root `TNode` of the i18n block. This node determines if the new TNode will be\n *     added as part of the `i18nStart` instruction or as part of the `TNode.insertBeforeIndex`.\n * @param existingTNodes internal state for `addTNodeAndUpdateInsertBeforeIndex`.\n * @param lView Current `LView` needed to allocate space in i18n range.\n * @param createOpCodes Array storing `I18nCreateOpCodes` where new opCodes will be added.\n * @param text Text to be added when the `Text` or `Comment` node will be created.\n * @param isICU true if a `Comment` node for ICU (instead of `Text`) node should be created.\n */\nfunction createTNodeAndAddOpCode(\n    tView: TView, rootTNode: TNode|null, existingTNodes: TNode[], lView: LView,\n    createOpCodes: I18nCreateOpCodes, text: string|null, isICU: boolean): TNode {\n  const i18nNodeIdx = allocExpando(tView, lView, 1, null);\n  let opCode = i18nNodeIdx << I18nCreateOpCode.SHIFT;\n  let parentTNode = getCurrentParentTNode();\n\n  if (rootTNode === parentTNode) {\n    // FIXME(misko): A null `parentTNode` should represent when we fall of the `LView` boundary.\n    // (there is no parent), but in some circumstances (because we are inconsistent about how we set\n    // `previousOrParentTNode`) it could point to `rootTNode` So this is a work around.\n    parentTNode = null;\n  }\n  if (parentTNode === null) {\n    // If we don't have a parent that means that we can eagerly add nodes.\n    // If we have a parent than these nodes can't be added now (as the parent has not been created\n    // yet) and instead the `parentTNode` is responsible for adding it. See\n    // `TNode.insertBeforeIndex`\n    opCode |= I18nCreateOpCode.APPEND_EAGERLY;\n  }\n  if (isICU) {\n    opCode |= I18nCreateOpCode.COMMENT;\n    ensureIcuContainerVisitorLoaded(loadIcuContainerVisitor);\n  }\n  createOpCodes.push(opCode, text === null ? '' : text);\n  // We store `{{?}}` so that when looking at debug `TNodeType.template` we can see where the\n  // bindings are.\n  const tNode = createTNodeAtIndex(\n      tView, i18nNodeIdx, isICU ? TNodeType.Icu : TNodeType.Text,\n      text === null ? (ngDevMode ? '{{?}}' : '') : text, null);\n  addTNodeAndUpdateInsertBeforeIndex(existingTNodes, tNode);\n  const tNodeIdx = tNode.index;\n  setCurrentTNode(tNode, false /* Text nodes are self closing */);\n  if (parentTNode !== null && rootTNode !== parentTNode) {\n    // We are a child of deeper node (rather than a direct child of `i18nStart` instruction.)\n    // We have to make sure to add ourselves to the parent.\n    setTNodeInsertBeforeIndex(parentTNode, tNodeIdx);\n  }\n  return tNode;\n}\n\n/**\n * Processes text node in i18n block.\n *\n * Text nodes can have:\n * - Create instruction in `createOpCodes` for creating the text node.\n * - Allocate spec for text node in i18n range of `LView`\n * - If contains binding:\n *    - bindings => allocate space in i18n range of `LView` to store the binding value.\n *    - populate `updateOpCodes` with update instructions.\n *\n * @param tView Current `TView`\n * @param rootTNode Root `TNode` of the i18n block. This node determines if the new TNode will\n *     be added as part of the `i18nStart` instruction or as part of the\n *     `TNode.insertBeforeIndex`.\n * @param existingTNodes internal state for `addTNodeAndUpdateInsertBeforeIndex`.\n * @param createOpCodes Location where the creation OpCodes will be stored.\n * @param lView Current `LView`\n * @param text The translated text (which may contain binding)\n */\nfunction i18nStartFirstCreatePassProcessTextNode(\n    tView: TView, rootTNode: TNode|null, existingTNodes: TNode[], createOpCodes: I18nCreateOpCodes,\n    updateOpCodes: I18nUpdateOpCodes, lView: LView, text: string): void {\n  const hasBinding = text.match(BINDING_REGEXP);\n  const tNode = createTNodeAndAddOpCode(\n      tView, rootTNode, existingTNodes, lView, createOpCodes, hasBinding ? null : text, false);\n  if (hasBinding) {\n    generateBindingUpdateOpCodes(updateOpCodes, text, tNode.index, null, 0, null);\n  }\n}\n\n/**\n * See `i18nAttributes` above.\n */\nexport function i18nAttributesFirstPass(tView: TView, index: number, values: string[]) {\n  const previousElement = getCurrentTNode()!;\n  const previousElementIndex = previousElement.index;\n  const updateOpCodes: I18nUpdateOpCodes = [] as any;\n  if (ngDevMode) {\n    attachDebugGetter(updateOpCodes, i18nUpdateOpCodesToString);\n  }\n  if (tView.firstCreatePass && tView.data[index] === null) {\n    for (let i = 0; i < values.length; i += 2) {\n      const attrName = values[i];\n      const message = values[i + 1];\n\n      if (message !== '') {\n        // Check if attribute value contains an ICU and throw an error if that's the case.\n        // ICUs in element attributes are not supported.\n        // Note: we intentionally retain the error here by not using `ngDevMode`, because\n        // the `value` can change based on the locale and users aren't guaranteed to hit\n        // an invalid string while they're developing.\n        if (ICU_REGEXP.test(message)) {\n          throw new Error(\n              `ICU expressions are not supported in attributes. Message: \"${message}\".`);\n        }\n\n        // i18n attributes that hit this code path are guaranteed to have bindings, because\n        // the compiler treats static i18n attributes as regular attribute bindings.\n        // Since this may not be the first i18n attribute on this element we need to pass in how\n        // many previous bindings there have already been.\n        generateBindingUpdateOpCodes(\n            updateOpCodes, message, previousElementIndex, attrName, countBindings(updateOpCodes),\n            null);\n      }\n    }\n    tView.data[index] = updateOpCodes;\n  }\n}\n\n\n/**\n * Generate the OpCodes to update the bindings of a string.\n *\n * @param updateOpCodes Place where the update opcodes will be stored.\n * @param str The string containing the bindings.\n * @param destinationNode Index of the destination node which will receive the binding.\n * @param attrName Name of the attribute, if the string belongs to an attribute.\n * @param sanitizeFn Sanitization function used to sanitize the string after update, if necessary.\n * @param bindingStart The lView index of the next expression that can be bound via an opCode.\n * @returns The mask value for these bindings\n */\nfunction generateBindingUpdateOpCodes(\n    updateOpCodes: I18nUpdateOpCodes, str: string, destinationNode: number, attrName: string|null,\n    bindingStart: number, sanitizeFn: SanitizerFn|null): number {\n  ngDevMode &&\n      assertGreaterThanOrEqual(\n          destinationNode, HEADER_OFFSET, 'Index must be in absolute LView offset');\n  const maskIndex = updateOpCodes.length;  // Location of mask\n  const sizeIndex = maskIndex + 1;         // location of size for skipping\n  updateOpCodes.push(null, null);          // Alloc space for mask and size\n  const startIndex = maskIndex + 2;        // location of first allocation.\n  if (ngDevMode) {\n    attachDebugGetter(updateOpCodes, i18nUpdateOpCodesToString);\n  }\n  const textParts = str.split(BINDING_REGEXP);\n  let mask = 0;\n\n  for (let j = 0; j < textParts.length; j++) {\n    const textValue = textParts[j];\n\n    if (j & 1) {\n      // Odd indexes are bindings\n      const bindingIndex = bindingStart + parseInt(textValue, 10);\n      updateOpCodes.push(-1 - bindingIndex);\n      mask = mask | toMaskBit(bindingIndex);\n    } else if (textValue !== '') {\n      // Even indexes are text\n      updateOpCodes.push(textValue);\n    }\n  }\n\n  updateOpCodes.push(\n      destinationNode << I18nUpdateOpCode.SHIFT_REF |\n      (attrName ? I18nUpdateOpCode.Attr : I18nUpdateOpCode.Text));\n  if (attrName) {\n    updateOpCodes.push(attrName, sanitizeFn);\n  }\n  updateOpCodes[maskIndex] = mask;\n  updateOpCodes[sizeIndex] = updateOpCodes.length - startIndex;\n  return mask;\n}\n\n/**\n * Count the number of bindings in the given `opCodes`.\n *\n * It could be possible to speed this up, by passing the number of bindings found back from\n * `generateBindingUpdateOpCodes()` to `i18nAttributesFirstPass()` but this would then require more\n * complexity in the code and/or transient objects to be created.\n *\n * Since this function is only called once when the template is instantiated, is trivial in the\n * first instance (since `opCodes` will be an empty array), and it is not common for elements to\n * contain multiple i18n bound attributes, it seems like this is a reasonable compromise.\n */\nfunction countBindings(opCodes: I18nUpdateOpCodes): number {\n  let count = 0;\n  for (let i = 0; i < opCodes.length; i++) {\n    const opCode = opCodes[i];\n    // Bindings are negative numbers.\n    if (typeof opCode === 'number' && opCode < 0) {\n      count++;\n    }\n  }\n  return count;\n}\n\n/**\n * Convert binding index to mask bit.\n *\n * Each index represents a single bit on the bit-mask. Because bit-mask only has 32 bits, we make\n * the 32nd bit share all masks for all bindings higher than 32. Since it is extremely rare to\n * have more than 32 bindings this will be hit very rarely. The downside of hitting this corner\n * case is that we will execute binding code more often than necessary. (penalty of performance)\n */\nfunction toMaskBit(bindingIndex: number): number {\n  return 1 << Math.min(bindingIndex, 31);\n}\n\nexport function isRootTemplateMessage(subTemplateIndex: number): subTemplateIndex is - 1 {\n  return subTemplateIndex === -1;\n}\n\n\n/**\n * Removes everything inside the sub-templates of a message.\n */\nfunction removeInnerTemplateTranslation(message: string): string {\n  let match;\n  let res = '';\n  let index = 0;\n  let inTemplate = false;\n  let tagMatched;\n\n  while ((match = SUBTEMPLATE_REGEXP.exec(message)) !== null) {\n    if (!inTemplate) {\n      res += message.substring(index, match.index + match[0].length);\n      tagMatched = match[1];\n      inTemplate = true;\n    } else {\n      if (match[0] === `${MARKER}/*${tagMatched}${MARKER}`) {\n        index = match.index;\n        inTemplate = false;\n      }\n    }\n  }\n\n  ngDevMode &&\n      assertEqual(\n          inTemplate, false,\n          `Tag mismatch: unable to find the end of the sub-template in the translation \"${\n              message}\"`);\n\n  res += message.slice(index);\n  return res;\n}\n\n\n/**\n * Extracts a part of a message and removes the rest.\n *\n * This method is used for extracting a part of the message associated with a template. A\n * translated message can span multiple templates.\n *\n * Example:\n * ```\n * <div i18n>Translate <span *ngIf>me</span>!</div>\n * ```\n *\n * @param message The message to crop\n * @param subTemplateIndex Index of the sub-template to extract. If undefined it returns the\n * external template and removes all sub-templates.\n */\nexport function getTranslationForTemplate(message: string, subTemplateIndex: number) {\n  if (isRootTemplateMessage(subTemplateIndex)) {\n    // We want the root template message, ignore all sub-templates\n    return removeInnerTemplateTranslation(message);\n  } else {\n    // We want a specific sub-template\n    const start =\n        message.indexOf(`:${subTemplateIndex}${MARKER}`) + 2 + subTemplateIndex.toString().length;\n    const end = message.search(new RegExp(`${MARKER}\\\\/\\\\*\\\\d+:${subTemplateIndex}${MARKER}`));\n    return removeInnerTemplateTranslation(message.substring(start, end));\n  }\n}\n\n/**\n * Generate the OpCodes for ICU expressions.\n *\n * @param icuExpression\n * @param index Index where the anchor is stored and an optional `TIcuContainerNode`\n *   - `lView[anchorIdx]` points to a `Comment` node representing the anchor for the ICU.\n *   - `tView.data[anchorIdx]` points to the `TIcuContainerNode` if ICU is root (`null` otherwise)\n */\nexport function icuStart(\n    tView: TView, lView: LView, updateOpCodes: I18nUpdateOpCodes, parentIdx: number,\n    icuExpression: IcuExpression, anchorIdx: number) {\n  ngDevMode && assertDefined(icuExpression, 'ICU expression must be defined');\n  let bindingMask = 0;\n  const tIcu: TIcu = {\n    type: icuExpression.type,\n    currentCaseLViewIndex: allocExpando(tView, lView, 1, null),\n    anchorIdx,\n    cases: [],\n    create: [],\n    remove: [],\n    update: []\n  };\n  addUpdateIcuSwitch(updateOpCodes, icuExpression, anchorIdx);\n  setTIcu(tView, anchorIdx, tIcu);\n  const values = icuExpression.values;\n  for (let i = 0; i < values.length; i++) {\n    // Each value is an array of strings & other ICU expressions\n    const valueArr = values[i];\n    const nestedIcus: IcuExpression[] = [];\n    for (let j = 0; j < valueArr.length; j++) {\n      const value = valueArr[j];\n      if (typeof value !== 'string') {\n        // It is an nested ICU expression\n        const icuIndex = nestedIcus.push(value as IcuExpression) - 1;\n        // Replace nested ICU expression by a comment node\n        valueArr[j] = `<!--${icuIndex}-->`;\n      }\n    }\n    bindingMask = parseIcuCase(\n                      tView, tIcu, lView, updateOpCodes, parentIdx, icuExpression.cases[i],\n                      valueArr.join(''), nestedIcus) |\n        bindingMask;\n  }\n  if (bindingMask) {\n    addUpdateIcuUpdate(updateOpCodes, bindingMask, anchorIdx);\n  }\n}\n\n/**\n * Parses text containing an ICU expression and produces a JSON object for it.\n * Original code from closure library, modified for Angular.\n *\n * @param pattern Text containing an ICU expression that needs to be parsed.\n *\n */\nexport function parseICUBlock(pattern: string): IcuExpression {\n  const cases = [];\n  const values: (string|IcuExpression)[][] = [];\n  let icuType = IcuType.plural;\n  let mainBinding = 0;\n  pattern = pattern.replace(ICU_BLOCK_REGEXP, function(str: string, binding: string, type: string) {\n    if (type === 'select') {\n      icuType = IcuType.select;\n    } else {\n      icuType = IcuType.plural;\n    }\n    mainBinding = parseInt(binding.slice(1), 10);\n    return '';\n  });\n\n  const parts = i18nParseTextIntoPartsAndICU(pattern) as string[];\n  // Looking for (key block)+ sequence. One of the keys has to be \"other\".\n  for (let pos = 0; pos < parts.length;) {\n    let key = parts[pos++].trim();\n    if (icuType === IcuType.plural) {\n      // Key can be \"=x\", we just want \"x\"\n      key = key.replace(/\\s*(?:=)?(\\w+)\\s*/, '$1');\n    }\n    if (key.length) {\n      cases.push(key);\n    }\n\n    const blocks = i18nParseTextIntoPartsAndICU(parts[pos++]) as string[];\n    if (cases.length > values.length) {\n      values.push(blocks);\n    }\n  }\n\n  // TODO(ocombe): support ICU expressions in attributes, see #21615\n  return {type: icuType, mainBinding: mainBinding, cases, values};\n}\n\n\n/**\n * Breaks pattern into strings and top level {...} blocks.\n * Can be used to break a message into text and ICU expressions, or to break an ICU expression\n * into keys and cases. Original code from closure library, modified for Angular.\n *\n * @param pattern (sub)Pattern to be broken.\n * @returns An `Array<string|IcuExpression>` where:\n *   - odd positions: `string` => text between ICU expressions\n *   - even positions: `ICUExpression` => ICU expression parsed into `ICUExpression` record.\n */\nexport function i18nParseTextIntoPartsAndICU(pattern: string): (string|IcuExpression)[] {\n  if (!pattern) {\n    return [];\n  }\n\n  let prevPos = 0;\n  const braceStack = [];\n  const results: (string|IcuExpression)[] = [];\n  const braces = /[{}]/g;\n  // lastIndex doesn't get set to 0 so we have to.\n  braces.lastIndex = 0;\n\n  let match;\n  while (match = braces.exec(pattern)) {\n    const pos = match.index;\n    if (match[0] == '}') {\n      braceStack.pop();\n\n      if (braceStack.length == 0) {\n        // End of the block.\n        const block = pattern.substring(prevPos, pos);\n        if (ICU_BLOCK_REGEXP.test(block)) {\n          results.push(parseICUBlock(block));\n        } else {\n          results.push(block);\n        }\n\n        prevPos = pos + 1;\n      }\n    } else {\n      if (braceStack.length == 0) {\n        const substring = pattern.substring(prevPos, pos);\n        results.push(substring);\n        prevPos = pos + 1;\n      }\n      braceStack.push('{');\n    }\n  }\n\n  const substring = pattern.substring(prevPos);\n  results.push(substring);\n  return results;\n}\n\n\n/**\n * Parses a node, its children and its siblings, and generates the mutate & update OpCodes.\n *\n */\nexport function parseIcuCase(\n    tView: TView, tIcu: TIcu, lView: LView, updateOpCodes: I18nUpdateOpCodes, parentIdx: number,\n    caseName: string, unsafeCaseHtml: string, nestedIcus: IcuExpression[]): number {\n  const create: IcuCreateOpCodes = [] as any;\n  const remove: I18nRemoveOpCodes = [] as any;\n  const update: I18nUpdateOpCodes = [] as any;\n  if (ngDevMode) {\n    attachDebugGetter(create, icuCreateOpCodesToString);\n    attachDebugGetter(remove, i18nRemoveOpCodesToString);\n    attachDebugGetter(update, i18nUpdateOpCodesToString);\n  }\n  tIcu.cases.push(caseName);\n  tIcu.create.push(create);\n  tIcu.remove.push(remove);\n  tIcu.update.push(update);\n\n  const inertBodyHelper = getInertBodyHelper(getDocument());\n  const inertBodyElement = inertBodyHelper.getInertBodyElement(unsafeCaseHtml);\n  ngDevMode && assertDefined(inertBodyElement, 'Unable to generate inert body element');\n  const inertRootNode = getTemplateContent(inertBodyElement!) as Element || inertBodyElement;\n  if (inertRootNode) {\n    return walkIcuTree(\n        tView, tIcu, lView, updateOpCodes, create, remove, update, inertRootNode, parentIdx,\n        nestedIcus, 0);\n  } else {\n    return 0;\n  }\n}\n\nfunction walkIcuTree(\n    tView: TView, tIcu: TIcu, lView: LView, sharedUpdateOpCodes: I18nUpdateOpCodes,\n    create: IcuCreateOpCodes, remove: I18nRemoveOpCodes, update: I18nUpdateOpCodes,\n    parentNode: Element, parentIdx: number, nestedIcus: IcuExpression[], depth: number): number {\n  let bindingMask = 0;\n  let currentNode = parentNode.firstChild;\n  while (currentNode) {\n    const newIndex = allocExpando(tView, lView, 1, null);\n    switch (currentNode.nodeType) {\n      case Node.ELEMENT_NODE:\n        const element = currentNode as Element;\n        const tagName = element.tagName.toLowerCase();\n        if (VALID_ELEMENTS.hasOwnProperty(tagName)) {\n          addCreateNodeAndAppend(create, ELEMENT_MARKER, tagName, parentIdx, newIndex);\n          tView.data[newIndex] = tagName;\n          const elAttrs = element.attributes;\n          for (let i = 0; i < elAttrs.length; i++) {\n            const attr = elAttrs.item(i)!;\n            const lowerAttrName = attr.name.toLowerCase();\n            const hasBinding = !!attr.value.match(BINDING_REGEXP);\n            // we assume the input string is safe, unless it's using a binding\n            if (hasBinding) {\n              if (VALID_ATTRS.hasOwnProperty(lowerAttrName)) {\n                if (URI_ATTRS[lowerAttrName]) {\n                  generateBindingUpdateOpCodes(\n                      update, attr.value, newIndex, attr.name, 0, _sanitizeUrl);\n                } else {\n                  generateBindingUpdateOpCodes(update, attr.value, newIndex, attr.name, 0, null);\n                }\n              } else {\n                ngDevMode &&\n                    console.warn(\n                        `WARNING: ignoring unsafe attribute value ` +\n                        `${lowerAttrName} on element ${tagName} ` +\n                        `(see ${XSS_SECURITY_URL})`);\n              }\n            } else {\n              addCreateAttribute(create, newIndex, attr);\n            }\n          }\n          // Parse the children of this node (if any)\n          bindingMask = walkIcuTree(\n                            tView, tIcu, lView, sharedUpdateOpCodes, create, remove, update,\n                            currentNode as Element, newIndex, nestedIcus, depth + 1) |\n              bindingMask;\n          addRemoveNode(remove, newIndex, depth);\n        }\n        break;\n      case Node.TEXT_NODE:\n        const value = currentNode.textContent || '';\n        const hasBinding = value.match(BINDING_REGEXP);\n        addCreateNodeAndAppend(create, null, hasBinding ? '' : value, parentIdx, newIndex);\n        addRemoveNode(remove, newIndex, depth);\n        if (hasBinding) {\n          bindingMask =\n              generateBindingUpdateOpCodes(update, value, newIndex, null, 0, null) | bindingMask;\n        }\n        break;\n      case Node.COMMENT_NODE:\n        // Check if the comment node is a placeholder for a nested ICU\n        const isNestedIcu = NESTED_ICU.exec(currentNode.textContent || '');\n        if (isNestedIcu) {\n          const nestedIcuIndex = parseInt(isNestedIcu[1], 10);\n          const icuExpression: IcuExpression = nestedIcus[nestedIcuIndex];\n          // Create the comment node that will anchor the ICU expression\n          addCreateNodeAndAppend(\n              create, ICU_MARKER, ngDevMode ? `nested ICU ${nestedIcuIndex}` : '', parentIdx,\n              newIndex);\n          icuStart(tView, lView, sharedUpdateOpCodes, parentIdx, icuExpression, newIndex);\n          addRemoveNestedIcu(remove, newIndex, depth);\n        }\n        break;\n    }\n    currentNode = currentNode.nextSibling;\n  }\n  return bindingMask;\n}\n\nfunction addRemoveNode(remove: I18nRemoveOpCodes, index: number, depth: number) {\n  if (depth === 0) {\n    remove.push(index);\n  }\n}\n\nfunction addRemoveNestedIcu(remove: I18nRemoveOpCodes, index: number, depth: number) {\n  if (depth === 0) {\n    remove.push(~index);  // remove ICU at `index`\n    remove.push(index);   // remove ICU comment at `index`\n  }\n}\n\nfunction addUpdateIcuSwitch(\n    update: I18nUpdateOpCodes, icuExpression: IcuExpression, index: number) {\n  update.push(\n      toMaskBit(icuExpression.mainBinding), 2, -1 - icuExpression.mainBinding,\n      index << I18nUpdateOpCode.SHIFT_REF | I18nUpdateOpCode.IcuSwitch);\n}\n\nfunction addUpdateIcuUpdate(update: I18nUpdateOpCodes, bindingMask: number, index: number) {\n  update.push(bindingMask, 1, index << I18nUpdateOpCode.SHIFT_REF | I18nUpdateOpCode.IcuUpdate);\n}\n\nfunction addCreateNodeAndAppend(\n    create: IcuCreateOpCodes, marker: null|ICU_MARKER|ELEMENT_MARKER, text: string,\n    appendToParentIdx: number, createAtIdx: number) {\n  if (marker !== null) {\n    create.push(marker);\n  }\n  create.push(\n      text, createAtIdx,\n      icuCreateOpCode(IcuCreateOpCode.AppendChild, appendToParentIdx, createAtIdx));\n}\n\nfunction addCreateAttribute(create: IcuCreateOpCodes, newIndex: number, attr: Attr) {\n  create.push(newIndex << IcuCreateOpCode.SHIFT_REF | IcuCreateOpCode.Attr, attr.name, attr.value);\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n// i18nPostprocess consts\nconst ROOT_TEMPLATE_ID = 0;\nconst PP_MULTI_VALUE_PLACEHOLDERS_REGEXP = /\\[(.+??)\\]/;\nconst PP_PLACEHOLDERS_REGEXP = /\\[(.+??)\\]|(\\/?\\*\\d+:\\d+)/g;\nconst PP_ICU_VARS_REGEXP = /({\\s*)(VAR_(PLURAL|SELECT)(_\\d+)?)(\\s*,)/g;\nconst PP_ICU_PLACEHOLDERS_REGEXP = /{([A-Z0-9_]+)}/g;\nconst PP_ICUS_REGEXP = /I18N_EXP_(ICU(_\\d+)?)/g;\nconst PP_CLOSE_TEMPLATE_REGEXP = /\\/\\*/;\nconst PP_TEMPLATE_ID_REGEXP = /\\d+\\:(\\d+)/;\n\n// Parsed placeholder structure used in postprocessing (within `i18nPostprocess` function)\n// Contains the following fields: [templateId, isCloseTemplateTag, placeholder]\ntype PostprocessPlaceholder = [number, boolean, string];\n\n\n/**\n * Handles message string post-processing for internationalization.\n *\n * Handles message string post-processing by transforming it from intermediate\n * format (that might contain some markers that we need to replace) to the final\n * form, consumable by i18nStart instruction. Post processing steps include:\n *\n * 1. Resolve all multi-value cases (like [*1:1#2:1|#4:1|5])\n * 2. Replace all ICU vars (like \"VAR_PLURAL\")\n * 3. Replace all placeholders used inside ICUs in a form of {PLACEHOLDER}\n * 4. Replace all ICU references with corresponding values (like ICU_EXP_ICU_1)\n *    in case multiple ICUs have the same placeholder name\n *\n * @param message Raw translation string for post processing\n * @param replacements Set of replacements that should be applied\n *\n * @returns Transformed string that can be consumed by i18nStart instruction\n *\n * @codeGenApi\n */\nexport function i18nPostprocess(\n    message: string, replacements: {[key: string]: (string|string[])} = {}): string {\n  /**\n   * Step 1: resolve all multi-value placeholders like [#5|*1:1#2:1|#4:1]\n   *\n   * Note: due to the way we process nested templates (BFS), multi-value placeholders are typically\n   * grouped by templates, for example: [#5|#6|#1:1|#3:2] where #5 and #6 belong to root\n   * template, #1:1 belong to nested template with index 1 and #1:2 - nested template with index\n   * 3. However in real templates the order might be different: i.e. #1:1 and/or #3:2 may go in\n   * front of #6. The post processing step restores the right order by keeping track of the\n   * template id stack and looks for placeholders that belong to the currently active template.\n   */\n  let result: string = message;\n  if (PP_MULTI_VALUE_PLACEHOLDERS_REGEXP.test(message)) {\n    const matches: {[key: string]: PostprocessPlaceholder[]} = {};\n    const templateIdsStack: number[] = [ROOT_TEMPLATE_ID];\n    result = result.replace(PP_PLACEHOLDERS_REGEXP, (m: any, phs: string, tmpl: string): string => {\n      const content = phs || tmpl;\n      const placeholders: PostprocessPlaceholder[] = matches[content] || [];\n      if (!placeholders.length) {\n        content.split('|').forEach((placeholder: string) => {\n          const match = placeholder.match(PP_TEMPLATE_ID_REGEXP);\n          const templateId = match ? parseInt(match[1], 10) : ROOT_TEMPLATE_ID;\n          const isCloseTemplateTag = PP_CLOSE_TEMPLATE_REGEXP.test(placeholder);\n          placeholders.push([templateId, isCloseTemplateTag, placeholder]);\n        });\n        matches[content] = placeholders;\n      }\n\n      if (!placeholders.length) {\n        throw new Error(`i18n postprocess: unmatched placeholder - ${content}`);\n      }\n\n      const currentTemplateId = templateIdsStack[templateIdsStack.length - 1];\n      let idx = 0;\n      // find placeholder index that matches current template id\n      for (let i = 0; i < placeholders.length; i++) {\n        if (placeholders[i][0] === currentTemplateId) {\n          idx = i;\n          break;\n        }\n      }\n      // update template id stack based on the current tag extracted\n      const [templateId, isCloseTemplateTag, placeholder] = placeholders[idx];\n      if (isCloseTemplateTag) {\n        templateIdsStack.pop();\n      } else if (currentTemplateId !== templateId) {\n        templateIdsStack.push(templateId);\n      }\n      // remove processed tag from the list\n      placeholders.splice(idx, 1);\n      return placeholder;\n    });\n  }\n\n  // return current result if no replacements specified\n  if (!Object.keys(replacements).length) {\n    return result;\n  }\n\n  /**\n   * Step 2: replace all ICU vars (like \"VAR_PLURAL\")\n   */\n  result = result.replace(PP_ICU_VARS_REGEXP, (match, start, key, _type, _idx, end): string => {\n    return replacements.hasOwnProperty(key) ? `${start}${replacements[key]}${end}` : match;\n  });\n\n  /**\n   * Step 3: replace all placeholders used inside ICUs in a form of {PLACEHOLDER}\n   */\n  result = result.replace(PP_ICU_PLACEHOLDERS_REGEXP, (match, key): string => {\n    return replacements.hasOwnProperty(key) ? replacements[key] as string : match;\n  });\n\n  /**\n   * Step 4: replace all ICU references with corresponding values (like ICU_EXP_ICU_1) in case\n   * multiple ICUs have the same placeholder name\n   */\n  result = result.replace(PP_ICUS_REGEXP, (match, key): string => {\n    if (replacements.hasOwnProperty(key)) {\n      const list = replacements[key] as string[];\n      if (!list.length) {\n        throw new Error(`i18n postprocess: unmatched ICU - ${match} with key: ${key}`);\n      }\n      return list.shift()!;\n    }\n    return match;\n  });\n\n  return result;\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport '../../util/ng_dev_mode';\nimport '../../util/ng_i18n_closure_mode';\n\nimport {assertDefined} from '../../util/assert';\nimport {bindingUpdated} from '../bindings';\nimport {applyCreateOpCodes, applyI18n, setMaskBit} from '../i18n/i18n_apply';\nimport {i18nAttributesFirstPass, i18nStartFirstCreatePass} from '../i18n/i18n_parse';\nimport {i18nPostprocess} from '../i18n/i18n_postprocess';\nimport {TI18n} from '../interfaces/i18n';\nimport {TElementNode, TNodeType} from '../interfaces/node';\nimport {DECLARATION_COMPONENT_VIEW, FLAGS, HEADER_OFFSET, LViewFlags, T_HOST, TViewType} from '../interfaces/view';\nimport {getClosestRElement} from '../node_manipulation';\nimport {getCurrentParentTNode, getLView, getTView, nextBindingIndex, setInI18nBlock} from '../state';\nimport {getConstant} from '../util/view_utils';\n\n/**\n * Marks a block of text as translatable.\n *\n * The instructions `i18nStart` and `i18nEnd` mark the translation block in the template.\n * The translation `message` is the value which is locale specific. The translation string may\n * contain placeholders which associate inner elements and sub-templates within the translation.\n *\n * The translation `message` placeholders are:\n * - `{index}(:{block})`: *Binding Placeholder*: Marks a location where an expression will be\n *   interpolated into. The placeholder `index` points to the expression binding index. An optional\n *   `block` that matches the sub-template in which it was declared.\n * - `#{index}(:{block})`/`/#{index}(:{block})`: *Element Placeholder*:  Marks the beginning\n *   and end of DOM element that were embedded in the original translation block. The placeholder\n *   `index` points to the element index in the template instructions set. An optional `block` that\n *   matches the sub-template in which it was declared.\n * - `*{index}:{block}`/`/*{index}:{block}`: *Sub-template Placeholder*: Sub-templates must be\n *   split up and translated separately in each angular template function. The `index` points to the\n *   `template` instruction index. A `block` that matches the sub-template in which it was declared.\n *\n * @param index A unique index of the translation in the static block.\n * @param messageIndex An index of the translation message from the `def.consts` array.\n * @param subTemplateIndex Optional sub-template index in the `message`.\n *\n * @codeGenApi\n */\nexport function i18nStart(\n    index: number, messageIndex: number, subTemplateIndex: number = -1): void {\n  const tView = getTView();\n  const lView = getLView();\n  const adjustedIndex = HEADER_OFFSET + index;\n  ngDevMode && assertDefined(tView, `tView should be defined`);\n  const message = getConstant<string>(tView.consts, messageIndex)!;\n  const parentTNode = getCurrentParentTNode() as TElementNode | null;\n  if (tView.firstCreatePass) {\n    i18nStartFirstCreatePass(\n        tView, parentTNode === null ? 0 : parentTNode.index, lView, adjustedIndex, message,\n        subTemplateIndex);\n  }\n\n  // Set a flag that this LView has i18n blocks.\n  // The flag is later used to determine whether this component should\n  // be hydrated (currently hydration is not supported for i18n blocks).\n  if (tView.type === TViewType.Embedded) {\n    // Annotate host component's LView (not embedded view's LView),\n    // since hydration can be skipped on per-component basis only.\n    const componentLView = lView[DECLARATION_COMPONENT_VIEW];\n    componentLView[FLAGS] |= LViewFlags.HasI18n;\n  } else {\n    lView[FLAGS] |= LViewFlags.HasI18n;\n  }\n\n  const tI18n = tView.data[adjustedIndex] as TI18n;\n  const sameViewParentTNode = parentTNode === lView[T_HOST] ? null : parentTNode;\n  const parentRNode = getClosestRElement(tView, sameViewParentTNode, lView);\n  // If `parentTNode` is an `ElementContainer` than it has `<!--ng-container--->`.\n  // When we do inserts we have to make sure to insert in front of `<!--ng-container--->`.\n  const insertInFrontOf = parentTNode && (parentTNode.type & TNodeType.ElementContainer) ?\n      lView[parentTNode.index] :\n      null;\n  applyCreateOpCodes(lView, tI18n.create, parentRNode, insertInFrontOf);\n  setInI18nBlock(true);\n}\n\n\n\n/**\n * Translates a translation block marked by `i18nStart` and `i18nEnd`. It inserts the text/ICU nodes\n * into the render tree, moves the placeholder nodes and removes the deleted nodes.\n *\n * @codeGenApi\n */\nexport function i18nEnd(): void {\n  setInI18nBlock(false);\n}\n\n/**\n *\n * Use this instruction to create a translation block that doesn't contain any placeholder.\n * It calls both {@link i18nStart} and {@link i18nEnd} in one instruction.\n *\n * The translation `message` is the value which is locale specific. The translation string may\n * contain placeholders which associate inner elements and sub-templates within the translation.\n *\n * The translation `message` placeholders are:\n * - `{index}(:{block})`: *Binding Placeholder*: Marks a location where an expression will be\n *   interpolated into. The placeholder `index` points to the expression binding index. An optional\n *   `block` that matches the sub-template in which it was declared.\n * - `#{index}(:{block})`/`/#{index}(:{block})`: *Element Placeholder*:  Marks the beginning\n *   and end of DOM element that were embedded in the original translation block. The placeholder\n *   `index` points to the element index in the template instructions set. An optional `block` that\n *   matches the sub-template in which it was declared.\n * - `*{index}:{block}`/`/*{index}:{block}`: *Sub-template Placeholder*: Sub-templates must be\n *   split up and translated separately in each angular template function. The `index` points to the\n *   `template` instruction index. A `block` that matches the sub-template in which it was declared.\n *\n * @param index A unique index of the translation in the static block.\n * @param messageIndex An index of the translation message from the `def.consts` array.\n * @param subTemplateIndex Optional sub-template index in the `message`.\n *\n * @codeGenApi\n */\nexport function i18n(index: number, messageIndex: number, subTemplateIndex?: number): void {\n  i18nStart(index, messageIndex, subTemplateIndex);\n  i18nEnd();\n}\n\n/**\n * Marks a list of attributes as translatable.\n *\n * @param index A unique index in the static block\n * @param values\n *\n * @codeGenApi\n */\nexport function i18nAttributes(index: number, attrsIndex: number): void {\n  const tView = getTView();\n  ngDevMode && assertDefined(tView, `tView should be defined`);\n  const attrs = getConstant<string[]>(tView.consts, attrsIndex)!;\n  i18nAttributesFirstPass(tView, index + HEADER_OFFSET, attrs);\n}\n\n\n/**\n * Stores the values of the bindings during each update cycle in order to determine if we need to\n * update the translated nodes.\n *\n * @param value The binding's value\n * @returns This function returns itself so that it may be chained\n * (e.g. `i18nExp(ctx.name)(ctx.title)`)\n *\n * @codeGenApi\n */\nexport function i18nExp<T>(value: T): typeof i18nExp {\n  const lView = getLView();\n  setMaskBit(bindingUpdated(lView, nextBindingIndex(), value));\n  return i18nExp;\n}\n\n/**\n * Updates a translation block or an i18n attribute when the bindings have changed.\n *\n * @param index Index of either {@link i18nStart} (translation block) or {@link i18nAttributes}\n * (i18n attribute) on which it should update the content.\n *\n * @codeGenApi\n */\nexport function i18nApply(index: number) {\n  applyI18n(getTView(), getLView(), index + HEADER_OFFSET);\n}\n\n/**\n * Handles message string post-processing for internationalization.\n *\n * Handles message string post-processing by transforming it from intermediate\n * format (that might contain some markers that we need to replace) to the final\n * form, consumable by i18nStart instruction. Post processing steps include:\n *\n * 1. Resolve all multi-value cases (like [*1:1#2:1|#4:1|5])\n * 2. Replace all ICU vars (like \"VAR_PLURAL\")\n * 3. Replace all placeholders used inside ICUs in a form of {PLACEHOLDER}\n * 4. Replace all ICU references with corresponding values (like ICU_EXP_ICU_1)\n *    in case multiple ICUs have the same placeholder name\n *\n * @param message Raw translation string for post processing\n * @param replacements Set of replacements that should be applied\n *\n * @returns Transformed string that can be consumed by i18nStart instruction\n *\n * @codeGenApi\n */\nexport function i18nPostprocess(\n    message: string, replacements: {[key: string]: (string|string[])} = {}): string {\n  return i18nPostprocess(message, replacements);\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {isForwardRef, resolveForwardRef} from '../di/forward_ref';\nimport {Type} from '../interface/type';\nimport {flatten} from '../util/array_utils';\nimport {noSideEffects} from '../util/closure';\nimport {EMPTY_ARRAY} from '../util/empty';\n\nimport {extractDefListOrFactory, getNgModuleDef} from './definition';\nimport {depsTracker} from './deps_tracker/deps_tracker';\nimport {ComponentDef, ComponentType, NgModuleScopeInfoFromDecorator, RawScopeInfoFromDecorator} from './interfaces/definition';\nimport {isModuleWithProviders} from './jit/util';\n\n/**\n * Generated next to NgModules to monkey-patch directive and pipe references onto a component's\n * definition, when generating a direct reference in the component file would otherwise create an\n * import cycle.\n *\n * See [this explanation](https://hackmd.io/Odw80D0pR6yfsOjg_7XCJg?view) for more details.\n *\n * @codeGenApi\n */\nexport function setComponentScope(\n    type: ComponentType<any>, directives: Type<any>[]|(() => Type<any>[]),\n    pipes: Type<any>[]|(() => Type<any>[])): void {\n  const def = type.cmp as ComponentDef<any>;\n  def.directiveDefs = extractDefListOrFactory(directives, /* pipeDef */ false);\n  def.pipeDefs = extractDefListOrFactory(pipes, /* pipeDef */ true);\n}\n\n/**\n * Adds the module metadata that is necessary to compute the module's transitive scope to an\n * existing module definition.\n *\n * Scope metadata of modules is not used in production builds, so calls to this function can be\n * marked pure to tree-shake it from the bundle, allowing for all referenced declarations\n * to become eligible for tree-shaking as well.\n *\n * @codeGenApi\n */\nexport function setNgModuleScope(type: any, scope: NgModuleScopeInfoFromDecorator): unknown {\n  return noSideEffects(() => {\n    const ngModuleDef = getNgModuleDef(type, true);\n    ngModuleDef.declarations = convertToTypeArray(scope.declarations || EMPTY_ARRAY);\n    ngModuleDef.imports = convertToTypeArray(scope.imports || EMPTY_ARRAY);\n    ngModuleDef.exports = convertToTypeArray(scope.exports || EMPTY_ARRAY);\n\n    if (scope.bootstrap) {\n      // This only happens in local compilation mode.\n      ngModuleDef.bootstrap = convertToTypeArray(scope.bootstrap);\n    }\n\n    depsTracker.registerNgModule(type, scope);\n  });\n}\n\nfunction convertToTypeArray(values: Type<any>[]|(() => Type<any>[])|\n                            RawScopeInfoFromDecorator[]): Type<any>[]|(() => Type<any>[]) {\n  if (typeof values === 'function') {\n    return values;\n  }\n\n  const flattenValues = flatten(values);\n\n  if (flattenValues.some(isForwardRef)) {\n    return () => flattenValues.map(resolveForwardRef).map(maybeUnwrapModuleWithProviders);\n  } else {\n    return flattenValues.map(maybeUnwrapModuleWithProviders);\n  }\n}\n\nfunction maybeUnwrapModuleWithProviders(value: any): Type<any> {\n  return isModuleWithProviders(value) ? value.ngModule : value as Type<any>;\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {forwardRef, resolveForwardRef} from '../../di/forward_ref';\nimport {inject, invalidFactoryDep} from '../../di/injector_compatibility';\nimport {defineInjectable, defineInjector} from '../../di/interface/defs';\nimport {registerNgModuleType} from '../../linker/ng_module_registration';\nimport * as iframe_attrs_validation from '../../sanitization/iframe_attrs_validation';\nimport * as sanitization from '../../sanitization/sanitization';\nimport * as r3 from '../index';\n\n\n/**\n * A mapping of the @angular/core API surface used in generated expressions to the actual symbols.\n *\n * This should be kept up to date with the public exports of @angular/core.\n */\nexport const angularCoreEnv: {[name: string]: Function} =\n    (() => ({\n       'attribute': r3.attribute,\n       'attributeInterpolate1': r3.attributeInterpolate1,\n       'attributeInterpolate2': r3.attributeInterpolate2,\n       'attributeInterpolate3': r3.attributeInterpolate3,\n       'attributeInterpolate4': r3.attributeInterpolate4,\n       'attributeInterpolate5': r3.attributeInterpolate5,\n       'attributeInterpolate6': r3.attributeInterpolate6,\n       'attributeInterpolate7': r3.attributeInterpolate7,\n       'attributeInterpolate8': r3.attributeInterpolate8,\n       'attributeInterpolateV': r3.attributeInterpolateV,\n       'defineComponent': r3.defineComponent,\n       'defineDirective': r3.defineDirective,\n       'defineInjectable': defineInjectable,\n       'defineInjector': defineInjector,\n       'defineNgModule': r3.defineNgModule,\n       'definePipe': r3.definePipe,\n       'directiveInject': r3.directiveInject,\n       'getInheritedFactory': r3.getInheritedFactory,\n       'inject': inject,\n       'injectAttribute': r3.injectAttribute,\n       'invalidFactory': r3.invalidFactory,\n       'invalidFactoryDep': invalidFactoryDep,\n       'templateRefExtractor': r3.templateRefExtractor,\n       'resetView': r3.resetView,\n       'HostDirectivesFeature': r3.HostDirectivesFeature,\n       'NgOnChangesFeature': r3.NgOnChangesFeature,\n       'ProvidersFeature': r3.ProvidersFeature,\n       'CopyDefinitionFeature': r3.CopyDefinitionFeature,\n       'InheritDefinitionFeature': r3.InheritDefinitionFeature,\n       'InputTransformsFeature': r3.InputTransformsFeature,\n       'StandaloneFeature': r3.StandaloneFeature,\n       'nextContext': r3.nextContext,\n       'namespaceHTML': r3.namespaceHTML,\n       'namespaceMathML': r3.namespaceMathML,\n       'namespaceSVG': r3.namespaceSVG,\n       'enableBindings': r3.enableBindings,\n       'disableBindings': r3.disableBindings,\n       'elementStart': r3.elementStart,\n       'elementEnd': r3.elementEnd,\n       'element': r3.element,\n       'elementContainerStart': r3.elementContainerStart,\n       'elementContainerEnd': r3.elementContainerEnd,\n       'elementContainer': r3.elementContainer,\n       'pureFunction0': r3.pureFunction0,\n       'pureFunction1': r3.pureFunction1,\n       'pureFunction2': r3.pureFunction2,\n       'pureFunction3': r3.pureFunction3,\n       'pureFunction4': r3.pureFunction4,\n       'pureFunction5': r3.pureFunction5,\n       'pureFunction6': r3.pureFunction6,\n       'pureFunction7': r3.pureFunction7,\n       'pureFunction8': r3.pureFunction8,\n       'pureFunctionV': r3.pureFunctionV,\n       'getCurrentView': r3.getCurrentView,\n       'restoreView': r3.restoreView,\n       'listener': r3.listener,\n       'projection': r3.projection,\n       'syntheticHostProperty': r3.syntheticHostProperty,\n       'syntheticHostListener': r3.syntheticHostListener,\n       'pipeBind1': r3.pipeBind1,\n       'pipeBind2': r3.pipeBind2,\n       'pipeBind3': r3.pipeBind3,\n       'pipeBind4': r3.pipeBind4,\n       'pipeBindV': r3.pipeBindV,\n       'projectionDef': r3.projectionDef,\n       'hostProperty': r3.hostProperty,\n       'property': r3.property,\n       'propertyInterpolate': r3.propertyInterpolate,\n       'propertyInterpolate1': r3.propertyInterpolate1,\n       'propertyInterpolate2': r3.propertyInterpolate2,\n       'propertyInterpolate3': r3.propertyInterpolate3,\n       'propertyInterpolate4': r3.propertyInterpolate4,\n       'propertyInterpolate5': r3.propertyInterpolate5,\n       'propertyInterpolate6': r3.propertyInterpolate6,\n       'propertyInterpolate7': r3.propertyInterpolate7,\n       'propertyInterpolate8': r3.propertyInterpolate8,\n       'propertyInterpolateV': r3.propertyInterpolateV,\n       'pipe': r3.pipe,\n       'queryRefresh': r3.queryRefresh,\n       'viewQuery': r3.viewQuery,\n       'loadQuery': r3.loadQuery,\n       'contentQuery': r3.contentQuery,\n       'reference': r3.reference,\n       'classMap': r3.classMap,\n       'classMapInterpolate1': r3.classMapInterpolate1,\n       'classMapInterpolate2': r3.classMapInterpolate2,\n       'classMapInterpolate3': r3.classMapInterpolate3,\n       'classMapInterpolate4': r3.classMapInterpolate4,\n       'classMapInterpolate5': r3.classMapInterpolate5,\n       'classMapInterpolate6': r3.classMapInterpolate6,\n       'classMapInterpolate7': r3.classMapInterpolate7,\n       'classMapInterpolate8': r3.classMapInterpolate8,\n       'classMapInterpolateV': r3.classMapInterpolateV,\n       'styleMap': r3.styleMap,\n       'styleMapInterpolate1': r3.styleMapInterpolate1,\n       'styleMapInterpolate2': r3.styleMapInterpolate2,\n       'styleMapInterpolate3': r3.styleMapInterpolate3,\n       'styleMapInterpolate4': r3.styleMapInterpolate4,\n       'styleMapInterpolate5': r3.styleMapInterpolate5,\n       'styleMapInterpolate6': r3.styleMapInterpolate6,\n       'styleMapInterpolate7': r3.styleMapInterpolate7,\n       'styleMapInterpolate8': r3.styleMapInterpolate8,\n       'styleMapInterpolateV': r3.styleMapInterpolateV,\n       'styleProp': r3.styleProp,\n       'stylePropInterpolate1': r3.stylePropInterpolate1,\n       'stylePropInterpolate2': r3.stylePropInterpolate2,\n       'stylePropInterpolate3': r3.stylePropInterpolate3,\n       'stylePropInterpolate4': r3.stylePropInterpolate4,\n       'stylePropInterpolate5': r3.stylePropInterpolate5,\n       'stylePropInterpolate6': r3.stylePropInterpolate6,\n       'stylePropInterpolate7': r3.stylePropInterpolate7,\n       'stylePropInterpolate8': r3.stylePropInterpolate8,\n       'stylePropInterpolateV': r3.stylePropInterpolateV,\n       'classProp': r3.classProp,\n       'advance': r3.advance,\n       'template': r3.template,\n       'conditional': r3.conditional,\n       'defer': r3.defer,\n       'deferWhen': r3.deferWhen,\n       'deferOnIdle': r3.deferOnIdle,\n       'deferOnImmediate': r3.deferOnImmediate,\n       'deferOnTimer': r3.deferOnTimer,\n       'deferOnHover': r3.deferOnHover,\n       'deferOnInteraction': r3.deferOnInteraction,\n       'deferOnViewport': r3.deferOnViewport,\n       'deferPrefetchWhen': r3.deferPrefetchWhen,\n       'deferPrefetchOnIdle': r3.deferPrefetchOnIdle,\n       'deferPrefetchOnImmediate': r3.deferPrefetchOnImmediate,\n       'deferPrefetchOnTimer': r3.deferPrefetchOnTimer,\n       'deferPrefetchOnHover': r3.deferPrefetchOnHover,\n       'deferPrefetchOnInteraction': r3.deferPrefetchOnInteraction,\n       'deferPrefetchOnViewport': r3.deferPrefetchOnViewport,\n       'deferEnableTimerScheduling': r3.deferEnableTimerScheduling,\n       'repeater': r3.repeater,\n       'repeaterCreate': r3.repeaterCreate,\n       'repeaterTrackByIndex': r3.repeaterTrackByIndex,\n       'repeaterTrackByIdentity': r3.repeaterTrackByIdentity,\n       'componentInstance': r3.componentInstance,\n       'text': r3.text,\n       'textInterpolate': r3.textInterpolate,\n       'textInterpolate1': r3.textInterpolate1,\n       'textInterpolate2': r3.textInterpolate2,\n       'textInterpolate3': r3.textInterpolate3,\n       'textInterpolate4': r3.textInterpolate4,\n       'textInterpolate5': r3.textInterpolate5,\n       'textInterpolate6': r3.textInterpolate6,\n       'textInterpolate7': r3.textInterpolate7,\n       'textInterpolate8': r3.textInterpolate8,\n       'textInterpolateV': r3.textInterpolateV,\n       'i18n': r3.i18n,\n       'i18nAttributes': r3.i18nAttributes,\n       'i18nExp': r3.i18nExp,\n       'i18nStart': r3.i18nStart,\n       'i18nEnd': r3.i18nEnd,\n       'i18nApply': r3.i18nApply,\n       'i18nPostprocess': r3.i18nPostprocess,\n       'resolveWindow': r3.resolveWindow,\n       'resolveDocument': r3.resolveDocument,\n       'resolveBody': r3.resolveBody,\n       'setComponentScope': r3.setComponentScope,\n       'setNgModuleScope': r3.setNgModuleScope,\n       'registerNgModuleType': registerNgModuleType,\n       'getComponentDepsFactory': r3.getComponentDepsFactory,\n       'setClassDebugInfo': r3.setClassDebugInfo,\n\n       'sanitizeHtml': sanitization.sanitizeHtml,\n       'sanitizeStyle': sanitization.sanitizeStyle,\n       'sanitizeResourceUrl': sanitization.sanitizeResourceUrl,\n       'sanitizeScript': sanitization.sanitizeScript,\n       'sanitizeUrl': sanitization.sanitizeUrl,\n       'sanitizeUrlOrResourceUrl': sanitization.sanitizeUrlOrResourceUrl,\n       'trustConstantHtml': sanitization.trustConstantHtml,\n       'trustConstantResourceUrl': sanitization.trustConstantResourceUrl,\n       'validateIframeAttribute': iframe_attrs_validation.validateIframeAttribute,\n\n       'forwardRef': forwardRef,\n       'resolveForwardRef': resolveForwardRef,\n     }))();\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport {SanitizerFn} from '../interfaces/sanitization';\nimport {getBindingIndex, getLView, getSelectedTNode, getTView} from '../state';\nimport {NO_CHANGE} from '../tokens';\nimport {interpolation1, interpolation2, interpolation3, interpolation4, interpolation5, interpolation6, interpolation7, interpolation8, interpolationV} from './interpolation';\nimport {elementAttributeInternal, storePropertyBindingMetadata} from './shared';\n\n\n\n/**\n *\n * Update an interpolated attribute on an element with single bound value surrounded by text.\n *\n * Used when the value passed to a property has 1 interpolated value in it:\n *\n * ```html\n * <div attr.title=\"prefix{{v0}}suffix\"></div>\n * ```\n *\n * Its compiled representation is::\n *\n * ```ts\n * attributeInterpolate1('title', 'prefix', v0, 'suffix');\n * ```\n *\n * @param attrName The name of the attribute to update\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @param sanitizer An optional sanitizer function\n * @returns itself, so that it may be chained.\n * @codeGenApi\n */\nexport function attributeInterpolate1(\n    attrName: string, prefix: string, v0: any, suffix: string, sanitizer?: SanitizerFn,\n    namespace?: string): typeof attributeInterpolate1 {\n  const lView = getLView();\n  const interpolatedValue = interpolation1(lView, prefix, v0, suffix);\n  if (interpolatedValue !== NO_CHANGE) {\n    const tNode = getSelectedTNode();\n    elementAttributeInternal(tNode, lView, attrName, interpolatedValue, sanitizer, namespace);\n    ngDevMode &&\n        storePropertyBindingMetadata(\n            getTView().data, tNode, 'attr.' + attrName, getBindingIndex() - 1, prefix, suffix);\n  }\n  return attributeInterpolate1;\n}\n\n/**\n *\n * Update an interpolated attribute on an element with 2 bound values surrounded by text.\n *\n * Used when the value passed to a property has 2 interpolated values in it:\n *\n * ```html\n * <div attr.title=\"prefix{{v0}}-{{v1}}suffix\"></div>\n * ```\n *\n * Its compiled representation is::\n *\n * ```ts\n * attributeInterpolate2('title', 'prefix', v0, '-', v1, 'suffix');\n * ```\n *\n * @param attrName The name of the attribute to update\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @param sanitizer An optional sanitizer function\n * @returns itself, so that it may be chained.\n * @codeGenApi\n */\nexport function attributeInterpolate2(\n    attrName: string, prefix: string, v0: any, i0: string, v1: any, suffix: string,\n    sanitizer?: SanitizerFn, namespace?: string): typeof attributeInterpolate2 {\n  const lView = getLView();\n  const interpolatedValue = interpolation2(lView, prefix, v0, i0, v1, suffix);\n  if (interpolatedValue !== NO_CHANGE) {\n    const tNode = getSelectedTNode();\n    elementAttributeInternal(tNode, lView, attrName, interpolatedValue, sanitizer, namespace);\n    ngDevMode &&\n        storePropertyBindingMetadata(\n            getTView().data, tNode, 'attr.' + attrName, getBindingIndex() - 2, prefix, i0, suffix);\n  }\n  return attributeInterpolate2;\n}\n\n/**\n *\n * Update an interpolated attribute on an element with 3 bound values surrounded by text.\n *\n * Used when the value passed to a property has 3 interpolated values in it:\n *\n * ```html\n * <div attr.title=\"prefix{{v0}}-{{v1}}-{{v2}}suffix\"></div>\n * ```\n *\n * Its compiled representation is::\n *\n * ```ts\n * attributeInterpolate3(\n * 'title', 'prefix', v0, '-', v1, '-', v2, 'suffix');\n * ```\n *\n * @param attrName The name of the attribute to update\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param i1 Static value used for concatenation only.\n * @param v2 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @param sanitizer An optional sanitizer function\n * @returns itself, so that it may be chained.\n * @codeGenApi\n */\nexport function attributeInterpolate3(\n    attrName: string, prefix: string, v0: any, i0: string, v1: any, i1: string, v2: any,\n    suffix: string, sanitizer?: SanitizerFn, namespace?: string): typeof attributeInterpolate3 {\n  const lView = getLView();\n  const interpolatedValue = interpolation3(lView, prefix, v0, i0, v1, i1, v2, suffix);\n  if (interpolatedValue !== NO_CHANGE) {\n    const tNode = getSelectedTNode();\n    elementAttributeInternal(tNode, lView, attrName, interpolatedValue, sanitizer, namespace);\n    ngDevMode &&\n        storePropertyBindingMetadata(\n            getTView().data, tNode, 'attr.' + attrName, getBindingIndex() - 3, prefix, i0, i1,\n            suffix);\n  }\n  return attributeInterpolate3;\n}\n\n/**\n *\n * Update an interpolated attribute on an element with 4 bound values surrounded by text.\n *\n * Used when the value passed to a property has 4 interpolated values in it:\n *\n * ```html\n * <div attr.title=\"prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}suffix\"></div>\n * ```\n *\n * Its compiled representation is::\n *\n * ```ts\n * attributeInterpolate4(\n * 'title', 'prefix', v0, '-', v1, '-', v2, '-', v3, 'suffix');\n * ```\n *\n * @param attrName The name of the attribute to update\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param i1 Static value used for concatenation only.\n * @param v2 Value checked for change.\n * @param i2 Static value used for concatenation only.\n * @param v3 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @param sanitizer An optional sanitizer function\n * @returns itself, so that it may be chained.\n * @codeGenApi\n */\nexport function attributeInterpolate4(\n    attrName: string, prefix: string, v0: any, i0: string, v1: any, i1: string, v2: any, i2: string,\n    v3: any, suffix: string, sanitizer?: SanitizerFn,\n    namespace?: string): typeof attributeInterpolate4 {\n  const lView = getLView();\n  const interpolatedValue = interpolation4(lView, prefix, v0, i0, v1, i1, v2, i2, v3, suffix);\n  if (interpolatedValue !== NO_CHANGE) {\n    const tNode = getSelectedTNode();\n    elementAttributeInternal(tNode, lView, attrName, interpolatedValue, sanitizer, namespace);\n    ngDevMode &&\n        storePropertyBindingMetadata(\n            getTView().data, tNode, 'attr.' + attrName, getBindingIndex() - 4, prefix, i0, i1, i2,\n            suffix);\n  }\n  return attributeInterpolate4;\n}\n\n/**\n *\n * Update an interpolated attribute on an element with 5 bound values surrounded by text.\n *\n * Used when the value passed to a property has 5 interpolated values in it:\n *\n * ```html\n * <div attr.title=\"prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}-{{v4}}suffix\"></div>\n * ```\n *\n * Its compiled representation is::\n *\n * ```ts\n * attributeInterpolate5(\n * 'title', 'prefix', v0, '-', v1, '-', v2, '-', v3, '-', v4, 'suffix');\n * ```\n *\n * @param attrName The name of the attribute to update\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param i1 Static value used for concatenation only.\n * @param v2 Value checked for change.\n * @param i2 Static value used for concatenation only.\n * @param v3 Value checked for change.\n * @param i3 Static value used for concatenation only.\n * @param v4 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @param sanitizer An optional sanitizer function\n * @returns itself, so that it may be chained.\n * @codeGenApi\n */\nexport function attributeInterpolate5(\n    attrName: string, prefix: string, v0: any, i0: string, v1: any, i1: string, v2: any, i2: string,\n    v3: any, i3: string, v4: any, suffix: string, sanitizer?: SanitizerFn,\n    namespace?: string): typeof attributeInterpolate5 {\n  const lView = getLView();\n  const interpolatedValue =\n      interpolation5(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, suffix);\n  if (interpolatedValue !== NO_CHANGE) {\n    const tNode = getSelectedTNode();\n    elementAttributeInternal(tNode, lView, attrName, interpolatedValue, sanitizer, namespace);\n    ngDevMode &&\n        storePropertyBindingMetadata(\n            getTView().data, tNode, 'attr.' + attrName, getBindingIndex() - 5, prefix, i0, i1, i2,\n            i3, suffix);\n  }\n  return attributeInterpolate5;\n}\n\n/**\n *\n * Update an interpolated attribute on an element with 6 bound values surrounded by text.\n *\n * Used when the value passed to a property has 6 interpolated values in it:\n *\n * ```html\n * <div attr.title=\"prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}-{{v4}}-{{v5}}suffix\"></div>\n * ```\n *\n * Its compiled representation is::\n *\n * ```ts\n * attributeInterpolate6(\n *    'title', 'prefix', v0, '-', v1, '-', v2, '-', v3, '-', v4, '-', v5, 'suffix');\n * ```\n *\n * @param attrName The name of the attribute to update\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param i1 Static value used for concatenation only.\n * @param v2 Value checked for change.\n * @param i2 Static value used for concatenation only.\n * @param v3 Value checked for change.\n * @param i3 Static value used for concatenation only.\n * @param v4 Value checked for change.\n * @param i4 Static value used for concatenation only.\n * @param v5 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @param sanitizer An optional sanitizer function\n * @returns itself, so that it may be chained.\n * @codeGenApi\n */\nexport function attributeInterpolate6(\n    attrName: string, prefix: string, v0: any, i0: string, v1: any, i1: string, v2: any, i2: string,\n    v3: any, i3: string, v4: any, i4: string, v5: any, suffix: string, sanitizer?: SanitizerFn,\n    namespace?: string): typeof attributeInterpolate6 {\n  const lView = getLView();\n  const interpolatedValue =\n      interpolation6(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, suffix);\n  if (interpolatedValue !== NO_CHANGE) {\n    const tNode = getSelectedTNode();\n    elementAttributeInternal(tNode, lView, attrName, interpolatedValue, sanitizer, namespace);\n    ngDevMode &&\n        storePropertyBindingMetadata(\n            getTView().data, tNode, 'attr.' + attrName, getBindingIndex() - 6, prefix, i0, i1, i2,\n            i3, i4, suffix);\n  }\n  return attributeInterpolate6;\n}\n\n/**\n *\n * Update an interpolated attribute on an element with 7 bound values surrounded by text.\n *\n * Used when the value passed to a property has 7 interpolated values in it:\n *\n * ```html\n * <div attr.title=\"prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}-{{v4}}-{{v5}}-{{v6}}suffix\"></div>\n * ```\n *\n * Its compiled representation is::\n *\n * ```ts\n * attributeInterpolate7(\n *    'title', 'prefix', v0, '-', v1, '-', v2, '-', v3, '-', v4, '-', v5, '-', v6, 'suffix');\n * ```\n *\n * @param attrName The name of the attribute to update\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param i1 Static value used for concatenation only.\n * @param v2 Value checked for change.\n * @param i2 Static value used for concatenation only.\n * @param v3 Value checked for change.\n * @param i3 Static value used for concatenation only.\n * @param v4 Value checked for change.\n * @param i4 Static value used for concatenation only.\n * @param v5 Value checked for change.\n * @param i5 Static value used for concatenation only.\n * @param v6 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @param sanitizer An optional sanitizer function\n * @returns itself, so that it may be chained.\n * @codeGenApi\n */\nexport function attributeInterpolate7(\n    attrName: string, prefix: string, v0: any, i0: string, v1: any, i1: string, v2: any, i2: string,\n    v3: any, i3: string, v4: any, i4: string, v5: any, i5: string, v6: any, suffix: string,\n    sanitizer?: SanitizerFn, namespace?: string): typeof attributeInterpolate7 {\n  const lView = getLView();\n  const interpolatedValue =\n      interpolation7(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, suffix);\n  if (interpolatedValue !== NO_CHANGE) {\n    const tNode = getSelectedTNode();\n    elementAttributeInternal(tNode, lView, attrName, interpolatedValue, sanitizer, namespace);\n    ngDevMode &&\n        storePropertyBindingMetadata(\n            getTView().data, tNode, 'attr.' + attrName, getBindingIndex() - 7, prefix, i0, i1, i2,\n            i3, i4, i5, suffix);\n  }\n  return attributeInterpolate7;\n}\n\n/**\n *\n * Update an interpolated attribute on an element with 8 bound values surrounded by text.\n *\n * Used when the value passed to a property has 8 interpolated values in it:\n *\n * ```html\n * <div attr.title=\"prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}-{{v4}}-{{v5}}-{{v6}}-{{v7}}suffix\"></div>\n * ```\n *\n * Its compiled representation is::\n *\n * ```ts\n * attributeInterpolate8(\n *  'title', 'prefix', v0, '-', v1, '-', v2, '-', v3, '-', v4, '-', v5, '-', v6, '-', v7, 'suffix');\n * ```\n *\n * @param attrName The name of the attribute to update\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param i1 Static value used for concatenation only.\n * @param v2 Value checked for change.\n * @param i2 Static value used for concatenation only.\n * @param v3 Value checked for change.\n * @param i3 Static value used for concatenation only.\n * @param v4 Value checked for change.\n * @param i4 Static value used for concatenation only.\n * @param v5 Value checked for change.\n * @param i5 Static value used for concatenation only.\n * @param v6 Value checked for change.\n * @param i6 Static value used for concatenation only.\n * @param v7 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @param sanitizer An optional sanitizer function\n * @returns itself, so that it may be chained.\n * @codeGenApi\n */\nexport function attributeInterpolate8(\n    attrName: string, prefix: string, v0: any, i0: string, v1: any, i1: string, v2: any, i2: string,\n    v3: any, i3: string, v4: any, i4: string, v5: any, i5: string, v6: any, i6: string, v7: any,\n    suffix: string, sanitizer?: SanitizerFn, namespace?: string): typeof attributeInterpolate8 {\n  const lView = getLView();\n  const interpolatedValue = interpolation8(\n      lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, i6, v7, suffix);\n  if (interpolatedValue !== NO_CHANGE) {\n    const tNode = getSelectedTNode();\n    elementAttributeInternal(tNode, lView, attrName, interpolatedValue, sanitizer, namespace);\n    ngDevMode &&\n        storePropertyBindingMetadata(\n            getTView().data, tNode, 'attr.' + attrName, getBindingIndex() - 8, prefix, i0, i1, i2,\n            i3, i4, i5, i6, suffix);\n  }\n  return attributeInterpolate8;\n}\n\n/**\n * Update an interpolated attribute on an element with 9 or more bound values surrounded by text.\n *\n * Used when the number of interpolated values exceeds 8.\n *\n * ```html\n * <div\n *  title=\"prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}-{{v4}}-{{v5}}-{{v6}}-{{v7}}-{{v8}}-{{v9}}suffix\"></div>\n * ```\n *\n * Its compiled representation is::\n *\n * ```ts\n * attributeInterpolateV(\n *  'title', ['prefix', v0, '-', v1, '-', v2, '-', v3, '-', v4, '-', v5, '-', v6, '-', v7, '-', v9,\n *  'suffix']);\n * ```\n *\n * @param attrName The name of the attribute to update.\n * @param values The collection of values and the strings in-between those values, beginning with\n * a string prefix and ending with a string suffix.\n * (e.g. `['prefix', value0, '-', value1, '-', value2, ..., value99, 'suffix']`)\n * @param sanitizer An optional sanitizer function\n * @returns itself, so that it may be chained.\n * @codeGenApi\n */\nexport function attributeInterpolateV(\n    attrName: string, values: any[], sanitizer?: SanitizerFn,\n    namespace?: string): typeof attributeInterpolateV {\n  const lView = getLView();\n  const interpolated = interpolationV(lView, values);\n  if (interpolated !== NO_CHANGE) {\n    const tNode = getSelectedTNode();\n    elementAttributeInternal(tNode, lView, attrName, interpolated, sanitizer, namespace);\n    if (ngDevMode) {\n      const interpolationInBetween = [values[0]];  // prefix\n      for (let i = 2; i < values.length; i += 2) {\n        interpolationInBetween.push(values[i]);\n      }\n      storePropertyBindingMetadata(\n          getTView().data, tNode, 'attr.' + attrName,\n          getBindingIndex() - interpolationInBetween.length + 1, ...interpolationInBetween);\n    }\n  }\n  return attributeInterpolateV;\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {getLView} from '../state';\nimport {interpolation1, interpolation2, interpolation3, interpolation4, interpolation5, interpolation6, interpolation7, interpolation8, interpolationV} from './interpolation';\nimport {styleMap} from './styling';\n\n\n/**\n *\n * Update an interpolated style on an element with single bound value surrounded by text.\n *\n * Used when the value passed to a property has 1 interpolated value in it:\n *\n * ```html\n * <div style=\"key: {{v0}}suffix\"></div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * styleMapInterpolate1('key: ', v0, 'suffix');\n * ```\n *\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @codeGenApi\n */\nexport function styleMapInterpolate1(prefix: string, v0: any, suffix: string): void {\n  const lView = getLView();\n  const interpolatedValue = interpolation1(lView, prefix, v0, suffix);\n  styleMap(interpolatedValue);\n}\n\n/**\n *\n * Update an interpolated style on an element with 2 bound values surrounded by text.\n *\n * Used when the value passed to a property has 2 interpolated values in it:\n *\n * ```html\n * <div style=\"key: {{v0}}; key1: {{v1}}suffix\"></div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * styleMapInterpolate2('key: ', v0, '; key1: ', v1, 'suffix');\n * ```\n *\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @codeGenApi\n */\nexport function styleMapInterpolate2(\n    prefix: string, v0: any, i0: string, v1: any, suffix: string): void {\n  const lView = getLView();\n  const interpolatedValue = interpolation2(lView, prefix, v0, i0, v1, suffix);\n  styleMap(interpolatedValue);\n}\n\n/**\n *\n * Update an interpolated style on an element with 3 bound values surrounded by text.\n *\n * Used when the value passed to a property has 3 interpolated values in it:\n *\n * ```html\n * <div style=\"key: {{v0}}; key2: {{v1}}; key2: {{v2}}suffix\"></div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * styleMapInterpolate3(\n *     'key: ', v0, '; key1: ', v1, '; key2: ', v2, 'suffix');\n * ```\n *\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param i1 Static value used for concatenation only.\n * @param v2 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @codeGenApi\n */\nexport function styleMapInterpolate3(\n    prefix: string, v0: any, i0: string, v1: any, i1: string, v2: any, suffix: string): void {\n  const lView = getLView();\n  const interpolatedValue = interpolation3(lView, prefix, v0, i0, v1, i1, v2, suffix);\n  styleMap(interpolatedValue);\n}\n\n/**\n *\n * Update an interpolated style on an element with 4 bound values surrounded by text.\n *\n * Used when the value passed to a property has 4 interpolated values in it:\n *\n * ```html\n * <div style=\"key: {{v0}}; key1: {{v1}}; key2: {{v2}}; key3: {{v3}}suffix\"></div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * styleMapInterpolate4(\n *     'key: ', v0, '; key1: ', v1, '; key2: ', v2, '; key3: ', v3, 'suffix');\n * ```\n *\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param i1 Static value used for concatenation only.\n * @param v2 Value checked for change.\n * @param i2 Static value used for concatenation only.\n * @param v3 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @codeGenApi\n */\nexport function styleMapInterpolate4(\n    prefix: string, v0: any, i0: string, v1: any, i1: string, v2: any, i2: string, v3: any,\n    suffix: string): void {\n  const lView = getLView();\n  const interpolatedValue = interpolation4(lView, prefix, v0, i0, v1, i1, v2, i2, v3, suffix);\n  styleMap(interpolatedValue);\n}\n\n/**\n *\n * Update an interpolated style on an element with 5 bound values surrounded by text.\n *\n * Used when the value passed to a property has 5 interpolated values in it:\n *\n * ```html\n * <div style=\"key: {{v0}}; key1: {{v1}}; key2: {{v2}}; key3: {{v3}}; key4: {{v4}}suffix\"></div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * styleMapInterpolate5(\n *     'key: ', v0, '; key1: ', v1, '; key2: ', v2, '; key3: ', v3, '; key4: ', v4, 'suffix');\n * ```\n *\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param i1 Static value used for concatenation only.\n * @param v2 Value checked for change.\n * @param i2 Static value used for concatenation only.\n * @param v3 Value checked for change.\n * @param i3 Static value used for concatenation only.\n * @param v4 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @codeGenApi\n */\nexport function styleMapInterpolate5(\n    prefix: string, v0: any, i0: string, v1: any, i1: string, v2: any, i2: string, v3: any,\n    i3: string, v4: any, suffix: string): void {\n  const lView = getLView();\n  const interpolatedValue =\n      interpolation5(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, suffix);\n  styleMap(interpolatedValue);\n}\n\n/**\n *\n * Update an interpolated style on an element with 6 bound values surrounded by text.\n *\n * Used when the value passed to a property has 6 interpolated values in it:\n *\n * ```html\n * <div style=\"key: {{v0}}; key1: {{v1}}; key2: {{v2}}; key3: {{v3}}; key4: {{v4}};\n *             key5: {{v5}}suffix\"></div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * styleMapInterpolate6(\n *    'key: ', v0, '; key1: ', v1, '; key2: ', v2, '; key3: ', v3, '; key4: ', v4, '; key5: ', v5,\n *    'suffix');\n * ```\n *\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param i1 Static value used for concatenation only.\n * @param v2 Value checked for change.\n * @param i2 Static value used for concatenation only.\n * @param v3 Value checked for change.\n * @param i3 Static value used for concatenation only.\n * @param v4 Value checked for change.\n * @param i4 Static value used for concatenation only.\n * @param v5 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @codeGenApi\n */\nexport function styleMapInterpolate6(\n    prefix: string, v0: any, i0: string, v1: any, i1: string, v2: any, i2: string, v3: any,\n    i3: string, v4: any, i4: string, v5: any, suffix: string): void {\n  const lView = getLView();\n  const interpolatedValue =\n      interpolation6(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, suffix);\n  styleMap(interpolatedValue);\n}\n\n/**\n *\n * Update an interpolated style on an element with 7 bound values surrounded by text.\n *\n * Used when the value passed to a property has 7 interpolated values in it:\n *\n * ```html\n * <div style=\"key: {{v0}}; key1: {{v1}}; key2: {{v2}}; key3: {{v3}}; key4: {{v4}}; key5: {{v5}};\n *             key6: {{v6}}suffix\"></div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * styleMapInterpolate7(\n *    'key: ', v0, '; key1: ', v1, '; key2: ', v2, '; key3: ', v3, '; key4: ', v4, '; key5: ', v5,\n *    '; key6: ', v6, 'suffix');\n * ```\n *\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param i1 Static value used for concatenation only.\n * @param v2 Value checked for change.\n * @param i2 Static value used for concatenation only.\n * @param v3 Value checked for change.\n * @param i3 Static value used for concatenation only.\n * @param v4 Value checked for change.\n * @param i4 Static value used for concatenation only.\n * @param v5 Value checked for change.\n * @param i5 Static value used for concatenation only.\n * @param v6 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @codeGenApi\n */\nexport function styleMapInterpolate7(\n    prefix: string, v0: any, i0: string, v1: any, i1: string, v2: any, i2: string, v3: any,\n    i3: string, v4: any, i4: string, v5: any, i5: string, v6: any, suffix: string): void {\n  const lView = getLView();\n  const interpolatedValue =\n      interpolation7(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, suffix);\n  styleMap(interpolatedValue);\n}\n\n/**\n *\n * Update an interpolated style on an element with 8 bound values surrounded by text.\n *\n * Used when the value passed to a property has 8 interpolated values in it:\n *\n * ```html\n * <div style=\"key: {{v0}}; key1: {{v1}}; key2: {{v2}}; key3: {{v3}}; key4: {{v4}}; key5: {{v5}};\n *             key6: {{v6}}; key7: {{v7}}suffix\"></div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * styleMapInterpolate8(\n *    'key: ', v0, '; key1: ', v1, '; key2: ', v2, '; key3: ', v3, '; key4: ', v4, '; key5: ', v5,\n *    '; key6: ', v6, '; key7: ', v7, 'suffix');\n * ```\n *\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param i1 Static value used for concatenation only.\n * @param v2 Value checked for change.\n * @param i2 Static value used for concatenation only.\n * @param v3 Value checked for change.\n * @param i3 Static value used for concatenation only.\n * @param v4 Value checked for change.\n * @param i4 Static value used for concatenation only.\n * @param v5 Value checked for change.\n * @param i5 Static value used for concatenation only.\n * @param v6 Value checked for change.\n * @param i6 Static value used for concatenation only.\n * @param v7 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @codeGenApi\n */\nexport function styleMapInterpolate8(\n    prefix: string, v0: any, i0: string, v1: any, i1: string, v2: any, i2: string, v3: any,\n    i3: string, v4: any, i4: string, v5: any, i5: string, v6: any, i6: string, v7: any,\n    suffix: string): void {\n  const lView = getLView();\n  const interpolatedValue = interpolation8(\n      lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, i6, v7, suffix);\n  styleMap(interpolatedValue);\n}\n\n/**\n * Update an interpolated style on an element with 9 or more bound values surrounded by text.\n *\n * Used when the number of interpolated values exceeds 8.\n *\n * ```html\n * <div\n *  class=\"key: {{v0}}; key1: {{v1}}; key2: {{v2}}; key3: {{v3}}; key4: {{v4}}; key5: {{v5}};\n *         key6: {{v6}}; key7: {{v7}}; key8: {{v8}}; key9: {{v9}}suffix\"></div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * styleMapInterpolateV(\n *    ['key: ', v0, '; key1: ', v1, '; key2: ', v2, '; key3: ', v3, '; key4: ', v4, '; key5: ', v5,\n *     '; key6: ', v6, '; key7: ', v7, '; key8: ', v8, '; key9: ', v9, 'suffix']);\n * ```\n *.\n * @param values The collection of values and the strings in-between those values, beginning with\n * a string prefix and ending with a string suffix.\n * (e.g. `['prefix', value0, '; key2: ', value1, '; key2: ', value2, ..., value99, 'suffix']`)\n * @codeGenApi\n */\nexport function styleMapInterpolateV(values: any[]): void {\n  const lView = getLView();\n  const interpolatedValue = interpolationV(lView, values);\n  styleMap(interpolatedValue);\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {getLView,} from '../state';\nimport {interpolation1, interpolation2, interpolation3, interpolation4, interpolation5, interpolation6, interpolation7, interpolation8, interpolationV} from './interpolation';\nimport {checkStylingProperty} from './styling';\n\n\n/**\n *\n * Update an interpolated style property on an element with single bound value surrounded by text.\n *\n * Used when the value passed to a property has 1 interpolated value in it:\n *\n * ```html\n * <div style.color=\"prefix{{v0}}suffix\"></div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * stylePropInterpolate1(0, 'prefix', v0, 'suffix');\n * ```\n *\n * @param styleIndex Index of style to update. This index value refers to the\n *        index of the style in the style bindings array that was passed into\n *        `styling`.\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @param valueSuffix Optional suffix. Used with scalar values to add unit such as `px`.\n * @returns itself, so that it may be chained.\n * @codeGenApi\n */\nexport function stylePropInterpolate1(\n    prop: string, prefix: string, v0: any, suffix: string,\n    valueSuffix?: string|null): typeof stylePropInterpolate1 {\n  const lView = getLView();\n  const interpolatedValue = interpolation1(lView, prefix, v0, suffix);\n  checkStylingProperty(prop, interpolatedValue, valueSuffix, false);\n  return stylePropInterpolate1;\n}\n\n/**\n *\n * Update an interpolated style property on an element with 2 bound values surrounded by text.\n *\n * Used when the value passed to a property has 2 interpolated values in it:\n *\n * ```html\n * <div style.color=\"prefix{{v0}}-{{v1}}suffix\"></div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * stylePropInterpolate2(0, 'prefix', v0, '-', v1, 'suffix');\n * ```\n *\n * @param styleIndex Index of style to update. This index value refers to the\n *        index of the style in the style bindings array that was passed into\n *        `styling`.\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @param valueSuffix Optional suffix. Used with scalar values to add unit such as `px`.\n * @returns itself, so that it may be chained.\n * @codeGenApi\n */\nexport function stylePropInterpolate2(\n    prop: string, prefix: string, v0: any, i0: string, v1: any, suffix: string,\n    valueSuffix?: string|null): typeof stylePropInterpolate2 {\n  const lView = getLView();\n  const interpolatedValue = interpolation2(lView, prefix, v0, i0, v1, suffix);\n  checkStylingProperty(prop, interpolatedValue, valueSuffix, false);\n  return stylePropInterpolate2;\n}\n\n/**\n *\n * Update an interpolated style property on an element with 3 bound values surrounded by text.\n *\n * Used when the value passed to a property has 3 interpolated values in it:\n *\n * ```html\n * <div style.color=\"prefix{{v0}}-{{v1}}-{{v2}}suffix\"></div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * stylePropInterpolate3(0, 'prefix', v0, '-', v1, '-', v2, 'suffix');\n * ```\n *\n * @param styleIndex Index of style to update. This index value refers to the\n *        index of the style in the style bindings array that was passed into\n *        `styling`.\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param i1 Static value used for concatenation only.\n * @param v2 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @param valueSuffix Optional suffix. Used with scalar values to add unit such as `px`.\n * @returns itself, so that it may be chained.\n * @codeGenApi\n */\nexport function stylePropInterpolate3(\n    prop: string, prefix: string, v0: any, i0: string, v1: any, i1: string, v2: any, suffix: string,\n    valueSuffix?: string|null): typeof stylePropInterpolate3 {\n  const lView = getLView();\n  const interpolatedValue = interpolation3(lView, prefix, v0, i0, v1, i1, v2, suffix);\n  checkStylingProperty(prop, interpolatedValue, valueSuffix, false);\n  return stylePropInterpolate3;\n}\n\n/**\n *\n * Update an interpolated style property on an element with 4 bound values surrounded by text.\n *\n * Used when the value passed to a property has 4 interpolated values in it:\n *\n * ```html\n * <div style.color=\"prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}suffix\"></div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * stylePropInterpolate4(0, 'prefix', v0, '-', v1, '-', v2, '-', v3, 'suffix');\n * ```\n *\n * @param styleIndex Index of style to update. This index value refers to the\n *        index of the style in the style bindings array that was passed into\n *        `styling`.\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param i1 Static value used for concatenation only.\n * @param v2 Value checked for change.\n * @param i2 Static value used for concatenation only.\n * @param v3 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @param valueSuffix Optional suffix. Used with scalar values to add unit such as `px`.\n * @returns itself, so that it may be chained.\n * @codeGenApi\n */\nexport function stylePropInterpolate4(\n    prop: string, prefix: string, v0: any, i0: string, v1: any, i1: string, v2: any, i2: string,\n    v3: any, suffix: string, valueSuffix?: string|null): typeof stylePropInterpolate4 {\n  const lView = getLView();\n  const interpolatedValue = interpolation4(lView, prefix, v0, i0, v1, i1, v2, i2, v3, suffix);\n  checkStylingProperty(prop, interpolatedValue, valueSuffix, false);\n  return stylePropInterpolate4;\n}\n\n/**\n *\n * Update an interpolated style property on an element with 5 bound values surrounded by text.\n *\n * Used when the value passed to a property has 5 interpolated values in it:\n *\n * ```html\n * <div style.color=\"prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}-{{v4}}suffix\"></div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * stylePropInterpolate5(0, 'prefix', v0, '-', v1, '-', v2, '-', v3, '-', v4, 'suffix');\n * ```\n *\n * @param styleIndex Index of style to update. This index value refers to the\n *        index of the style in the style bindings array that was passed into\n *        `styling`.\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param i1 Static value used for concatenation only.\n * @param v2 Value checked for change.\n * @param i2 Static value used for concatenation only.\n * @param v3 Value checked for change.\n * @param i3 Static value used for concatenation only.\n * @param v4 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @param valueSuffix Optional suffix. Used with scalar values to add unit such as `px`.\n * @returns itself, so that it may be chained.\n * @codeGenApi\n */\nexport function stylePropInterpolate5(\n    prop: string, prefix: string, v0: any, i0: string, v1: any, i1: string, v2: any, i2: string,\n    v3: any, i3: string, v4: any, suffix: string,\n    valueSuffix?: string|null): typeof stylePropInterpolate5 {\n  const lView = getLView();\n  const interpolatedValue =\n      interpolation5(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, suffix);\n  checkStylingProperty(prop, interpolatedValue, valueSuffix, false);\n  return stylePropInterpolate5;\n}\n\n/**\n *\n * Update an interpolated style property on an element with 6 bound values surrounded by text.\n *\n * Used when the value passed to a property has 6 interpolated values in it:\n *\n * ```html\n * <div style.color=\"prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}-{{v4}}-{{v5}}suffix\"></div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * stylePropInterpolate6(0, 'prefix', v0, '-', v1, '-', v2, '-', v3, '-', v4, '-', v5, 'suffix');\n * ```\n *\n * @param styleIndex Index of style to update. This index value refers to the\n *        index of the style in the style bindings array that was passed into\n *        `styling`.\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param i1 Static value used for concatenation only.\n * @param v2 Value checked for change.\n * @param i2 Static value used for concatenation only.\n * @param v3 Value checked for change.\n * @param i3 Static value used for concatenation only.\n * @param v4 Value checked for change.\n * @param i4 Static value used for concatenation only.\n * @param v5 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @param valueSuffix Optional suffix. Used with scalar values to add unit such as `px`.\n * @returns itself, so that it may be chained.\n * @codeGenApi\n */\nexport function stylePropInterpolate6(\n    prop: string, prefix: string, v0: any, i0: string, v1: any, i1: string, v2: any, i2: string,\n    v3: any, i3: string, v4: any, i4: string, v5: any, suffix: string,\n    valueSuffix?: string|null): typeof stylePropInterpolate6 {\n  const lView = getLView();\n  const interpolatedValue =\n      interpolation6(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, suffix);\n  checkStylingProperty(prop, interpolatedValue, valueSuffix, false);\n  return stylePropInterpolate6;\n}\n\n/**\n *\n * Update an interpolated style property on an element with 7 bound values surrounded by text.\n *\n * Used when the value passed to a property has 7 interpolated values in it:\n *\n * ```html\n * <div style.color=\"prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}-{{v4}}-{{v5}}-{{v6}}suffix\"></div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * stylePropInterpolate7(\n *    0, 'prefix', v0, '-', v1, '-', v2, '-', v3, '-', v4, '-', v5, '-', v6, 'suffix');\n * ```\n *\n * @param styleIndex Index of style to update. This index value refers to the\n *        index of the style in the style bindings array that was passed into\n *        `styling`.\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param i1 Static value used for concatenation only.\n * @param v2 Value checked for change.\n * @param i2 Static value used for concatenation only.\n * @param v3 Value checked for change.\n * @param i3 Static value used for concatenation only.\n * @param v4 Value checked for change.\n * @param i4 Static value used for concatenation only.\n * @param v5 Value checked for change.\n * @param i5 Static value used for concatenation only.\n * @param v6 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @param valueSuffix Optional suffix. Used with scalar values to add unit such as `px`.\n * @returns itself, so that it may be chained.\n * @codeGenApi\n */\nexport function stylePropInterpolate7(\n    prop: string, prefix: string, v0: any, i0: string, v1: any, i1: string, v2: any, i2: string,\n    v3: any, i3: string, v4: any, i4: string, v5: any, i5: string, v6: any, suffix: string,\n    valueSuffix?: string|null): typeof stylePropInterpolate7 {\n  const lView = getLView();\n  const interpolatedValue =\n      interpolation7(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, suffix);\n  checkStylingProperty(prop, interpolatedValue, valueSuffix, false);\n  return stylePropInterpolate7;\n}\n\n/**\n *\n * Update an interpolated style property on an element with 8 bound values surrounded by text.\n *\n * Used when the value passed to a property has 8 interpolated values in it:\n *\n * ```html\n * <div style.color=\"prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}-{{v4}}-{{v5}}-{{v6}}-{{v7}}suffix\"></div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * stylePropInterpolate8(0, 'prefix', v0, '-', v1, '-', v2, '-', v3, '-', v4, '-', v5, '-', v6,\n * '-', v7, 'suffix');\n * ```\n *\n * @param styleIndex Index of style to update. This index value refers to the\n *        index of the style in the style bindings array that was passed into\n *        `styling`.\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param i1 Static value used for concatenation only.\n * @param v2 Value checked for change.\n * @param i2 Static value used for concatenation only.\n * @param v3 Value checked for change.\n * @param i3 Static value used for concatenation only.\n * @param v4 Value checked for change.\n * @param i4 Static value used for concatenation only.\n * @param v5 Value checked for change.\n * @param i5 Static value used for concatenation only.\n * @param v6 Value checked for change.\n * @param i6 Static value used for concatenation only.\n * @param v7 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @param valueSuffix Optional suffix. Used with scalar values to add unit such as `px`.\n * @returns itself, so that it may be chained.\n * @codeGenApi\n */\nexport function stylePropInterpolate8(\n    prop: string, prefix: string, v0: any, i0: string, v1: any, i1: string, v2: any, i2: string,\n    v3: any, i3: string, v4: any, i4: string, v5: any, i5: string, v6: any, i6: string, v7: any,\n    suffix: string, valueSuffix?: string|null): typeof stylePropInterpolate8 {\n  const lView = getLView();\n  const interpolatedValue = interpolation8(\n      lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, i6, v7, suffix);\n  checkStylingProperty(prop, interpolatedValue, valueSuffix, false);\n  return stylePropInterpolate8;\n}\n\n/**\n * Update an interpolated style property on an element with 9 or more bound values surrounded by\n * text.\n *\n * Used when the number of interpolated values exceeds 8.\n *\n * ```html\n * <div\n *  style.color=\"prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}-{{v4}}-{{v5}}-{{v6}}-{{v7}}-{{v8}}-{{v9}}suffix\">\n * </div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * stylePropInterpolateV(\n *  0, ['prefix', v0, '-', v1, '-', v2, '-', v3, '-', v4, '-', v5, '-', v6, '-', v7, '-', v9,\n *  'suffix']);\n * ```\n *\n * @param styleIndex Index of style to update. This index value refers to the\n *        index of the style in the style bindings array that was passed into\n *        `styling`..\n * @param values The collection of values and the strings in-between those values, beginning with\n * a string prefix and ending with a string suffix.\n * (e.g. `['prefix', value0, '-', value1, '-', value2, ..., value99, 'suffix']`)\n * @param valueSuffix Optional suffix. Used with scalar values to add unit such as `px`.\n * @returns itself, so that it may be chained.\n * @codeGenApi\n */\nexport function stylePropInterpolateV(\n    prop: string, values: any[], valueSuffix?: string|null): typeof stylePropInterpolateV {\n  const lView = getLView();\n  const interpolatedValue = interpolationV(lView, values);\n  checkStylingProperty(prop, interpolatedValue, valueSuffix, false);\n  return stylePropInterpolateV;\n}\n","/*!\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {assertDefined} from '../../util/assert';\nimport {CONTEXT, DECLARATION_COMPONENT_VIEW} from '../interfaces/view';\nimport {getLView} from '../state';\n\n\n/**\n * Instruction that returns the component instance in which the current instruction is executing.\n * This is a constant-time version of `nextContent` for the case where we know that we need the\n * component instance specifically, rather than the context of a particular template.\n *\n * @codeGenApi\n */\nexport function componentInstance(): unknown {\n  const instance = getLView()[DECLARATION_COMPONENT_VIEW][CONTEXT];\n  ngDevMode && assertDefined(instance, 'Expected component instance to be defined');\n  return instance;\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {depsTracker} from './deps_tracker/deps_tracker';\nimport {ComponentType, DependencyTypeList, RawScopeInfoFromDecorator} from './interfaces/definition';\n\nexport function getComponentDepsFactory(\n    type: ComponentType<any>, rawImports?: RawScopeInfoFromDecorator[]): () => DependencyTypeList {\n  return () => {\n    try {\n      return depsTracker.getComponentDependencies(type, rawImports).dependencies;\n    } catch (e) {\n      console.error(\n          `Computing dependencies in local compilation mode for the component \"${\n              type.name}\" failed with the exception:`,\n          e);\n      throw e;\n    }\n  };\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {Type} from '../../interface/type';\nimport {getComponentDef} from '../definition';\nimport {ClassDebugInfo} from '../interfaces/definition';\n\n/**\n * Sets the debug info for an Angular class.\n *\n * This runtime is guarded by ngDevMode flag.\n */\nexport function setClassDebugInfo(type: Type<any>, debugInfo: ClassDebugInfo): void {\n  const def = getComponentDef(type);\n  if (def !== null) {\n    def.debugInfo = debugInfo;\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {RuntimeError, RuntimeErrorCode} from '../errors';\nimport {getTemplateLocationDetails} from '../render3/instructions/element_validation';\nimport {TNodeType} from '../render3/interfaces/node';\nimport {RComment, RElement} from '../render3/interfaces/renderer_dom';\nimport {RENDERER} from '../render3/interfaces/view';\nimport {nativeRemoveNode} from '../render3/node_manipulation';\nimport {getLView, getSelectedTNode} from '../render3/state';\nimport {getNativeByTNode} from '../render3/util/view_utils';\nimport {trustedHTMLFromString} from '../util/security/trusted_types';\n\n\n/**\n * Validation function invoked at runtime for each binding that might potentially\n * represent a security-sensitive attribute of an <iframe>.\n * See `IFRAME_SECURITY_SENSITIVE_ATTRS` in the\n * `packages/compiler/src/schema/dom_security_schema.ts` script for the full list\n * of such attributes.\n *\n * @codeGenApi\n */\nexport function validateIframeAttribute(attrValue: any, tagName: string, attrName: string) {\n  const lView = getLView();\n  const tNode = getSelectedTNode()!;\n  const element = getNativeByTNode(tNode, lView) as RElement | RComment;\n\n  // Restrict any dynamic bindings of security-sensitive attributes/properties\n  // on an <iframe> for security reasons.\n  if (tNode.type === TNodeType.Element && tagName.toLowerCase() === 'iframe') {\n    const iframe = element as HTMLIFrameElement;\n\n    // Unset previously applied `src` and `srcdoc` if we come across a situation when\n    // a security-sensitive attribute is set later via an attribute/property binding.\n    iframe.src = '';\n    iframe.srcdoc = trustedHTMLFromString('') as unknown as string;\n\n    // Also remove the <iframe> from the document.\n    nativeRemoveNode(lView[RENDERER], iframe);\n\n    const errorMessage = ngDevMode &&\n        `Angular has detected that the \\`${attrName}\\` was applied ` +\n            `as a binding to an <iframe>${getTemplateLocationDetails(lView)}. ` +\n            `For security reasons, the \\`${attrName}\\` can be set on an <iframe> ` +\n            `as a static attribute only. \\n` +\n            `To fix this, switch the \\`${attrName}\\` binding to a static attribute ` +\n            `in a template or in host bindings section.`;\n    throw new RuntimeError(RuntimeErrorCode.UNSAFE_IFRAME_ATTRS, errorMessage);\n  }\n  return attrValue;\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {getCompilerFacade, JitCompilerUsage, R3InjectorMetadataFacade} from '../../compiler/compiler_facade';\nimport {resolveForwardRef} from '../../di/forward_ref';\nimport {NG_INJ_DEF} from '../../di/interface/defs';\nimport {ModuleWithProviders} from '../../di/interface/provider';\nimport {reflectDependencies} from '../../di/jit/util';\nimport {Type} from '../../interface/type';\nimport {registerNgModuleType} from '../../linker/ng_module_registration';\nimport {Component} from '../../metadata/directives';\nimport {NgModule} from '../../metadata/ng_module';\nimport {NgModuleDef, NgModuleTransitiveScopes, NgModuleType} from '../../metadata/ng_module_def';\nimport {deepForEach, flatten} from '../../util/array_utils';\nimport {assertDefined} from '../../util/assert';\nimport {EMPTY_ARRAY} from '../../util/empty';\nimport {GENERATED_COMP_IDS, getComponentDef, getDirectiveDef, getNgModuleDef, getPipeDef, isStandalone} from '../definition';\nimport {depsTracker, USE_RUNTIME_DEPS_TRACKER_FOR_JIT} from '../deps_tracker/deps_tracker';\nimport {NG_COMP_DEF, NG_DIR_DEF, NG_FACTORY_DEF, NG_MOD_DEF, NG_PIPE_DEF} from '../fields';\nimport {ComponentDef} from '../interfaces/definition';\nimport {maybeUnwrapFn} from '../util/misc_utils';\nimport {stringifyForError} from '../util/stringify_utils';\n\nimport {angularCoreEnv} from './environment';\nimport {patchModuleCompilation} from './module_patch';\nimport {isModuleWithProviders, isNgModule} from './util';\n\ninterface ModuleQueueItem {\n  moduleType: Type<any>;\n  ngModule: NgModule;\n}\n\nconst moduleQueue: ModuleQueueItem[] = [];\n\n/**\n * Enqueues moduleDef to be checked later to see if scope can be set on its\n * component declarations.\n */\nfunction enqueueModuleForDelayedScoping(moduleType: Type<any>, ngModule: NgModule) {\n  moduleQueue.push({moduleType, ngModule});\n}\n\nlet flushingModuleQueue = false;\n/**\n * Loops over queued module definitions, if a given module definition has all of its\n * declarations resolved, it dequeues that module definition and sets the scope on\n * its declarations.\n */\nexport function flushModuleScopingQueueAsMuchAsPossible() {\n  if (!flushingModuleQueue) {\n    flushingModuleQueue = true;\n    try {\n      for (let i = moduleQueue.length - 1; i >= 0; i--) {\n        const {moduleType, ngModule} = moduleQueue[i];\n\n        if (ngModule.declarations && ngModule.declarations.every(isResolvedDeclaration)) {\n          // dequeue\n          moduleQueue.splice(i, 1);\n          setScopeOnDeclaredComponents(moduleType, ngModule);\n        }\n      }\n    } finally {\n      flushingModuleQueue = false;\n    }\n  }\n}\n\n/**\n * Returns truthy if a declaration has resolved. If the declaration happens to be\n * an array of declarations, it will recurse to check each declaration in that array\n * (which may also be arrays).\n */\nfunction isResolvedDeclaration(declaration: any[]|Type<any>): boolean {\n  if (Array.isArray(declaration)) {\n    return declaration.every(isResolvedDeclaration);\n  }\n  return !!resolveForwardRef(declaration);\n}\n\n/**\n * Compiles a module in JIT mode.\n *\n * This function automatically gets called when a class has a `@NgModule` decorator.\n */\nexport function compileNgModule(moduleType: Type<any>, ngModule: NgModule = {}): void {\n  patchModuleCompilation();\n  compileNgModuleDefs(moduleType as NgModuleType, ngModule);\n  if (ngModule.id !== undefined) {\n    registerNgModuleType(moduleType as NgModuleType, ngModule.id);\n  }\n\n  // Because we don't know if all declarations have resolved yet at the moment the\n  // NgModule decorator is executing, we're enqueueing the setting of module scope\n  // on its declarations to be run at a later time when all declarations for the module,\n  // including forward refs, have resolved.\n  enqueueModuleForDelayedScoping(moduleType, ngModule);\n}\n\n/**\n * Compiles and adds the `mod`, `fac` and `inj` properties to the module class.\n *\n * It's possible to compile a module via this API which will allow duplicate declarations in its\n * root.\n */\nexport function compileNgModuleDefs(\n    moduleType: NgModuleType, ngModule: NgModule,\n    allowDuplicateDeclarationsInRoot: boolean = false): void {\n  ngDevMode && assertDefined(moduleType, 'Required value moduleType');\n  ngDevMode && assertDefined(ngModule, 'Required value ngModule');\n  const declarations: Type<any>[] = flatten(ngModule.declarations || EMPTY_ARRAY);\n  let ngModuleDef: any = null;\n  Object.defineProperty(moduleType, NG_MOD_DEF, {\n    configurable: true,\n    get: () => {\n      if (ngModuleDef === null) {\n        if (ngDevMode && ngModule.imports && ngModule.imports.indexOf(moduleType) > -1) {\n          // We need to assert this immediately, because allowing it to continue will cause it to\n          // go into an infinite loop before we've reached the point where we throw all the errors.\n          throw new Error(`'${stringifyForError(moduleType)}' module can't import itself`);\n        }\n        const compiler = getCompilerFacade(\n            {usage: JitCompilerUsage.Decorator, kind: 'NgModule', type: moduleType});\n        ngModuleDef = compiler.compileNgModule(angularCoreEnv, `ng:///${moduleType.name}/mod.js`, {\n          type: moduleType,\n          bootstrap: flatten(ngModule.bootstrap || EMPTY_ARRAY).map(resolveForwardRef),\n          declarations: declarations.map(resolveForwardRef),\n          imports: flatten(ngModule.imports || EMPTY_ARRAY)\n                       .map(resolveForwardRef)\n                       .map(expandModuleWithProviders),\n          exports: flatten(ngModule.exports || EMPTY_ARRAY)\n                       .map(resolveForwardRef)\n                       .map(expandModuleWithProviders),\n          schemas: ngModule.schemas ? flatten(ngModule.schemas) : null,\n          id: ngModule.id || null,\n        });\n        // Set `schemas` on ngModuleDef to an empty array in JIT mode to indicate that runtime\n        // should verify that there are no unknown elements in a template. In AOT mode, that check\n        // happens at compile time and `schemas` information is not present on Component and Module\n        // defs after compilation (so the check doesn't happen the second time at runtime).\n        if (!ngModuleDef.schemas) {\n          ngModuleDef.schemas = [];\n        }\n      }\n      return ngModuleDef;\n    }\n  });\n\n  let ngFactoryDef: any = null;\n  Object.defineProperty(moduleType, NG_FACTORY_DEF, {\n    get: () => {\n      if (ngFactoryDef === null) {\n        const compiler = getCompilerFacade(\n            {usage: JitCompilerUsage.Decorator, kind: 'NgModule', type: moduleType});\n        ngFactoryDef = compiler.compileFactory(angularCoreEnv, `ng:///${moduleType.name}/fac.js`, {\n          name: moduleType.name,\n          type: moduleType,\n          deps: reflectDependencies(moduleType),\n          target: compiler.FactoryTarget.NgModule,\n          typeArgumentCount: 0,\n        });\n      }\n      return ngFactoryDef;\n    },\n    // Make the property configurable in dev mode to allow overriding in tests\n    configurable: !!ngDevMode,\n  });\n\n  let ngInjectorDef: any = null;\n  Object.defineProperty(moduleType, NG_INJ_DEF, {\n    get: () => {\n      if (ngInjectorDef === null) {\n        ngDevMode && verifySemanticsOfNgModuleDef(moduleType, allowDuplicateDeclarationsInRoot);\n        const meta: R3InjectorMetadataFacade = {\n          name: moduleType.name,\n          type: moduleType,\n          providers: ngModule.providers || EMPTY_ARRAY,\n          imports: [\n            (ngModule.imports || EMPTY_ARRAY).map(resolveForwardRef),\n            (ngModule.exports || EMPTY_ARRAY).map(resolveForwardRef),\n          ],\n        };\n        const compiler = getCompilerFacade(\n            {usage: JitCompilerUsage.Decorator, kind: 'NgModule', type: moduleType});\n        ngInjectorDef =\n            compiler.compileInjector(angularCoreEnv, `ng:///${moduleType.name}/inj.js`, meta);\n      }\n      return ngInjectorDef;\n    },\n    // Make the property configurable in dev mode to allow overriding in tests\n    configurable: !!ngDevMode,\n  });\n}\n\nexport function generateStandaloneInDeclarationsError(type: Type<any>, location: string) {\n  const prefix = `Unexpected \"${stringifyForError(type)}\" found in the \"declarations\" array of the`;\n  const suffix = `\"${stringifyForError(type)}\" is marked as standalone and can't be declared ` +\n      'in any NgModule - did you intend to import it instead (by adding it to the \"imports\" array)?';\n  return `${prefix} ${location}, ${suffix}`;\n}\n\nfunction verifySemanticsOfNgModuleDef(\n    moduleType: NgModuleType, allowDuplicateDeclarationsInRoot: boolean,\n    importingModule?: NgModuleType): void {\n  if (verifiedNgModule.get(moduleType)) return;\n\n  // skip verifications of standalone components, directives, and pipes\n  if (isStandalone(moduleType)) return;\n\n  verifiedNgModule.set(moduleType, true);\n  moduleType = resolveForwardRef(moduleType);\n  let ngModuleDef: NgModuleDef<any>;\n  if (importingModule) {\n    ngModuleDef = getNgModuleDef(moduleType)!;\n    if (!ngModuleDef) {\n      throw new Error(`Unexpected value '${moduleType.name}' imported by the module '${\n          importingModule.name}'. Please add an @NgModule annotation.`);\n    }\n  } else {\n    ngModuleDef = getNgModuleDef(moduleType, true);\n  }\n  const errors: string[] = [];\n  const declarations = maybeUnwrapFn(ngModuleDef.declarations);\n  const imports = maybeUnwrapFn(ngModuleDef.imports);\n  flatten(imports).map(unwrapModuleWithProvidersImports).forEach(modOrStandaloneCmpt => {\n    verifySemanticsOfNgModuleImport(modOrStandaloneCmpt, moduleType);\n    verifySemanticsOfNgModuleDef(modOrStandaloneCmpt, false, moduleType);\n  });\n  const exports = maybeUnwrapFn(ngModuleDef.exports);\n  declarations.forEach(verifyDeclarationsHaveDefinitions);\n  declarations.forEach(verifyDirectivesHaveSelector);\n  declarations.forEach((declarationType) => verifyNotStandalone(declarationType, moduleType));\n  const combinedDeclarations: Type<any>[] = [\n    ...declarations.map(resolveForwardRef),\n    ...flatten(imports.map(computeCombinedExports)).map(resolveForwardRef),\n  ];\n  exports.forEach(verifyExportsAreDeclaredOrReExported);\n  declarations.forEach(decl => verifyDeclarationIsUnique(decl, allowDuplicateDeclarationsInRoot));\n\n  const ngModule = getAnnotation<NgModule>(moduleType, 'NgModule');\n  if (ngModule) {\n    ngModule.imports &&\n        flatten(ngModule.imports).map(unwrapModuleWithProvidersImports).forEach(mod => {\n          verifySemanticsOfNgModuleImport(mod, moduleType);\n          verifySemanticsOfNgModuleDef(mod, false, moduleType);\n        });\n    ngModule.bootstrap && deepForEach(ngModule.bootstrap, verifyCorrectBootstrapType);\n    ngModule.bootstrap && deepForEach(ngModule.bootstrap, verifyComponentIsPartOfNgModule);\n  }\n\n  // Throw Error if any errors were detected.\n  if (errors.length) {\n    throw new Error(errors.join('\\n'));\n  }\n  ////////////////////////////////////////////////////////////////////////////////////////////////\n  function verifyDeclarationsHaveDefinitions(type: Type<any>): void {\n    type = resolveForwardRef(type);\n    const def = getComponentDef(type) || getDirectiveDef(type) || getPipeDef(type);\n    if (!def) {\n      errors.push(`Unexpected value '${stringifyForError(type)}' declared by the module '${\n          stringifyForError(moduleType)}'. Please add a @Pipe/@Directive/@Component annotation.`);\n    }\n  }\n\n  function verifyDirectivesHaveSelector(type: Type<any>): void {\n    type = resolveForwardRef(type);\n    const def = getDirectiveDef(type);\n    if (!getComponentDef(type) && def && def.selectors.length == 0) {\n      errors.push(`Directive ${stringifyForError(type)} has no selector, please add it!`);\n    }\n  }\n\n  function verifyNotStandalone(type: Type<any>, moduleType: NgModuleType): void {\n    type = resolveForwardRef(type);\n    const def = getComponentDef(type) || getDirectiveDef(type) || getPipeDef(type);\n    if (def?.standalone) {\n      const location = `\"${stringifyForError(moduleType)}\" NgModule`;\n      errors.push(generateStandaloneInDeclarationsError(type, location));\n    }\n  }\n\n  function verifyExportsAreDeclaredOrReExported(type: Type<any>) {\n    type = resolveForwardRef(type);\n    const kind = getComponentDef(type) && 'component' || getDirectiveDef(type) && 'directive' ||\n        getPipeDef(type) && 'pipe';\n    if (kind) {\n      // only checked if we are declared as Component, Directive, or Pipe\n      // Modules don't need to be declared or imported.\n      if (combinedDeclarations.lastIndexOf(type) === -1) {\n        // We are exporting something which we don't explicitly declare or import.\n        errors.push(`Can't export ${kind} ${stringifyForError(type)} from ${\n            stringifyForError(moduleType)} as it was neither declared nor imported!`);\n      }\n    }\n  }\n\n  function verifyDeclarationIsUnique(type: Type<any>, suppressErrors: boolean) {\n    type = resolveForwardRef(type);\n    const existingModule = ownerNgModule.get(type);\n    if (existingModule && existingModule !== moduleType) {\n      if (!suppressErrors) {\n        const modules = [existingModule, moduleType].map(stringifyForError).sort();\n        errors.push(\n            `Type ${stringifyForError(type)} is part of the declarations of 2 modules: ${\n                modules[0]} and ${modules[1]}! ` +\n            `Please consider moving ${stringifyForError(type)} to a higher module that imports ${\n                modules[0]} and ${modules[1]}. ` +\n            `You can also create a new NgModule that exports and includes ${\n                stringifyForError(\n                    type)} then import that NgModule in ${modules[0]} and ${modules[1]}.`);\n      }\n    } else {\n      // Mark type as having owner.\n      ownerNgModule.set(type, moduleType);\n    }\n  }\n\n  function verifyComponentIsPartOfNgModule(type: Type<any>) {\n    type = resolveForwardRef(type);\n    const existingModule = ownerNgModule.get(type);\n    if (!existingModule && !isStandalone(type)) {\n      errors.push(`Component ${\n          stringifyForError(\n              type)} is not part of any NgModule or the module has not been imported into your module.`);\n    }\n  }\n\n  function verifyCorrectBootstrapType(type: Type<any>) {\n    type = resolveForwardRef(type);\n    if (!getComponentDef(type)) {\n      errors.push(`${stringifyForError(type)} cannot be used as an entry component.`);\n    }\n    if (isStandalone(type)) {\n      // Note: this error should be the same as the\n      // `NGMODULE_BOOTSTRAP_IS_STANDALONE` one in AOT compiler.\n      errors.push(\n          `The \\`${stringifyForError(type)}\\` class is a standalone component, which can ` +\n          `not be used in the \\`@NgModule.bootstrap\\` array. Use the \\`bootstrapApplication\\` ` +\n          `function for bootstrap instead.`);\n    }\n  }\n\n  function verifySemanticsOfNgModuleImport(type: Type<any>, importingModule: Type<any>) {\n    type = resolveForwardRef(type);\n\n    const directiveDef = getComponentDef(type) || getDirectiveDef(type);\n    if (directiveDef !== null && !directiveDef.standalone) {\n      throw new Error(`Unexpected directive '${type.name}' imported by the module '${\n          importingModule.name}'. Please add an @NgModule annotation.`);\n    }\n\n    const pipeDef = getPipeDef(type);\n    if (pipeDef !== null && !pipeDef.standalone) {\n      throw new Error(`Unexpected pipe '${type.name}' imported by the module '${\n          importingModule.name}'. Please add an @NgModule annotation.`);\n    }\n  }\n}\n\nfunction unwrapModuleWithProvidersImports(typeOrWithProviders: NgModuleType<any>|\n                                          {ngModule: NgModuleType<any>}): NgModuleType<any> {\n  typeOrWithProviders = resolveForwardRef(typeOrWithProviders);\n  return (typeOrWithProviders as any).ngModule || typeOrWithProviders;\n}\n\nfunction getAnnotation<T>(type: any, name: string): T|null {\n  let annotation: T|null = null;\n  collect(type.__annotations__);\n  collect(type.decorators);\n  return annotation;\n\n  function collect(annotations: any[]|null) {\n    if (annotations) {\n      annotations.forEach(readAnnotation);\n    }\n  }\n\n  function readAnnotation(\n      decorator: {type: {prototype: {ngMetadataName: string}, args: any[]}, args: any}): void {\n    if (!annotation) {\n      const proto = Object.getPrototypeOf(decorator);\n      if (proto.ngMetadataName == name) {\n        annotation = decorator as any;\n      } else if (decorator.type) {\n        const proto = Object.getPrototypeOf(decorator.type);\n        if (proto.ngMetadataName == name) {\n          annotation = decorator.args[0];\n        }\n      }\n    }\n  }\n}\n\n/**\n * Keep track of compiled components. This is needed because in tests we often want to compile the\n * same component with more than one NgModule. This would cause an error unless we reset which\n * NgModule the component belongs to. We keep the list of compiled components here so that the\n * TestBed can reset it later.\n */\nlet ownerNgModule = new WeakMap<Type<any>, NgModuleType<any>>();\nlet verifiedNgModule = new WeakMap<NgModuleType<any>, boolean>();\n\nexport function resetCompiledComponents(): void {\n  ownerNgModule = new WeakMap<Type<any>, NgModuleType<any>>();\n  verifiedNgModule = new WeakMap<NgModuleType<any>, boolean>();\n  moduleQueue.length = 0;\n  GENERATED_COMP_IDS.clear();\n}\n\n/**\n * Computes the combined declarations of explicit declarations, as well as declarations inherited by\n * traversing the exports of imported modules.\n * @param type\n */\nfunction computeCombinedExports(type: Type<any>): Type<any>[] {\n  type = resolveForwardRef(type);\n  const ngModuleDef = getNgModuleDef(type);\n\n  // a standalone component, directive or pipe\n  if (ngModuleDef === null) {\n    return [type];\n  }\n\n  return flatten(maybeUnwrapFn(ngModuleDef.exports).map((type) => {\n    const ngModuleDef = getNgModuleDef(type);\n    if (ngModuleDef) {\n      verifySemanticsOfNgModuleDef(type as any as NgModuleType, false);\n      return computeCombinedExports(type);\n    } else {\n      return type;\n    }\n  }));\n}\n\n/**\n * Some declared components may be compiled asynchronously, and thus may not have their\n * cmp set yet. If this is the case, then a reference to the module is written into\n * the `ngSelectorScope` property of the declared type.\n */\nfunction setScopeOnDeclaredComponents(moduleType: Type<any>, ngModule: NgModule) {\n  const declarations: Type<any>[] = flatten(ngModule.declarations || EMPTY_ARRAY);\n\n  const transitiveScopes = transitiveScopesFor(moduleType);\n\n  declarations.forEach(declaration => {\n    declaration = resolveForwardRef(declaration);\n    if (declaration.hasOwnProperty(NG_COMP_DEF)) {\n      // A `cmp` field exists - go ahead and patch the component directly.\n      const component = declaration as Type<any>& {cmp: ComponentDef<any>};\n      const componentDef = getComponentDef(component)!;\n      patchComponentDefWithScope(componentDef, transitiveScopes);\n    } else if (\n        !declaration.hasOwnProperty(NG_DIR_DEF) && !declaration.hasOwnProperty(NG_PIPE_DEF)) {\n      // Set `ngSelectorScope` for future reference when the component compilation finishes.\n      (declaration as Type<any>& {ngSelectorScope?: any}).ngSelectorScope = moduleType;\n    }\n  });\n}\n\n/**\n * Patch the definition of a component with directives and pipes from the compilation scope of\n * a given module.\n */\nexport function patchComponentDefWithScope<C>(\n    componentDef: ComponentDef<C>, transitiveScopes: NgModuleTransitiveScopes) {\n  componentDef.directiveDefs = () =>\n      Array.from(transitiveScopes.compilation.directives)\n          .map(\n              dir => dir.hasOwnProperty(NG_COMP_DEF) ? getComponentDef(dir)! : getDirectiveDef(dir)!\n              )\n          .filter(def => !!def);\n  componentDef.pipeDefs = () =>\n      Array.from(transitiveScopes.compilation.pipes).map(pipe => getPipeDef(pipe)!);\n  componentDef.schemas = transitiveScopes.schemas;\n\n  // Since we avoid Components/Directives/Pipes recompiling in case there are no overrides, we\n  // may face a problem where previously compiled defs available to a given Component/Directive\n  // are cached in TView and may become stale (in case any of these defs gets recompiled). In\n  // order to avoid this problem, we force fresh TView to be created.\n  componentDef.tView = null;\n}\n\n/**\n * Compute the pair of transitive scopes (compilation scope and exported scope) for a given type\n * (either a NgModule or a standalone component / directive / pipe).\n */\nexport function transitiveScopesFor<T>(type: Type<T>): NgModuleTransitiveScopes {\n  if (isNgModule(type)) {\n    if (USE_RUNTIME_DEPS_TRACKER_FOR_JIT) {\n      const scope = depsTracker.getNgModuleScope(type);\n      const def = getNgModuleDef(type, true);\n      return {\n        schemas: def.schemas || null,\n        ...scope,\n      };\n    } else {\n      return transitiveScopesForNgModule(type);\n    }\n  } else if (isStandalone(type)) {\n    const directiveDef = getComponentDef(type) || getDirectiveDef(type);\n    if (directiveDef !== null) {\n      return {\n        schemas: null,\n        compilation: {\n          directives: new Set<any>(),\n          pipes: new Set<any>(),\n        },\n        exported: {\n          directives: new Set<any>([type]),\n          pipes: new Set<any>(),\n        },\n      };\n    }\n\n    const pipeDef = getPipeDef(type);\n    if (pipeDef !== null) {\n      return {\n        schemas: null,\n        compilation: {\n          directives: new Set<any>(),\n          pipes: new Set<any>(),\n        },\n        exported: {\n          directives: new Set<any>(),\n          pipes: new Set<any>([type]),\n        },\n      };\n    }\n  }\n\n  // TODO: change the error message to be more user-facing and take standalone into account\n  throw new Error(`${type.name} does not have a module def (mod property)`);\n}\n\n/**\n * Compute the pair of transitive scopes (compilation scope and exported scope) for a given module.\n *\n * This operation is memoized and the result is cached on the module's definition. This function can\n * be called on modules with components that have not fully compiled yet, but the result should not\n * be used until they have.\n *\n * @param moduleType module that transitive scope should be calculated for.\n */\nexport function transitiveScopesForNgModule<T>(moduleType: Type<T>): NgModuleTransitiveScopes {\n  const def = getNgModuleDef(moduleType, true);\n\n  if (def.transitiveCompileScopes !== null) {\n    return def.transitiveCompileScopes;\n  }\n\n  const scopes: NgModuleTransitiveScopes = {\n    schemas: def.schemas || null,\n    compilation: {\n      directives: new Set<any>(),\n      pipes: new Set<any>(),\n    },\n    exported: {\n      directives: new Set<any>(),\n      pipes: new Set<any>(),\n    },\n  };\n\n  maybeUnwrapFn(def.imports).forEach(<I>(imported: Type<I>) => {\n    // When this module imports another, the imported module's exported directives and pipes are\n    // added to the compilation scope of this module.\n    const importedScope = transitiveScopesFor(imported);\n    importedScope.exported.directives.forEach(entry => scopes.compilation.directives.add(entry));\n    importedScope.exported.pipes.forEach(entry => scopes.compilation.pipes.add(entry));\n  });\n\n  maybeUnwrapFn(def.declarations).forEach(declared => {\n    const declaredWithDefs = declared as Type<any>& {\n      pipe?: any;\n    };\n\n    if (getPipeDef(declaredWithDefs)) {\n      scopes.compilation.pipes.add(declared);\n    } else {\n      // Either declared has a cmp or dir, or it's a component which hasn't\n      // had its template compiled yet. In either case, it gets added to the compilation's\n      // directives.\n      scopes.compilation.directives.add(declared);\n    }\n  });\n\n  maybeUnwrapFn(def.exports).forEach(<E>(exported: Type<E>) => {\n    const exportedType = exported as Type<E>& {\n      // Components, Directives, NgModules, and Pipes can all be exported.\n      cmp?: any;\n      dir?: any;\n      mod?: NgModuleDef<E>;\n      pipe?: any;\n    };\n\n    // Either the type is a module, a pipe, or a component/directive (which may not have a\n    // cmp as it might be compiled asynchronously).\n    if (isNgModule(exportedType)) {\n      // When this module exports another, the exported module's exported directives and pipes are\n      // added to both the compilation and exported scopes of this module.\n      const exportedScope = transitiveScopesFor(exportedType);\n      exportedScope.exported.directives.forEach(entry => {\n        scopes.compilation.directives.add(entry);\n        scopes.exported.directives.add(entry);\n      });\n      exportedScope.exported.pipes.forEach(entry => {\n        scopes.compilation.pipes.add(entry);\n        scopes.exported.pipes.add(entry);\n      });\n    } else if (getPipeDef(exportedType)) {\n      scopes.exported.pipes.add(exportedType);\n    } else {\n      scopes.exported.directives.add(exportedType);\n    }\n  });\n\n  def.transitiveCompileScopes = scopes;\n  return scopes;\n}\n\nfunction expandModuleWithProviders(value: Type<any>|ModuleWithProviders<{}>): Type<any> {\n  if (isModuleWithProviders(value)) {\n    return value.ngModule;\n  }\n  return value;\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {getCompilerFacade, JitCompilerUsage, R3DirectiveMetadataFacade} from '../../compiler/compiler_facade';\nimport {R3ComponentMetadataFacade, R3QueryMetadataFacade} from '../../compiler/compiler_facade_interface';\nimport {resolveForwardRef} from '../../di/forward_ref';\nimport {getReflect, reflectDependencies} from '../../di/jit/util';\nimport {Type} from '../../interface/type';\nimport {Query} from '../../metadata/di';\nimport {Component, Directive, Input} from '../../metadata/directives';\nimport {componentNeedsResolution, maybeQueueResolutionOfComponentResources} from '../../metadata/resource_loading';\nimport {ViewEncapsulation} from '../../metadata/view';\nimport {flatten} from '../../util/array_utils';\nimport {EMPTY_ARRAY, EMPTY_OBJ} from '../../util/empty';\nimport {initNgDevMode} from '../../util/ng_dev_mode';\nimport {getComponentDef, getDirectiveDef, getNgModuleDef, getPipeDef} from '../definition';\nimport {depsTracker, USE_RUNTIME_DEPS_TRACKER_FOR_JIT} from '../deps_tracker/deps_tracker';\nimport {NG_COMP_DEF, NG_DIR_DEF, NG_FACTORY_DEF} from '../fields';\nimport {ComponentDef, ComponentType, DirectiveDefList, PipeDefList} from '../interfaces/definition';\nimport {stringifyForError} from '../util/stringify_utils';\n\nimport {angularCoreEnv} from './environment';\nimport {getJitOptions} from './jit_options';\nimport {flushModuleScopingQueueAsMuchAsPossible, patchComponentDefWithScope, transitiveScopesFor} from './module';\nimport {isComponent, verifyStandaloneImport} from './util';\n\n/**\n * Keep track of the compilation depth to avoid reentrancy issues during JIT compilation. This\n * matters in the following scenario:\n *\n * Consider a component 'A' that extends component 'B', both declared in module 'M'. During\n * the compilation of 'A' the definition of 'B' is requested to capture the inheritance chain,\n * potentially triggering compilation of 'B'. If this nested compilation were to trigger\n * `flushModuleScopingQueueAsMuchAsPossible` it may happen that module 'M' is still pending in the\n * queue, resulting in 'A' and 'B' to be patched with the NgModule scope. As the compilation of\n * 'A' is still in progress, this would introduce a circular dependency on its compilation. To avoid\n * this issue, the module scope queue is only flushed for compilations at the depth 0, to ensure\n * all compilations have finished.\n */\nlet compilationDepth = 0;\n\n/**\n * Compile an Angular component according to its decorator metadata, and patch the resulting\n * component def (cmp) onto the component type.\n *\n * Compilation may be asynchronous (due to the need to resolve URLs for the component template or\n * other resources, for example). In the event that compilation is not immediate, `compileComponent`\n * will enqueue resource resolution into a global queue and will fail to return the `cmp`\n * until the global queue has been resolved with a call to `resolveComponentResources`.\n */\nexport function compileComponent(type: Type<any>, metadata: Component): void {\n  // Initialize ngDevMode. This must be the first statement in compileComponent.\n  // See the `initNgDevMode` docstring for more information.\n  (typeof ngDevMode === 'undefined' || ngDevMode) && initNgDevMode();\n\n  let ngComponentDef: ComponentDef<unknown>|null = null;\n\n  // Metadata may have resources which need to be resolved.\n  maybeQueueResolutionOfComponentResources(type, metadata);\n\n  // Note that we're using the same function as `Directive`, because that's only subset of metadata\n  // that we need to create the ngFactoryDef. We're avoiding using the component metadata\n  // because we'd have to resolve the asynchronous templates.\n  addDirectiveFactoryDef(type, metadata);\n\n  Object.defineProperty(type, NG_COMP_DEF, {\n    get: () => {\n      if (ngComponentDef === null) {\n        const compiler =\n            getCompilerFacade({usage: JitCompilerUsage.Decorator, kind: 'component', type: type});\n\n        if (componentNeedsResolution(metadata)) {\n          const error = [`Component '${type.name}' is not resolved:`];\n          if (metadata.templateUrl) {\n            error.push(` - templateUrl: ${metadata.templateUrl}`);\n          }\n          if (metadata.styleUrls && metadata.styleUrls.length) {\n            error.push(` - styleUrls: ${JSON.stringify(metadata.styleUrls)}`);\n          }\n          if (metadata.styleUrl) {\n            error.push(` - styleUrl: ${metadata.styleUrl}`);\n          }\n          error.push(`Did you run and wait for 'resolveComponentResources()'?`);\n          throw new Error(error.join('\\n'));\n        }\n\n        // This const was called `jitOptions` previously but had to be renamed to `options` because\n        // of a bug with Terser that caused optimized JIT builds to throw a `ReferenceError`.\n        // This bug was investigated in https://github.com/angular/angular-cli/issues/17264.\n        // We should not rename it back until https://github.com/terser/terser/issues/615 is fixed.\n        const options = getJitOptions();\n        let preserveWhitespaces = metadata.preserveWhitespaces;\n        if (preserveWhitespaces === undefined) {\n          if (options !== null && options.preserveWhitespaces !== undefined) {\n            preserveWhitespaces = options.preserveWhitespaces;\n          } else {\n            preserveWhitespaces = false;\n          }\n        }\n        let encapsulation = metadata.encapsulation;\n        if (encapsulation === undefined) {\n          if (options !== null && options.defaultEncapsulation !== undefined) {\n            encapsulation = options.defaultEncapsulation;\n          } else {\n            encapsulation = ViewEncapsulation.Emulated;\n          }\n        }\n\n        const templateUrl = metadata.templateUrl || `ng:///${type.name}/template.html`;\n        const meta: R3ComponentMetadataFacade = {\n          ...directiveMetadata(type, metadata),\n          typeSourceSpan: compiler.createParseSourceSpan('Component', type.name, templateUrl),\n          template: metadata.template || '',\n          preserveWhitespaces,\n          styles: typeof metadata.styles === 'string' ? [metadata.styles] :\n                                                        (metadata.styles || EMPTY_ARRAY),\n          animations: metadata.animations,\n          // JIT components are always compiled against an empty set of `declarations`. Instead, the\n          // `directiveDefs` and `pipeDefs` are updated at a later point:\n          //  * for NgModule-based components, they're set when the NgModule which declares the\n          //    component resolves in the module scoping queue\n          //  * for standalone components, they're set just below, after `compileComponent`.\n          declarations: [],\n          changeDetection: metadata.changeDetection,\n          encapsulation,\n          interpolation: metadata.interpolation,\n          viewProviders: metadata.viewProviders || null,\n        };\n\n        compilationDepth++;\n        try {\n          if (meta.usesInheritance) {\n            addDirectiveDefToUndecoratedParents(type);\n          }\n          ngComponentDef =\n              compiler.compileComponent(angularCoreEnv, templateUrl, meta) as ComponentDef<unknown>;\n\n          if (metadata.standalone) {\n            // Patch the component definition for standalone components with `directiveDefs` and\n            // `pipeDefs` functions which lazily compute the directives/pipes available in the\n            // standalone component. Also set `dependencies` to the lazily resolved list of imports.\n            const imports: Type<any>[] = flatten(metadata.imports || EMPTY_ARRAY);\n            const {directiveDefs, pipeDefs} = getStandaloneDefFunctions(type, imports);\n            ngComponentDef.directiveDefs = directiveDefs;\n            ngComponentDef.pipeDefs = pipeDefs;\n            ngComponentDef.dependencies = () => imports.map(resolveForwardRef);\n          }\n        } finally {\n          // Ensure that the compilation depth is decremented even when the compilation failed.\n          compilationDepth--;\n        }\n\n        if (compilationDepth === 0) {\n          // When NgModule decorator executed, we enqueued the module definition such that\n          // it would only dequeue and add itself as module scope to all of its declarations,\n          // but only if  if all of its declarations had resolved. This call runs the check\n          // to see if any modules that are in the queue can be dequeued and add scope to\n          // their declarations.\n          flushModuleScopingQueueAsMuchAsPossible();\n        }\n\n        // If component compilation is async, then the @NgModule annotation which declares the\n        // component may execute and set an ngSelectorScope property on the component type. This\n        // allows the component to patch itself with directiveDefs from the module after it\n        // finishes compiling.\n        if (hasSelectorScope(type)) {\n          const scopes = transitiveScopesFor(type.ngSelectorScope);\n          patchComponentDefWithScope(ngComponentDef, scopes);\n        }\n\n        if (metadata.schemas) {\n          if (metadata.standalone) {\n            ngComponentDef.schemas = metadata.schemas;\n          } else {\n            throw new Error(`The 'schemas' was specified for the ${\n                stringifyForError(type)} but is only valid on a component that is standalone.`);\n          }\n        } else if (metadata.standalone) {\n          ngComponentDef.schemas = [];\n        }\n      }\n      return ngComponentDef;\n    },\n    // Make the property configurable in dev mode to allow overriding in tests\n    configurable: !!ngDevMode,\n  });\n}\n\n/**\n * Build memoized `directiveDefs` and `pipeDefs` functions for the component definition of a\n * standalone component, which process `imports` and filter out directives and pipes. The use of\n * memoized functions here allows for the delayed resolution of any `forwardRef`s present in the\n * component's `imports`.\n */\nfunction getStandaloneDefFunctions(type: Type<any>, imports: Type<any>[]): {\n  directiveDefs: () => DirectiveDefList,\n  pipeDefs: () => PipeDefList,\n} {\n  let cachedDirectiveDefs: DirectiveDefList|null = null;\n  let cachedPipeDefs: PipeDefList|null = null;\n  const directiveDefs = () => {\n    if (!USE_RUNTIME_DEPS_TRACKER_FOR_JIT) {\n      if (cachedDirectiveDefs === null) {\n        // Standalone components are always able to self-reference, so include the component's own\n        // definition in its `directiveDefs`.\n        cachedDirectiveDefs = [getComponentDef(type)!];\n        const seen = new Set<Type<unknown>>([type]);\n\n        for (const rawDep of imports) {\n          ngDevMode && verifyStandaloneImport(rawDep, type);\n\n          const dep = resolveForwardRef(rawDep);\n          if (seen.has(dep)) {\n            continue;\n          }\n          seen.add(dep);\n\n          if (!!getNgModuleDef(dep)) {\n            const scope = transitiveScopesFor(dep);\n            for (const dir of scope.exported.directives) {\n              const def = getComponentDef(dir) || getDirectiveDef(dir);\n              if (def && !seen.has(dir)) {\n                seen.add(dir);\n                cachedDirectiveDefs.push(def);\n              }\n            }\n          } else {\n            const def = getComponentDef(dep) || getDirectiveDef(dep);\n            if (def) {\n              cachedDirectiveDefs.push(def);\n            }\n          }\n        }\n      }\n      return cachedDirectiveDefs;\n    } else {\n      if (ngDevMode) {\n        for (const rawDep of imports) {\n          verifyStandaloneImport(rawDep, type);\n        }\n      }\n\n      if (!isComponent(type)) {\n        return [];\n      }\n\n      const scope = depsTracker.getStandaloneComponentScope(type, imports);\n\n      return [...scope.compilation.directives]\n          .map(p => (getComponentDef(p) || getDirectiveDef(p))!)\n          .filter(d => d !== null);\n    }\n  };\n\n  const pipeDefs = () => {\n    if (!USE_RUNTIME_DEPS_TRACKER_FOR_JIT) {\n      if (cachedPipeDefs === null) {\n        cachedPipeDefs = [];\n        const seen = new Set<Type<unknown>>();\n\n        for (const rawDep of imports) {\n          const dep = resolveForwardRef(rawDep);\n          if (seen.has(dep)) {\n            continue;\n          }\n          seen.add(dep);\n\n          if (!!getNgModuleDef(dep)) {\n            const scope = transitiveScopesFor(dep);\n            for (const pipe of scope.exported.pipes) {\n              const def = getPipeDef(pipe);\n              if (def && !seen.has(pipe)) {\n                seen.add(pipe);\n                cachedPipeDefs.push(def);\n              }\n            }\n          } else {\n            const def = getPipeDef(dep);\n            if (def) {\n              cachedPipeDefs.push(def);\n            }\n          }\n        }\n      }\n      return cachedPipeDefs;\n    } else {\n      if (ngDevMode) {\n        for (const rawDep of imports) {\n          verifyStandaloneImport(rawDep, type);\n        }\n      }\n\n      if (!isComponent(type)) {\n        return [];\n      }\n\n      const scope = depsTracker.getStandaloneComponentScope(type, imports);\n\n      return [...scope.compilation.pipes].map(p => getPipeDef(p)!).filter(d => d !== null);\n    }\n  };\n\n  return {\n    directiveDefs,\n    pipeDefs,\n  };\n}\n\nfunction hasSelectorScope<T>(component: Type<T>): component is Type<T>&\n    {ngSelectorScope: Type<any>} {\n  return (component as {ngSelectorScope?: any}).ngSelectorScope !== undefined;\n}\n\n/**\n * Compile an Angular directive according to its decorator metadata, and patch the resulting\n * directive def onto the component type.\n *\n * In the event that compilation is not immediate, `compileDirective` will return a `Promise` which\n * will resolve when compilation completes and the directive becomes usable.\n */\nexport function compileDirective(type: Type<any>, directive: Directive|null): void {\n  let ngDirectiveDef: any = null;\n\n  addDirectiveFactoryDef(type, directive || {});\n\n  Object.defineProperty(type, NG_DIR_DEF, {\n    get: () => {\n      if (ngDirectiveDef === null) {\n        // `directive` can be null in the case of abstract directives as a base class\n        // that use `@Directive()` with no selector. In that case, pass empty object to the\n        // `directiveMetadata` function instead of null.\n        const meta = getDirectiveMetadata(type, directive || {});\n        const compiler =\n            getCompilerFacade({usage: JitCompilerUsage.Decorator, kind: 'directive', type});\n        ngDirectiveDef =\n            compiler.compileDirective(angularCoreEnv, meta.sourceMapUrl, meta.metadata);\n      }\n      return ngDirectiveDef;\n    },\n    // Make the property configurable in dev mode to allow overriding in tests\n    configurable: !!ngDevMode,\n  });\n}\n\nfunction getDirectiveMetadata(type: Type<any>, metadata: Directive) {\n  const name = type && type.name;\n  const sourceMapUrl = `ng:///${name}/dir.js`;\n  const compiler = getCompilerFacade({usage: JitCompilerUsage.Decorator, kind: 'directive', type});\n  const facade = directiveMetadata(type as ComponentType<any>, metadata);\n  facade.typeSourceSpan = compiler.createParseSourceSpan('Directive', name, sourceMapUrl);\n  if (facade.usesInheritance) {\n    addDirectiveDefToUndecoratedParents(type);\n  }\n  return {metadata: facade, sourceMapUrl};\n}\n\nfunction addDirectiveFactoryDef(type: Type<any>, metadata: Directive|Component) {\n  let ngFactoryDef: any = null;\n\n  Object.defineProperty(type, NG_FACTORY_DEF, {\n    get: () => {\n      if (ngFactoryDef === null) {\n        const meta = getDirectiveMetadata(type, metadata);\n        const compiler =\n            getCompilerFacade({usage: JitCompilerUsage.Decorator, kind: 'directive', type});\n        ngFactoryDef = compiler.compileFactory(angularCoreEnv, `ng:///${type.name}/fac.js`, {\n          name: meta.metadata.name,\n          type: meta.metadata.type,\n          typeArgumentCount: 0,\n          deps: reflectDependencies(type),\n          target: compiler.FactoryTarget.Directive\n        });\n      }\n      return ngFactoryDef;\n    },\n    // Make the property configurable in dev mode to allow overriding in tests\n    configurable: !!ngDevMode,\n  });\n}\n\nexport function extendsDirectlyFromObject(type: Type<any>): boolean {\n  return Object.getPrototypeOf(type.prototype) === Object.prototype;\n}\n\n/**\n * Extract the `R3DirectiveMetadata` for a particular directive (either a `Directive` or a\n * `Component`).\n */\nexport function directiveMetadata(type: Type<any>, metadata: Directive): R3DirectiveMetadataFacade {\n  // Reflect inputs and outputs.\n  const reflect = getReflect();\n  const propMetadata = reflect.ownPropMetadata(type);\n\n  return {\n    name: type.name,\n    type: type,\n    selector: metadata.selector !== undefined ? metadata.selector : null,\n    host: metadata.host || EMPTY_OBJ,\n    propMetadata: propMetadata,\n    inputs: metadata.inputs || EMPTY_ARRAY,\n    outputs: metadata.outputs || EMPTY_ARRAY,\n    queries: extractQueriesMetadata(type, propMetadata, isContentQuery),\n    lifecycle: {usesOnChanges: reflect.hasLifecycleHook(type, 'ngOnChanges')},\n    typeSourceSpan: null!,\n    usesInheritance: !extendsDirectlyFromObject(type),\n    exportAs: extractExportAs(metadata.exportAs),\n    providers: metadata.providers || null,\n    viewQueries: extractQueriesMetadata(type, propMetadata, isViewQuery),\n    isStandalone: !!metadata.standalone,\n    isSignal: !!metadata.signals,\n    hostDirectives: metadata.hostDirectives?.map(\n                        directive => typeof directive === 'function' ? {directive} : directive) ||\n        null\n  };\n}\n\n/**\n * Adds a directive definition to all parent classes of a type that don't have an Angular decorator.\n */\nfunction addDirectiveDefToUndecoratedParents(type: Type<any>) {\n  const objPrototype = Object.prototype;\n  let parent = Object.getPrototypeOf(type.prototype).constructor;\n\n  // Go up the prototype until we hit `Object`.\n  while (parent && parent !== objPrototype) {\n    // Since inheritance works if the class was annotated already, we only need to add\n    // the def if there are no annotations and the def hasn't been created already.\n    if (!getDirectiveDef(parent) && !getComponentDef(parent) &&\n        shouldAddAbstractDirective(parent)) {\n      compileDirective(parent, null);\n    }\n    parent = Object.getPrototypeOf(parent);\n  }\n}\n\nfunction convertToR3QueryPredicate(selector: any): any|string[] {\n  return typeof selector === 'string' ? splitByComma(selector) : resolveForwardRef(selector);\n}\n\nexport function convertToR3QueryMetadata(propertyName: string, ann: Query): R3QueryMetadataFacade {\n  return {\n    propertyName: propertyName,\n    predicate: convertToR3QueryPredicate(ann.selector),\n    descendants: ann.descendants,\n    first: ann.first,\n    read: ann.read ? ann.read : null,\n    static: !!ann.static,\n    emitDistinctChangesOnly: !!ann.emitDistinctChangesOnly,\n  };\n}\nfunction extractQueriesMetadata(\n    type: Type<any>, propMetadata: {[key: string]: any[]},\n    isQueryAnn: (ann: any) => ann is Query): R3QueryMetadataFacade[] {\n  const queriesMeta: R3QueryMetadataFacade[] = [];\n  for (const field in propMetadata) {\n    if (propMetadata.hasOwnProperty(field)) {\n      const annotations = propMetadata[field];\n      annotations.forEach(ann => {\n        if (isQueryAnn(ann)) {\n          if (!ann.selector) {\n            throw new Error(\n                `Can't construct a query for the property \"${field}\" of ` +\n                `\"${stringifyForError(type)}\" since the query selector wasn't defined.`);\n          }\n          if (annotations.some(isInputAnnotation)) {\n            throw new Error(`Cannot combine @Input decorators with query decorators`);\n          }\n          queriesMeta.push(convertToR3QueryMetadata(field, ann));\n        }\n      });\n    }\n  }\n  return queriesMeta;\n}\n\nfunction extractExportAs(exportAs: string|undefined): string[]|null {\n  return exportAs === undefined ? null : splitByComma(exportAs);\n}\n\nfunction isContentQuery(value: any): value is Query {\n  const name = value.ngMetadataName;\n  return name === 'ContentChild' || name === 'ContentChildren';\n}\n\nfunction isViewQuery(value: any): value is Query {\n  const name = value.ngMetadataName;\n  return name === 'ViewChild' || name === 'ViewChildren';\n}\n\nfunction isInputAnnotation(value: any): value is Input {\n  return value.ngMetadataName === 'Input';\n}\n\nfunction splitByComma(value: string): string[] {\n  return value.split(',').map(piece => piece.trim());\n}\n\nconst LIFECYCLE_HOOKS = [\n  'ngOnChanges', 'ngOnInit', 'ngOnDestroy', 'ngDoCheck', 'ngAfterViewInit', 'ngAfterViewChecked',\n  'ngAfterContentInit', 'ngAfterContentChecked'\n];\n\nfunction shouldAddAbstractDirective(type: Type<any>): boolean {\n  const reflect = getReflect();\n\n  if (LIFECYCLE_HOOKS.some(hookName => reflect.hasLifecycleHook(type, hookName))) {\n    return true;\n  }\n\n  const propMetadata = reflect.propMetadata(type);\n\n  for (const field in propMetadata) {\n    const annotations = propMetadata[field];\n\n    for (let i = 0; i < annotations.length; i++) {\n      const current = annotations[i];\n      const metadataName = current.ngMetadataName;\n\n      if (isInputAnnotation(current) || isContentQuery(current) || isViewQuery(current) ||\n          metadataName === 'Output' || metadataName === 'HostBinding' ||\n          metadataName === 'HostListener') {\n        return true;\n      }\n    }\n  }\n\n  return false;\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {getCompilerFacade, JitCompilerUsage, R3PipeMetadataFacade} from '../../compiler/compiler_facade';\nimport {reflectDependencies} from '../../di/jit/util';\nimport {Type} from '../../interface/type';\nimport {Pipe} from '../../metadata/directives';\nimport {NG_FACTORY_DEF, NG_PIPE_DEF} from '../fields';\n\nimport {angularCoreEnv} from './environment';\n\nexport function compilePipe(type: Type<any>, meta: Pipe): void {\n  let ngPipeDef: any = null;\n  let ngFactoryDef: any = null;\n\n  Object.defineProperty(type, NG_FACTORY_DEF, {\n    get: () => {\n      if (ngFactoryDef === null) {\n        const metadata = getPipeMetadata(type, meta);\n        const compiler = getCompilerFacade(\n            {usage: JitCompilerUsage.Decorator, kind: 'pipe', type: metadata.type});\n        ngFactoryDef = compiler.compileFactory(angularCoreEnv, `ng:///${metadata.name}/fac.js`, {\n          name: metadata.name,\n          type: metadata.type,\n          typeArgumentCount: 0,\n          deps: reflectDependencies(type),\n          target: compiler.FactoryTarget.Pipe\n        });\n      }\n      return ngFactoryDef;\n    },\n    // Make the property configurable in dev mode to allow overriding in tests\n    configurable: !!ngDevMode,\n  });\n\n  Object.defineProperty(type, NG_PIPE_DEF, {\n    get: () => {\n      if (ngPipeDef === null) {\n        const metadata = getPipeMetadata(type, meta);\n        const compiler = getCompilerFacade(\n            {usage: JitCompilerUsage.Decorator, kind: 'pipe', type: metadata.type});\n        ngPipeDef =\n            compiler.compilePipe(angularCoreEnv, `ng:///${metadata.name}/pipe.js`, metadata);\n      }\n      return ngPipeDef;\n    },\n    // Make the property configurable in dev mode to allow overriding in tests\n    configurable: !!ngDevMode,\n  });\n}\n\nfunction getPipeMetadata(type: Type<any>, meta: Pipe): R3PipeMetadataFacade {\n  return {\n    type: type,\n    name: type.name,\n    pipeName: meta.name,\n    pure: meta.pure !== undefined ? meta.pure : true,\n    isStandalone: !!meta.standalone,\n  };\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {ChangeDetectionStrategy} from '../change_detection/constants';\nimport {Provider} from '../di/interface/provider';\nimport {Type} from '../interface/type';\nimport {compileComponent, compileDirective} from '../render3/jit/directive';\nimport {compilePipe} from '../render3/jit/pipe';\nimport {makeDecorator, makePropDecorator, TypeDecorator} from '../util/decorators';\n\nimport {SchemaMetadata} from './schema';\nimport {ViewEncapsulation} from './view';\n\n\n\n/**\n * Type of the Directive decorator / constructor function.\n * @publicApi\n */\nexport interface DirectiveDecorator {\n  /**\n   * Decorator that marks a class as an Angular directive.\n   * You can define your own directives to attach custom behavior to elements in the DOM.\n   *\n   * The options provide configuration metadata that determines\n   * how the directive should be processed, instantiated and used at\n   * runtime.\n   *\n   * Directive classes, like component classes, can implement\n   * [life-cycle hooks](guide/lifecycle-hooks) to influence their configuration and behavior.\n   *\n   *\n   * @usageNotes\n   * To define a directive, mark the class with the decorator and provide metadata.\n   *\n   * ```ts\n   * import {Directive} from '@angular/core';\n   *\n   * @Directive({\n   *   selector: 'my-directive',\n   * })\n   * export class MyDirective {\n   * ...\n   * }\n   * ```\n   *\n   * ### Declaring directives\n   *\n   * In order to make a directive available to other components in your application, you should do\n   * one of the following:\n   *  - either mark the directive as [standalone](guide/standalone-components),\n   *  - or declare it in an NgModule by adding it to the `declarations` and `exports` fields.\n   *\n   * ** Marking a directive as standalone **\n   *\n   * You can add the `standalone: true` flag to the Directive decorator metadata to declare it as\n   * [standalone](guide/standalone-components):\n   *\n   * ```ts\n   * @Directive({\n   *   standalone: true,\n   *   selector: 'my-directive',\n   * })\n   * class MyDirective {}\n   * ```\n   *\n   * When marking a directive as standalone, please make sure that the directive is not already\n   * declared in an NgModule.\n   *\n   *\n   * ** Declaring a directive in an NgModule **\n   *\n   * Another approach is to declare a directive in an NgModule:\n   *\n   * ```ts\n   * @Directive({\n   *   selector: 'my-directive',\n   * })\n   * class MyDirective {}\n   *\n   * @NgModule({\n   *   declarations: [MyDirective, SomeComponent],\n   *   exports: [MyDirective], // making it available outside of this module\n   * })\n   * class SomeNgModule {}\n   * ```\n   *\n   * When declaring a directive in an NgModule, please make sure that:\n   *  - the directive is declared in exactly one NgModule.\n   *  - the directive is not standalone.\n   *  - you do not re-declare a directive imported from another module.\n   *  - the directive is included into the `exports` field as well if you want this directive to be\n   *    accessible for components outside of the NgModule.\n   *\n   *\n   * @Annotation\n   */\n  (obj?: Directive): TypeDecorator;\n\n  /**\n   * See the `Directive` decorator.\n   */\n  new(obj?: Directive): Directive;\n}\n\n/**\n * Directive decorator and metadata.\n *\n * @Annotation\n * @publicApi\n */\nexport interface Directive {\n  /**\n   * The CSS selector that identifies this directive in a template\n   * and triggers instantiation of the directive.\n   *\n   * Declare as one of the following:\n   *\n   * - `element-name`: Select by element name.\n   * - `.class`: Select by class name.\n   * - `[attribute]`: Select by attribute name.\n   * - `[attribute=value]`: Select by attribute name and value.\n   * - `:not(sub_selector)`: Select only if the element does not match the `sub_selector`.\n   * - `selector1, selector2`: Select if either `selector1` or `selector2` matches.\n   *\n   * Angular only allows directives to apply on CSS selectors that do not cross\n   * element boundaries.\n   *\n   * For the following template HTML, a directive with an `input[type=text]` selector,\n   * would be instantiated only on the `<input type=\"text\">` element.\n   *\n   * ```html\n   * <form>\n   *   <input type=\"text\">\n   *   <input type=\"radio\">\n   * <form>\n   * ```\n   *\n   */\n  selector?: string;\n\n  /**\n   * Enumerates the set of data-bound input properties for a directive\n   *\n   * Angular automatically updates input properties during change detection.\n   * The `inputs` property accepts either strings or object literals that configure the directive\n   * properties that should be exposed as inputs.\n   *\n   * When an object literal is passed in, the `name` property indicates which property on the\n   * class the input should write to, while the `alias` determines the name under\n   * which the input will be available in template bindings. The `required` property indicates that\n   * the input is required which will trigger a compile-time error if it isn't passed in when the\n   * directive is used.\n   *\n   * When a string is passed into the `inputs` array, it can have a format of `'name'` or\n   * `'name: alias'` where `name` is the property on the class that the directive should write\n   * to, while the `alias` determines the name under which the input will be available in\n   * template bindings. String-based input definitions are assumed to be optional.\n   *\n   * @usageNotes\n   *\n   * The following example creates a component with two data-bound properties.\n   *\n   * ```typescript\n   * @Component({\n   *   selector: 'bank-account',\n   *   inputs: ['bankName', {name: 'id', alias: 'account-id'}],\n   *   template: `\n   *     Bank Name: {{bankName}}\n   *     Account Id: {{id}}\n   *   `\n   * })\n   * class BankAccount {\n   *   bankName: string;\n   *   id: string;\n   * }\n   * ```\n   *\n   */\n  inputs?: ({\n    name: string,\n    alias?: string,\n    required?: boolean,\n    transform?: (value: any) => any,\n  }|string)[];\n\n  /**\n   * Enumerates the set of event-bound output properties.\n   *\n   * When an output property emits an event, an event handler attached to that event\n   * in the template is invoked.\n   *\n   * The `outputs` property defines a set of `directiveProperty` to `alias`\n   * configuration:\n   *\n   * - `directiveProperty` specifies the component property that emits events.\n   * - `alias` specifies the DOM property the event handler is attached to.\n   *\n   * @usageNotes\n   *\n   * ```typescript\n   * @Component({\n   *   selector: 'child-dir',\n   *   outputs: [ 'bankNameChange' ],\n   *   template: `<input (input)=\"bankNameChange.emit($event.target.value)\" />`\n   * })\n   * class ChildDir {\n   *  bankNameChange: EventEmitter<string> = new EventEmitter<string>();\n   * }\n   *\n   * @Component({\n   *   selector: 'main',\n   *   template: `\n   *     {{ bankName }} <child-dir (bankNameChange)=\"onBankNameChange($event)\"></child-dir>\n   *   `\n   * })\n   * class MainComponent {\n   *  bankName: string;\n   *\n   *   onBankNameChange(bankName: string) {\n   *     this.bankName = bankName;\n   *   }\n   * }\n   * ```\n   *\n   */\n  outputs?: string[];\n\n  /**\n   * Configures the [injector](guide/glossary#injector) of this\n   * directive or component with a [token](guide/glossary#di-token)\n   * that maps to a [provider](guide/glossary#provider) of a dependency.\n   */\n  providers?: Provider[];\n\n  /**\n   * Defines the name that can be used in the template to assign this directive to a variable.\n   *\n   * @usageNotes\n   *\n   * ```ts\n   * @Directive({\n   *   selector: 'child-dir',\n   *   exportAs: 'child'\n   * })\n   * class ChildDir {\n   * }\n   *\n   * @Component({\n   *   selector: 'main',\n   *   template: `<child-dir #c=\"child\"></child-dir>`\n   * })\n   * class MainComponent {\n   * }\n   * ```\n   *\n   */\n  exportAs?: string;\n\n  /**\n   * Configures the queries that will be injected into the directive.\n   *\n   * Content queries are set before the `ngAfterContentInit` callback is called.\n   * View queries are set before the `ngAfterViewInit` callback is called.\n   *\n   * @usageNotes\n   *\n   * The following example shows how queries are defined\n   * and when their results are available in lifecycle hooks:\n   *\n   * ```ts\n   * @Component({\n   *   selector: 'someDir',\n   *   queries: {\n   *     contentChildren: new ContentChildren(ChildDirective),\n   *     viewChildren: new ViewChildren(ChildDirective)\n   *   },\n   *   template: '<child-directive></child-directive>'\n   * })\n   * class SomeDir {\n   *   contentChildren: QueryList<ChildDirective>,\n   *   viewChildren: QueryList<ChildDirective>\n   *\n   *   ngAfterContentInit() {\n   *     // contentChildren is set\n   *   }\n   *\n   *   ngAfterViewInit() {\n   *     // viewChildren is set\n   *   }\n   * }\n   * ```\n   *\n   * @Annotation\n   */\n  queries?: {[key: string]: any};\n\n  /**\n   * Maps class properties to host element bindings for properties,\n   * attributes, and events, using a set of key-value pairs.\n   *\n   * Angular automatically checks host property bindings during change detection.\n   * If a binding changes, Angular updates the directive's host element.\n   *\n   * When the key is a property of the host element, the property value is\n   * propagated to the specified DOM property.\n   *\n   * When the key is a static attribute in the DOM, the attribute value\n   * is propagated to the specified property in the host element.\n   *\n   * For event handling:\n   * - The key is the DOM event that the directive listens to.\n   * To listen to global events, add the target to the event name.\n   * The target can be `window`, `document` or `body`.\n   * - The value is the statement to execute when the event occurs. If the\n   * statement evaluates to `false`, then `preventDefault` is applied on the DOM\n   * event. A handler method can refer to the `$event` local variable.\n   *\n   */\n  host?: {[key: string]: string};\n\n  /**\n   * When present, this directive/component is ignored by the AOT compiler.\n   * It remains in distributed code, and the JIT compiler attempts to compile it\n   * at run time, in the browser.\n   * To ensure the correct behavior, the app must import `@angular/compiler`.\n   */\n  jit?: true;\n\n  /**\n   * Angular directives marked as `standalone` do not need to be declared in an NgModule. Such\n   * directives don't depend on any \"intermediate context\" of an NgModule (ex. configured\n   * providers).\n   *\n   * More information about standalone components, directives, and pipes can be found in [this\n   * guide](guide/standalone-components).\n   */\n  standalone?: boolean;\n\n  /**\n   * // TODO(signals): Remove internal and add public documentation\n   *\n   * @internal\n   */\n  signals?: boolean;\n\n  /**\n   * Standalone directives that should be applied to the host whenever the directive is matched.\n   * By default, none of the inputs or outputs of the host directives will be available on the host,\n   * unless they are specified in the `inputs` or `outputs` properties.\n   *\n   * You can additionally alias inputs and outputs by putting a colon and the alias after the\n   * original input or output name. For example, if a directive applied via `hostDirectives`\n   * defines an input named `menuDisabled`, you can alias this to `disabled` by adding\n   * `'menuDisabled: disabled'` as an entry to `inputs`.\n   */\n  hostDirectives?: (Type<unknown>|{\n    directive: Type<unknown>,\n    inputs?: string[],\n    outputs?: string[],\n  })[];\n}\n\n/**\n * Type of the Directive metadata.\n *\n * @publicApi\n */\nexport const Directive: DirectiveDecorator = makeDecorator(\n    'Directive', (dir: Directive = {}) => dir, undefined, undefined,\n    (type: Type<any>, meta: Directive) => compileDirective(type, meta));\n\n/**\n * Component decorator interface\n *\n * @publicApi\n */\nexport interface ComponentDecorator {\n  /**\n   * Decorator that marks a class as an Angular component and provides configuration\n   * metadata that determines how the component should be processed,\n   * instantiated, and used at runtime.\n   *\n   * Components are the most basic UI building block of an Angular app.\n   * An Angular app contains a tree of Angular components.\n   *\n   * Angular components are a subset of directives, always associated with a template.\n   * Unlike other directives, only one component can be instantiated for a given element in a\n   * template.\n   *\n   * A component must belong to an NgModule in order for it to be available\n   * to another component or application. To make it a member of an NgModule,\n   * list it in the `declarations` field of the `NgModule` metadata.\n   *\n   * Note that, in addition to these options for configuring a directive,\n   * you can control a component's runtime behavior by implementing\n   * life-cycle hooks. For more information, see the\n   * [Lifecycle Hooks](guide/lifecycle-hooks) guide.\n   *\n   * @usageNotes\n   *\n   * ### Setting component inputs\n   *\n   * The following example creates a component with two data-bound properties,\n   * specified by the `inputs` value.\n   *\n   * <code-example path=\"core/ts/metadata/directives.ts\" region=\"component-input\"></code-example>\n   *\n   *\n   * ### Setting component outputs\n   *\n   * The following example shows two event emitters that emit on an interval. One\n   * emits an output every second, while the other emits every five seconds.\n   *\n   * {@example core/ts/metadata/directives.ts region='component-output-interval'}\n   *\n   * ### Injecting a class with a view provider\n   *\n   * The following simple example injects a class into a component\n   * using the view provider specified in component metadata:\n   *\n   * ```ts\n   * class Greeter {\n   *    greet(name:string) {\n   *      return 'Hello ' + name + '!';\n   *    }\n   * }\n   *\n   * @Directive({\n   *   selector: 'needs-greeter'\n   * })\n   * class NeedsGreeter {\n   *   greeter:Greeter;\n   *\n   *   constructor(greeter:Greeter) {\n   *     this.greeter = greeter;\n   *   }\n   * }\n   *\n   * @Component({\n   *   selector: 'greet',\n   *   viewProviders: [\n   *     Greeter\n   *   ],\n   *   template: `<needs-greeter></needs-greeter>`\n   * })\n   * class HelloWorld {\n   * }\n   *\n   * ```\n   *\n   * ### Preserving whitespace\n   *\n   * Removing whitespace can greatly reduce AOT-generated code size and speed up view creation.\n   * As of Angular 6, the default for `preserveWhitespaces` is false (whitespace is removed).\n   * To change the default setting for all components in your application, set\n   * the `preserveWhitespaces` option of the AOT compiler.\n   *\n   * By default, the AOT compiler removes whitespace characters as follows:\n   * * Trims all whitespaces at the beginning and the end of a template.\n   * * Removes whitespace-only text nodes. For example,\n   *\n   * ```html\n   * <button>Action 1</button>  <button>Action 2</button>\n   * ```\n   *\n   * becomes:\n   *\n   * ```html\n   * <button>Action 1</button><button>Action 2</button>\n   * ```\n   *\n   * * Replaces a series of whitespace characters in text nodes with a single space.\n   * For example, `<span>\\n some text\\n</span>` becomes `<span> some text </span>`.\n   * * Does NOT alter text nodes inside HTML tags such as `<pre>` or `<textarea>`,\n   * where whitespace characters are significant.\n   *\n   * Note that these transformations can influence DOM nodes layout, although impact\n   * should be minimal.\n   *\n   * You can override the default behavior to preserve whitespace characters\n   * in certain fragments of a template. For example, you can exclude an entire\n   * DOM sub-tree by using the `ngPreserveWhitespaces` attribute:\n   *\n   * ```html\n   * <div ngPreserveWhitespaces>\n   *     whitespaces are preserved here\n   *     <span>    and here </span>\n   * </div>\n   * ```\n   *\n   * You can force a single space to be preserved in a text node by using `&ngsp;`,\n   * which is replaced with a space character by Angular's template\n   * compiler:\n   *\n   * ```html\n   * <a>Spaces</a>&ngsp;<a>between</a>&ngsp;<a>links.</a>\n   * <!-- compiled to be equivalent to:\n   *  <a>Spaces</a> <a>between</a> <a>links.</a>  -->\n   * ```\n   *\n   * Note that sequences of `&ngsp;` are still collapsed to just one space character when\n   * the `preserveWhitespaces` option is set to `false`.\n   *\n   * ```html\n   * <a>before</a>&ngsp;&ngsp;&ngsp;<a>after</a>\n   * <!-- compiled to be equivalent to:\n   *  <a>before</a> <a>after</a> -->\n   * ```\n   *\n   * To preserve sequences of whitespace characters, use the\n   * `ngPreserveWhitespaces` attribute.\n   *\n   * @Annotation\n   */\n  (obj: Component): TypeDecorator;\n  /**\n   * See the `Component` decorator.\n   */\n  new(obj: Component): Component;\n}\n\n/**\n * Supplies configuration metadata for an Angular component.\n *\n * @publicApi\n */\nexport interface Component extends Directive {\n  /**\n   * The change-detection strategy to use for this component.\n   *\n   * When a component is instantiated, Angular creates a change detector,\n   * which is responsible for propagating the component's bindings.\n   * The strategy is one of:\n   * - `ChangeDetectionStrategy#OnPush` sets the strategy to `CheckOnce` (on demand).\n   * - `ChangeDetectionStrategy#Default` sets the strategy to `CheckAlways`.\n   */\n  changeDetection?: ChangeDetectionStrategy;\n\n  /**\n   * Defines the set of injectable objects that are visible to its view DOM children.\n   * See [example](#injecting-a-class-with-a-view-provider).\n   *\n   */\n  viewProviders?: Provider[];\n\n  /**\n   * The module ID of the module that contains the component.\n   * The component must be able to resolve relative URLs for templates and styles.\n   * SystemJS exposes the `__moduleName` variable within each module.\n   * In CommonJS, this can  be set to `module.id`.\n   *\n   * @deprecated This option does not have any effect. Will be removed in Angular v17.\n   */\n  moduleId?: string;\n\n  /**\n   * The relative path or absolute URL of a template file for an Angular component.\n   * If provided, do not supply an inline template using `template`.\n   *\n   */\n  templateUrl?: string;\n\n  /**\n   * An inline template for an Angular component. If provided,\n   * do not supply a template file using `templateUrl`.\n   *\n   */\n  template?: string;\n\n  /**\n   * One relative paths or an absolute URL for files containing CSS stylesheet to use\n   * in this component.\n   */\n  styleUrl?: string;\n\n  /**\n   * Relative paths or absolute URLs for files containing CSS stylesheets to use in this component.\n   */\n  styleUrls?: string[];\n\n  /**\n   * One or more inline CSS stylesheets to use\n   * in this component.\n   */\n  styles?: string|string[];\n\n  /**\n   * One or more animation `trigger()` calls, containing\n   * [`state()`](api/animations/state) and `transition()` definitions.\n   * See the [Animations guide](/guide/animations) and animations API documentation.\n   *\n   */\n  animations?: any[];\n\n  /**\n   * An encapsulation policy for the component's styling.\n   * Possible values:\n   * - `ViewEncapsulation.Emulated`: Apply modified component styles in order to emulate\n   *                                 a native Shadow DOM CSS encapsulation behavior.\n   * - `ViewEncapsulation.None`: Apply component styles globally without any sort of encapsulation.\n   * - `ViewEncapsulation.ShadowDom`: Use the browser's native Shadow DOM API to encapsulate styles.\n   *\n   * If not supplied, the value is taken from the `CompilerOptions`\n   * which defaults to `ViewEncapsulation.Emulated`.\n   *\n   * If the policy is `ViewEncapsulation.Emulated` and the component has no\n   * {@link Component#styles styles} nor {@link Component#styleUrls styleUrls},\n   * the policy is automatically switched to `ViewEncapsulation.None`.\n   */\n  encapsulation?: ViewEncapsulation;\n\n  /**\n   * Overrides the default interpolation start and end delimiters (`{{` and `}}`).\n   */\n  interpolation?: [string, string];\n\n  /**\n   * True to preserve or false to remove potentially superfluous whitespace characters\n   * from the compiled template. Whitespace characters are those matching the `\\s`\n   * character class in JavaScript regular expressions. Default is false, unless\n   * overridden in compiler options.\n   */\n  preserveWhitespaces?: boolean;\n\n  /**\n   * Angular components marked as `standalone` do not need to be declared in an NgModule. Such\n   * components directly manage their own template dependencies (components, directives, and pipes\n   * used in a template) via the imports property.\n   *\n   * More information about standalone components, directives, and pipes can be found in [this\n   * guide](guide/standalone-components).\n   */\n  standalone?: boolean;\n\n  /**\n   * The imports property specifies the standalone component's template dependencies  those\n   * directives, components, and pipes that can be used within its template. Standalone components\n   * can import other standalone components, directives, and pipes as well as existing NgModules.\n   *\n   * This property is only available for standalone components - specifying it for components\n   * declared in an NgModule generates a compilation error.\n   *\n   * More information about standalone components, directives, and pipes can be found in [this\n   * guide](guide/standalone-components).\n   */\n  imports?: (Type<any>|ReadonlyArray<any>)[];\n\n  /**\n   * The set of schemas that declare elements to be allowed in a standalone component. Elements and\n   * properties that are neither Angular components nor directives must be declared in a schema.\n   *\n   * This property is only available for standalone components - specifying it for components\n   * declared in an NgModule generates a compilation error.\n   *\n   * More information about standalone components, directives, and pipes can be found in [this\n   * guide](guide/standalone-components).\n   */\n  schemas?: SchemaMetadata[];\n}\n\n/**\n * Component decorator and metadata.\n *\n * @Annotation\n * @publicApi\n */\nexport const Component: ComponentDecorator = makeDecorator(\n    'Component', (c: Component = {}) => ({changeDetection: ChangeDetectionStrategy.Default, ...c}),\n    Directive, undefined, (type: Type<any>, meta: Component) => compileComponent(type, meta));\n\n/**\n * Type of the Pipe decorator / constructor function.\n *\n * @publicApi\n */\nexport interface PipeDecorator {\n  /**\n   *\n   * Decorator that marks a class as pipe and supplies configuration metadata.\n   *\n   * A pipe class must implement the `PipeTransform` interface.\n   * For example, if the name is \"myPipe\", use a template binding expression\n   * such as the following:\n   *\n   * ```\n   * {{ exp | myPipe }}\n   * ```\n   *\n   * The result of the expression is passed to the pipe's `transform()` method.\n   *\n   * A pipe must belong to an NgModule in order for it to be available\n   * to a template. To make it a member of an NgModule,\n   * list it in the `declarations` field of the `NgModule` metadata.\n   *\n   * @see [Style Guide: Pipe Names](guide/styleguide#02-09)\n   *\n   */\n  (obj: Pipe): TypeDecorator;\n\n  /**\n   * See the `Pipe` decorator.\n   */\n  new(obj: Pipe): Pipe;\n}\n\n/**\n * Type of the Pipe metadata.\n *\n * @publicApi\n */\nexport interface Pipe {\n  /**\n   * The pipe name to use in template bindings.\n   * Typically uses [lowerCamelCase](guide/glossary#case-types)\n   * because the name cannot contain hyphens.\n   */\n  name: string;\n\n  /**\n   * When true, the pipe is pure, meaning that the\n   * `transform()` method is invoked only when its input arguments\n   * change. Pipes are pure by default.\n   *\n   * If the pipe has internal state (that is, the result\n   * depends on state other than its arguments), set `pure` to false.\n   * In this case, the pipe is invoked on each change-detection cycle,\n   * even if the arguments have not changed.\n   */\n  pure?: boolean;\n\n  /**\n   * Angular pipes marked as `standalone` do not need to be declared in an NgModule. Such\n   * pipes don't depend on any \"intermediate context\" of an NgModule (ex. configured providers).\n   *\n   * More information about standalone components, directives, and pipes can be found in [this\n   * guide](guide/standalone-components).\n   */\n  standalone?: boolean;\n}\n\n/**\n * @Annotation\n * @publicApi\n */\nexport const Pipe: PipeDecorator = makeDecorator(\n    'Pipe', (p: Pipe) => ({pure: true, ...p}), undefined, undefined,\n    (type: Type<any>, meta: Pipe) => compilePipe(type, meta));\n\n\n/**\n * @publicApi\n */\nexport interface InputDecorator {\n  /**\n   * Decorator that marks a class field as an input property and supplies configuration metadata.\n   * The input property is bound to a DOM property in the template. During change detection,\n   * Angular automatically updates the data property with the DOM property's value.\n   *\n   * @usageNotes\n   *\n   * You can supply an optional name to use in templates when the\n   * component is instantiated, that maps to the\n   * name of the bound property. By default, the original\n   * name of the bound property is used for input binding.\n   *\n   * The following example creates a component with two input properties,\n   * one of which is given a special binding name.\n   *\n   * ```typescript\n   * import { Component, Input, numberAttribute, booleanAttribute } from '@angular/core';\n   * @Component({\n   *   selector: 'bank-account',\n   *   template: `\n   *     Bank Name: {{bankName}}\n   *     Account Id: {{id}}\n   *     Account Status: {{status ? 'Active' : 'InActive'}}\n   *   `\n   * })\n   * class BankAccount {\n   *   // This property is bound using its original name.\n   *   // Defining argument required as true inside the Input Decorator\n   *   // makes this property deceleration as mandatory\n   *   @Input({ required: true }) bankName!: string;\n   *   // Argument alias makes this property value is bound to a different property name\n   *   // when this component is instantiated in a template.\n   *   // Argument transform convert the input value from string to number\n   *   @Input({ alias:'account-id', transform: numberAttribute }) id: number;\n   *   // Argument transform the input value from string to boolean\n   *   @Input({ transform: booleanAttribute }) status: boolean;\n   *   // this property is not bound, and is not automatically updated by Angular\n   *   normalizedBankName: string;\n   * }\n   *\n   * @Component({\n   *   selector: 'app',\n   *   template: `\n   *     <bank-account bankName=\"RBC\" account-id=\"4747\" status=\"true\"></bank-account>\n   *   `\n   * })\n   * class App {}\n   * ```\n   *\n   * @see [Input and Output properties](guide/inputs-outputs)\n   */\n  (arg?: string|Input): any;\n  new(arg?: string|Input): any;\n}\n\n/**\n * Type of metadata for an `Input` property.\n *\n * @publicApi\n */\nexport interface Input {\n  /**\n   * The name of the DOM property to which the input property is bound.\n   */\n  alias?: string;\n\n  /**\n   * Whether the input is required for the directive to function.\n   */\n  required?: boolean;\n\n  /**\n   * Function with which to transform the input value before assigning it to the directive instance.\n   */\n  transform?: (value: any) => any;\n}\n\n/**\n * @Annotation\n * @publicApi\n */\nexport const Input: InputDecorator =\n    makePropDecorator('Input', (arg?: string|{alias?: string, required?: boolean}) => {\n      if (!arg) {\n        return {};\n      }\n      return typeof arg === 'string' ? {alias: arg} : arg;\n    });\n\n/**\n * Type of the Output decorator / constructor function.\n *\n * @publicApi\n */\nexport interface OutputDecorator {\n  /**\n   * Decorator that marks a class field as an output property and supplies configuration metadata.\n   * The DOM property bound to the output property is automatically updated during change detection.\n   *\n   * @usageNotes\n   *\n   * You can supply an optional name to use in templates when the\n   * component is instantiated, that maps to the\n   * name of the bound property. By default, the original\n   * name of the bound property is used for output binding.\n   *\n   * See `Input` decorator for an example of providing a binding name.\n   *\n   * @see [Input and Output properties](guide/inputs-outputs)\n   *\n   */\n  (alias?: string): any;\n  new(alias?: string): any;\n}\n\n/**\n * Type of the Output metadata.\n *\n * @publicApi\n */\nexport interface Output {\n  /**\n   * The name of the DOM property to which the output property is bound.\n   */\n  alias?: string;\n}\n\n/**\n * @Annotation\n * @publicApi\n */\nexport const Output: OutputDecorator = makePropDecorator('Output', (alias?: string) => ({alias}));\n\n\n\n/**\n * Type of the HostBinding decorator / constructor function.\n *\n * @publicApi\n */\nexport interface HostBindingDecorator {\n  /**\n   * Decorator that marks a DOM property or an element class, style or attribute as a host-binding\n   * property and supplies configuration metadata. Angular automatically checks host bindings during\n   * change detection, and if a binding changes it updates the host element of the directive.\n   *\n   * @usageNotes\n   *\n   * The following example creates a directive that sets the `valid` and `invalid`\n   * class, a style color, and an id on the DOM element that has an `ngModel` directive on it.\n   *\n   * ```typescript\n   * @Directive({selector: '[ngModel]'})\n   * class NgModelStatus {\n   *   constructor(public control: NgModel) {}\n   *   // class bindings\n   *   @HostBinding('class.valid') get valid() { return this.control.valid; }\n   *   @HostBinding('class.invalid') get invalid() { return this.control.invalid; }\n   *\n   *   // style binding\n   *   @HostBinding('style.color') get color() { return this.control.valid ? 'green': 'red'; }\n   *\n   *   // style binding also supports a style unit extension\n   *   @HostBinding('style.width.px') @Input() width: number = 500;\n   *\n   *   // attribute binding\n   *   @HostBinding('attr.aria-required')\n   *   @Input() required: boolean = false;\n   *\n   *   // property binding\n   *   @HostBinding('id') get id() { return this.control.value?.length ? 'odd':  'even'; }\n   *\n   * @Component({\n   *   selector: 'app',\n   *   template: `<input [(ngModel)]=\"prop\">`,\n   * })\n   * class App {\n   *   prop;\n   * }\n   * ```\n   *\n   */\n  (hostPropertyName?: string): any;\n  new(hostPropertyName?: string): any;\n}\n\n/**\n * Type of the HostBinding metadata.\n *\n * @publicApi\n */\nexport interface HostBinding {\n  /**\n   * The DOM property that is bound to a data property.\n   * This field also accepts:\n   *   * classes, prefixed by `class.`\n   *   * styles, prefixed by `style.`\n   *   * attributes, prefixed by `attr.`\n   */\n  hostPropertyName?: string;\n}\n\n/**\n * @Annotation\n * @publicApi\n */\nexport const HostBinding: HostBindingDecorator =\n    makePropDecorator('HostBinding', (hostPropertyName?: string) => ({hostPropertyName}));\n\n\n/**\n * Type of the HostListener decorator / constructor function.\n *\n * @publicApi\n */\nexport interface HostListenerDecorator {\n  /**\n   * Decorator that declares a DOM event to listen for,\n   * and provides a handler method to run when that event occurs.\n   *\n   * Angular invokes the supplied handler method when the host element emits the specified event,\n   * and updates the bound element with the result.\n   *\n   * If the handler method returns false, applies `preventDefault` on the bound element.\n   */\n  (eventName: string, args?: string[]): any;\n  new(eventName: string, args?: string[]): any;\n}\n\n/**\n * Type of the HostListener metadata.\n *\n * @publicApi\n */\nexport interface HostListener {\n  /**\n   * The DOM event to listen for.\n   */\n  eventName?: string;\n  /**\n   * A set of arguments to pass to the handler method when the event occurs.\n   */\n  args?: string[];\n}\n\n/**\n * Decorator that binds a DOM event to a host listener and supplies configuration metadata.\n * Angular invokes the supplied handler method when the host element emits the specified event,\n * and updates the bound element with the result.\n *\n * If the handler method returns false, applies `preventDefault` on the bound element.\n *\n * @usageNotes\n *\n * The following example declares a directive\n * that attaches a click listener to a button and counts clicks.\n *\n * ```ts\n * @Directive({selector: 'button[counting]'})\n * class CountClicks {\n *   numberOfClicks = 0;\n *\n *   @HostListener('click', ['$event.target'])\n *   onClick(btn) {\n *     console.log('button', btn, 'number of clicks:', this.numberOfClicks++);\n *   }\n * }\n *\n * @Component({\n *   selector: 'app',\n *   template: '<button counting>Increment</button>',\n * })\n * class App {}\n *\n * ```\n *\n * The following example registers another DOM event handler that listens for `Enter` key-press\n * events on the global `window`.\n * ``` ts\n * import { HostListener, Component } from \"@angular/core\";\n *\n * @Component({\n *   selector: 'app',\n *   template: `<h1>Hello, you have pressed enter {{counter}} number of times!</h1> Press enter key\n * to increment the counter.\n *   <button (click)=\"resetCounter()\">Reset Counter</button>`\n * })\n * class AppComponent {\n *   counter = 0;\n *   @HostListener('window:keydown.enter', ['$event'])\n *   handleKeyDown(event: KeyboardEvent) {\n *     this.counter++;\n *   }\n *   resetCounter() {\n *     this.counter = 0;\n *   }\n * }\n * ```\n * The list of valid key names for `keydown` and `keyup` events\n * can be found here:\n * https://www.w3.org/TR/DOM-Level-3-Events-key/#named-key-attribute-values\n *\n * Note that keys can also be combined, e.g. `@HostListener('keydown.shift.a')`.\n *\n * The global target names that can be used to prefix an event name are\n * `document:`, `window:` and `body:`.\n *\n * @Annotation\n * @publicApi\n */\nexport const HostListener: HostListenerDecorator =\n    makePropDecorator('HostListener', (eventName?: string, args?: string[]) => ({eventName, args}));\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {keyValueArraySet} from '../../util/array_utils';\nimport {getLView} from '../state';\nimport {interpolation1, interpolation2, interpolation3, interpolation4, interpolation5, interpolation6, interpolation7, interpolation8, interpolationV} from './interpolation';\nimport {checkStylingMap, classStringParser} from './styling';\n\n\n\n/**\n *\n * Update an interpolated class on an element with single bound value surrounded by text.\n *\n * Used when the value passed to a property has 1 interpolated value in it:\n *\n * ```html\n * <div class=\"prefix{{v0}}suffix\"></div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * classMapInterpolate1('prefix', v0, 'suffix');\n * ```\n *\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @codeGenApi\n */\nexport function classMapInterpolate1(prefix: string, v0: any, suffix: string): void {\n  const lView = getLView();\n  const interpolatedValue = interpolation1(lView, prefix, v0, suffix);\n  checkStylingMap(keyValueArraySet, classStringParser, interpolatedValue, true);\n}\n\n/**\n *\n * Update an interpolated class on an element with 2 bound values surrounded by text.\n *\n * Used when the value passed to a property has 2 interpolated values in it:\n *\n * ```html\n * <div class=\"prefix{{v0}}-{{v1}}suffix\"></div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * classMapInterpolate2('prefix', v0, '-', v1, 'suffix');\n * ```\n *\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @codeGenApi\n */\nexport function classMapInterpolate2(\n    prefix: string, v0: any, i0: string, v1: any, suffix: string): void {\n  const lView = getLView();\n  const interpolatedValue = interpolation2(lView, prefix, v0, i0, v1, suffix);\n  checkStylingMap(keyValueArraySet, classStringParser, interpolatedValue, true);\n}\n\n/**\n *\n * Update an interpolated class on an element with 3 bound values surrounded by text.\n *\n * Used when the value passed to a property has 3 interpolated values in it:\n *\n * ```html\n * <div class=\"prefix{{v0}}-{{v1}}-{{v2}}suffix\"></div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * classMapInterpolate3(\n * 'prefix', v0, '-', v1, '-', v2, 'suffix');\n * ```\n *\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param i1 Static value used for concatenation only.\n * @param v2 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @codeGenApi\n */\nexport function classMapInterpolate3(\n    prefix: string, v0: any, i0: string, v1: any, i1: string, v2: any, suffix: string): void {\n  const lView = getLView();\n  const interpolatedValue = interpolation3(lView, prefix, v0, i0, v1, i1, v2, suffix);\n  checkStylingMap(keyValueArraySet, classStringParser, interpolatedValue, true);\n}\n\n/**\n *\n * Update an interpolated class on an element with 4 bound values surrounded by text.\n *\n * Used when the value passed to a property has 4 interpolated values in it:\n *\n * ```html\n * <div class=\"prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}suffix\"></div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * classMapInterpolate4(\n * 'prefix', v0, '-', v1, '-', v2, '-', v3, 'suffix');\n * ```\n *\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param i1 Static value used for concatenation only.\n * @param v2 Value checked for change.\n * @param i2 Static value used for concatenation only.\n * @param v3 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @codeGenApi\n */\nexport function classMapInterpolate4(\n    prefix: string, v0: any, i0: string, v1: any, i1: string, v2: any, i2: string, v3: any,\n    suffix: string): void {\n  const lView = getLView();\n  const interpolatedValue = interpolation4(lView, prefix, v0, i0, v1, i1, v2, i2, v3, suffix);\n  checkStylingMap(keyValueArraySet, classStringParser, interpolatedValue, true);\n}\n\n/**\n *\n * Update an interpolated class on an element with 5 bound values surrounded by text.\n *\n * Used when the value passed to a property has 5 interpolated values in it:\n *\n * ```html\n * <div class=\"prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}-{{v4}}suffix\"></div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * classMapInterpolate5(\n * 'prefix', v0, '-', v1, '-', v2, '-', v3, '-', v4, 'suffix');\n * ```\n *\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param i1 Static value used for concatenation only.\n * @param v2 Value checked for change.\n * @param i2 Static value used for concatenation only.\n * @param v3 Value checked for change.\n * @param i3 Static value used for concatenation only.\n * @param v4 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @codeGenApi\n */\nexport function classMapInterpolate5(\n    prefix: string, v0: any, i0: string, v1: any, i1: string, v2: any, i2: string, v3: any,\n    i3: string, v4: any, suffix: string): void {\n  const lView = getLView();\n  const interpolatedValue =\n      interpolation5(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, suffix);\n  checkStylingMap(keyValueArraySet, classStringParser, interpolatedValue, true);\n}\n\n/**\n *\n * Update an interpolated class on an element with 6 bound values surrounded by text.\n *\n * Used when the value passed to a property has 6 interpolated values in it:\n *\n * ```html\n * <div class=\"prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}-{{v4}}-{{v5}}suffix\"></div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * classMapInterpolate6(\n *    'prefix', v0, '-', v1, '-', v2, '-', v3, '-', v4, '-', v5, 'suffix');\n * ```\n *\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param i1 Static value used for concatenation only.\n * @param v2 Value checked for change.\n * @param i2 Static value used for concatenation only.\n * @param v3 Value checked for change.\n * @param i3 Static value used for concatenation only.\n * @param v4 Value checked for change.\n * @param i4 Static value used for concatenation only.\n * @param v5 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @codeGenApi\n */\nexport function classMapInterpolate6(\n    prefix: string, v0: any, i0: string, v1: any, i1: string, v2: any, i2: string, v3: any,\n    i3: string, v4: any, i4: string, v5: any, suffix: string): void {\n  const lView = getLView();\n  const interpolatedValue =\n      interpolation6(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, suffix);\n  checkStylingMap(keyValueArraySet, classStringParser, interpolatedValue, true);\n}\n\n/**\n *\n * Update an interpolated class on an element with 7 bound values surrounded by text.\n *\n * Used when the value passed to a property has 7 interpolated values in it:\n *\n * ```html\n * <div class=\"prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}-{{v4}}-{{v5}}-{{v6}}suffix\"></div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * classMapInterpolate7(\n *    'prefix', v0, '-', v1, '-', v2, '-', v3, '-', v4, '-', v5, '-', v6, 'suffix');\n * ```\n *\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param i1 Static value used for concatenation only.\n * @param v2 Value checked for change.\n * @param i2 Static value used for concatenation only.\n * @param v3 Value checked for change.\n * @param i3 Static value used for concatenation only.\n * @param v4 Value checked for change.\n * @param i4 Static value used for concatenation only.\n * @param v5 Value checked for change.\n * @param i5 Static value used for concatenation only.\n * @param v6 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @codeGenApi\n */\nexport function classMapInterpolate7(\n    prefix: string, v0: any, i0: string, v1: any, i1: string, v2: any, i2: string, v3: any,\n    i3: string, v4: any, i4: string, v5: any, i5: string, v6: any, suffix: string): void {\n  const lView = getLView();\n  const interpolatedValue =\n      interpolation7(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, suffix);\n  checkStylingMap(keyValueArraySet, classStringParser, interpolatedValue, true);\n}\n\n/**\n *\n * Update an interpolated class on an element with 8 bound values surrounded by text.\n *\n * Used when the value passed to a property has 8 interpolated values in it:\n *\n * ```html\n * <div class=\"prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}-{{v4}}-{{v5}}-{{v6}}-{{v7}}suffix\"></div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * classMapInterpolate8(\n *  'prefix', v0, '-', v1, '-', v2, '-', v3, '-', v4, '-', v5, '-', v6, '-', v7, 'suffix');\n * ```\n *\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param i1 Static value used for concatenation only.\n * @param v2 Value checked for change.\n * @param i2 Static value used for concatenation only.\n * @param v3 Value checked for change.\n * @param i3 Static value used for concatenation only.\n * @param v4 Value checked for change.\n * @param i4 Static value used for concatenation only.\n * @param v5 Value checked for change.\n * @param i5 Static value used for concatenation only.\n * @param v6 Value checked for change.\n * @param i6 Static value used for concatenation only.\n * @param v7 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @codeGenApi\n */\nexport function classMapInterpolate8(\n    prefix: string, v0: any, i0: string, v1: any, i1: string, v2: any, i2: string, v3: any,\n    i3: string, v4: any, i4: string, v5: any, i5: string, v6: any, i6: string, v7: any,\n    suffix: string): void {\n  const lView = getLView();\n  const interpolatedValue = interpolation8(\n      lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, i6, v7, suffix);\n  checkStylingMap(keyValueArraySet, classStringParser, interpolatedValue, true);\n}\n\n/**\n * Update an interpolated class on an element with 9 or more bound values surrounded by text.\n *\n * Used when the number of interpolated values exceeds 8.\n *\n * ```html\n * <div\n *  class=\"prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}-{{v4}}-{{v5}}-{{v6}}-{{v7}}-{{v8}}-{{v9}}suffix\"></div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * classMapInterpolateV(\n *  ['prefix', v0, '-', v1, '-', v2, '-', v3, '-', v4, '-', v5, '-', v6, '-', v7, '-', v9,\n *  'suffix']);\n * ```\n *.\n * @param values The collection of values and the strings in-between those values, beginning with\n * a string prefix and ending with a string suffix.\n * (e.g. `['prefix', value0, '-', value1, '-', value2, ..., value99, 'suffix']`)\n * @codeGenApi\n */\nexport function classMapInterpolateV(values: any[]): void {\n  const lView = getLView();\n  const interpolatedValue = interpolationV(lView, values);\n  checkStylingMap(keyValueArraySet, classStringParser, interpolatedValue, true);\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport {SanitizerFn} from '../interfaces/sanitization';\nimport {RENDERER} from '../interfaces/view';\nimport {getBindingIndex, getLView, getSelectedTNode, getTView} from '../state';\nimport {NO_CHANGE} from '../tokens';\n\nimport {interpolation1, interpolation2, interpolation3, interpolation4, interpolation5, interpolation6, interpolation7, interpolation8, interpolationV} from './interpolation';\nimport {elementPropertyInternal, storePropertyBindingMetadata} from './shared';\n\n\n/**\n *\n * Update an interpolated property on an element with a lone bound value\n *\n * Used when the value passed to a property has 1 interpolated value in it, an no additional text\n * surrounds that interpolated value:\n *\n * ```html\n * <div title=\"{{v0}}\"></div>\n * ```\n *\n * Its compiled representation is::\n *\n * ```ts\n * propertyInterpolate('title', v0);\n * ```\n *\n * If the property name also exists as an input property on one of the element's directives,\n * the component property will be set instead of the element property. This check must\n * be conducted at runtime so child components that add new `@Inputs` don't have to be re-compiled.\n *\n * @param propName The name of the property to update\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @param sanitizer An optional sanitizer function\n * @returns itself, so that it may be chained.\n * @codeGenApi\n */\nexport function propertyInterpolate(\n    propName: string, v0: any, sanitizer?: SanitizerFn): typeof propertyInterpolate {\n  propertyInterpolate1(propName, '', v0, '', sanitizer);\n  return propertyInterpolate;\n}\n\n\n/**\n *\n * Update an interpolated property on an element with single bound value surrounded by text.\n *\n * Used when the value passed to a property has 1 interpolated value in it:\n *\n * ```html\n * <div title=\"prefix{{v0}}suffix\"></div>\n * ```\n *\n * Its compiled representation is::\n *\n * ```ts\n * propertyInterpolate1('title', 'prefix', v0, 'suffix');\n * ```\n *\n * If the property name also exists as an input property on one of the element's directives,\n * the component property will be set instead of the element property. This check must\n * be conducted at runtime so child components that add new `@Inputs` don't have to be re-compiled.\n *\n * @param propName The name of the property to update\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @param sanitizer An optional sanitizer function\n * @returns itself, so that it may be chained.\n * @codeGenApi\n */\nexport function propertyInterpolate1(\n    propName: string, prefix: string, v0: any, suffix: string,\n    sanitizer?: SanitizerFn): typeof propertyInterpolate1 {\n  const lView = getLView();\n  const interpolatedValue = interpolation1(lView, prefix, v0, suffix);\n  if (interpolatedValue !== NO_CHANGE) {\n    const tView = getTView();\n    const tNode = getSelectedTNode();\n    elementPropertyInternal(\n        tView, tNode, lView, propName, interpolatedValue, lView[RENDERER], sanitizer, false);\n    ngDevMode &&\n        storePropertyBindingMetadata(\n            tView.data, tNode, propName, getBindingIndex() - 1, prefix, suffix);\n  }\n  return propertyInterpolate1;\n}\n\n/**\n *\n * Update an interpolated property on an element with 2 bound values surrounded by text.\n *\n * Used when the value passed to a property has 2 interpolated values in it:\n *\n * ```html\n * <div title=\"prefix{{v0}}-{{v1}}suffix\"></div>\n * ```\n *\n * Its compiled representation is::\n *\n * ```ts\n * propertyInterpolate2('title', 'prefix', v0, '-', v1, 'suffix');\n * ```\n *\n * If the property name also exists as an input property on one of the element's directives,\n * the component property will be set instead of the element property. This check must\n * be conducted at runtime so child components that add new `@Inputs` don't have to be re-compiled.\n *\n * @param propName The name of the property to update\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @param sanitizer An optional sanitizer function\n * @returns itself, so that it may be chained.\n * @codeGenApi\n */\nexport function propertyInterpolate2(\n    propName: string, prefix: string, v0: any, i0: string, v1: any, suffix: string,\n    sanitizer?: SanitizerFn): typeof propertyInterpolate2 {\n  const lView = getLView();\n  const interpolatedValue = interpolation2(lView, prefix, v0, i0, v1, suffix);\n  if (interpolatedValue !== NO_CHANGE) {\n    const tView = getTView();\n    const tNode = getSelectedTNode();\n    elementPropertyInternal(\n        tView, tNode, lView, propName, interpolatedValue, lView[RENDERER], sanitizer, false);\n    ngDevMode &&\n        storePropertyBindingMetadata(\n            tView.data, tNode, propName, getBindingIndex() - 2, prefix, i0, suffix);\n  }\n  return propertyInterpolate2;\n}\n\n/**\n *\n * Update an interpolated property on an element with 3 bound values surrounded by text.\n *\n * Used when the value passed to a property has 3 interpolated values in it:\n *\n * ```html\n * <div title=\"prefix{{v0}}-{{v1}}-{{v2}}suffix\"></div>\n * ```\n *\n * Its compiled representation is::\n *\n * ```ts\n * propertyInterpolate3(\n * 'title', 'prefix', v0, '-', v1, '-', v2, 'suffix');\n * ```\n *\n * If the property name also exists as an input property on one of the element's directives,\n * the component property will be set instead of the element property. This check must\n * be conducted at runtime so child components that add new `@Inputs` don't have to be re-compiled.\n *\n * @param propName The name of the property to update\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param i1 Static value used for concatenation only.\n * @param v2 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @param sanitizer An optional sanitizer function\n * @returns itself, so that it may be chained.\n * @codeGenApi\n */\nexport function propertyInterpolate3(\n    propName: string, prefix: string, v0: any, i0: string, v1: any, i1: string, v2: any,\n    suffix: string, sanitizer?: SanitizerFn): typeof propertyInterpolate3 {\n  const lView = getLView();\n  const interpolatedValue = interpolation3(lView, prefix, v0, i0, v1, i1, v2, suffix);\n  if (interpolatedValue !== NO_CHANGE) {\n    const tView = getTView();\n    const tNode = getSelectedTNode();\n    elementPropertyInternal(\n        tView, tNode, lView, propName, interpolatedValue, lView[RENDERER], sanitizer, false);\n    ngDevMode &&\n        storePropertyBindingMetadata(\n            tView.data, tNode, propName, getBindingIndex() - 3, prefix, i0, i1, suffix);\n  }\n  return propertyInterpolate3;\n}\n\n/**\n *\n * Update an interpolated property on an element with 4 bound values surrounded by text.\n *\n * Used when the value passed to a property has 4 interpolated values in it:\n *\n * ```html\n * <div title=\"prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}suffix\"></div>\n * ```\n *\n * Its compiled representation is::\n *\n * ```ts\n * propertyInterpolate4(\n * 'title', 'prefix', v0, '-', v1, '-', v2, '-', v3, 'suffix');\n * ```\n *\n * If the property name also exists as an input property on one of the element's directives,\n * the component property will be set instead of the element property. This check must\n * be conducted at runtime so child components that add new `@Inputs` don't have to be re-compiled.\n *\n * @param propName The name of the property to update\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param i1 Static value used for concatenation only.\n * @param v2 Value checked for change.\n * @param i2 Static value used for concatenation only.\n * @param v3 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @param sanitizer An optional sanitizer function\n * @returns itself, so that it may be chained.\n * @codeGenApi\n */\nexport function propertyInterpolate4(\n    propName: string, prefix: string, v0: any, i0: string, v1: any, i1: string, v2: any, i2: string,\n    v3: any, suffix: string, sanitizer?: SanitizerFn): typeof propertyInterpolate4 {\n  const lView = getLView();\n  const interpolatedValue = interpolation4(lView, prefix, v0, i0, v1, i1, v2, i2, v3, suffix);\n  if (interpolatedValue !== NO_CHANGE) {\n    const tView = getTView();\n    const tNode = getSelectedTNode();\n    elementPropertyInternal(\n        tView, tNode, lView, propName, interpolatedValue, lView[RENDERER], sanitizer, false);\n    ngDevMode &&\n        storePropertyBindingMetadata(\n            tView.data, tNode, propName, getBindingIndex() - 4, prefix, i0, i1, i2, suffix);\n  }\n  return propertyInterpolate4;\n}\n\n/**\n *\n * Update an interpolated property on an element with 5 bound values surrounded by text.\n *\n * Used when the value passed to a property has 5 interpolated values in it:\n *\n * ```html\n * <div title=\"prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}-{{v4}}suffix\"></div>\n * ```\n *\n * Its compiled representation is::\n *\n * ```ts\n * propertyInterpolate5(\n * 'title', 'prefix', v0, '-', v1, '-', v2, '-', v3, '-', v4, 'suffix');\n * ```\n *\n * If the property name also exists as an input property on one of the element's directives,\n * the component property will be set instead of the element property. This check must\n * be conducted at runtime so child components that add new `@Inputs` don't have to be re-compiled.\n *\n * @param propName The name of the property to update\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param i1 Static value used for concatenation only.\n * @param v2 Value checked for change.\n * @param i2 Static value used for concatenation only.\n * @param v3 Value checked for change.\n * @param i3 Static value used for concatenation only.\n * @param v4 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @param sanitizer An optional sanitizer function\n * @returns itself, so that it may be chained.\n * @codeGenApi\n */\nexport function propertyInterpolate5(\n    propName: string, prefix: string, v0: any, i0: string, v1: any, i1: string, v2: any, i2: string,\n    v3: any, i3: string, v4: any, suffix: string,\n    sanitizer?: SanitizerFn): typeof propertyInterpolate5 {\n  const lView = getLView();\n  const interpolatedValue =\n      interpolation5(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, suffix);\n  if (interpolatedValue !== NO_CHANGE) {\n    const tView = getTView();\n    const tNode = getSelectedTNode();\n    elementPropertyInternal(\n        tView, tNode, lView, propName, interpolatedValue, lView[RENDERER], sanitizer, false);\n    ngDevMode &&\n        storePropertyBindingMetadata(\n            tView.data, tNode, propName, getBindingIndex() - 5, prefix, i0, i1, i2, i3, suffix);\n  }\n  return propertyInterpolate5;\n}\n\n/**\n *\n * Update an interpolated property on an element with 6 bound values surrounded by text.\n *\n * Used when the value passed to a property has 6 interpolated values in it:\n *\n * ```html\n * <div title=\"prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}-{{v4}}-{{v5}}suffix\"></div>\n * ```\n *\n * Its compiled representation is::\n *\n * ```ts\n * propertyInterpolate6(\n *    'title', 'prefix', v0, '-', v1, '-', v2, '-', v3, '-', v4, '-', v5, 'suffix');\n * ```\n *\n * If the property name also exists as an input property on one of the element's directives,\n * the component property will be set instead of the element property. This check must\n * be conducted at runtime so child components that add new `@Inputs` don't have to be re-compiled.\n *\n * @param propName The name of the property to update\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param i1 Static value used for concatenation only.\n * @param v2 Value checked for change.\n * @param i2 Static value used for concatenation only.\n * @param v3 Value checked for change.\n * @param i3 Static value used for concatenation only.\n * @param v4 Value checked for change.\n * @param i4 Static value used for concatenation only.\n * @param v5 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @param sanitizer An optional sanitizer function\n * @returns itself, so that it may be chained.\n * @codeGenApi\n */\nexport function propertyInterpolate6(\n    propName: string, prefix: string, v0: any, i0: string, v1: any, i1: string, v2: any, i2: string,\n    v3: any, i3: string, v4: any, i4: string, v5: any, suffix: string,\n    sanitizer?: SanitizerFn): typeof propertyInterpolate6 {\n  const lView = getLView();\n  const interpolatedValue =\n      interpolation6(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, suffix);\n  if (interpolatedValue !== NO_CHANGE) {\n    const tView = getTView();\n    const tNode = getSelectedTNode();\n    elementPropertyInternal(\n        tView, tNode, lView, propName, interpolatedValue, lView[RENDERER], sanitizer, false);\n    ngDevMode &&\n        storePropertyBindingMetadata(\n            tView.data, tNode, propName, getBindingIndex() - 6, prefix, i0, i1, i2, i3, i4, suffix);\n  }\n  return propertyInterpolate6;\n}\n\n/**\n *\n * Update an interpolated property on an element with 7 bound values surrounded by text.\n *\n * Used when the value passed to a property has 7 interpolated values in it:\n *\n * ```html\n * <div title=\"prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}-{{v4}}-{{v5}}-{{v6}}suffix\"></div>\n * ```\n *\n * Its compiled representation is::\n *\n * ```ts\n * propertyInterpolate7(\n *    'title', 'prefix', v0, '-', v1, '-', v2, '-', v3, '-', v4, '-', v5, '-', v6, 'suffix');\n * ```\n *\n * If the property name also exists as an input property on one of the element's directives,\n * the component property will be set instead of the element property. This check must\n * be conducted at runtime so child components that add new `@Inputs` don't have to be re-compiled.\n *\n * @param propName The name of the property to update\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param i1 Static value used for concatenation only.\n * @param v2 Value checked for change.\n * @param i2 Static value used for concatenation only.\n * @param v3 Value checked for change.\n * @param i3 Static value used for concatenation only.\n * @param v4 Value checked for change.\n * @param i4 Static value used for concatenation only.\n * @param v5 Value checked for change.\n * @param i5 Static value used for concatenation only.\n * @param v6 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @param sanitizer An optional sanitizer function\n * @returns itself, so that it may be chained.\n * @codeGenApi\n */\nexport function propertyInterpolate7(\n    propName: string, prefix: string, v0: any, i0: string, v1: any, i1: string, v2: any, i2: string,\n    v3: any, i3: string, v4: any, i4: string, v5: any, i5: string, v6: any, suffix: string,\n    sanitizer?: SanitizerFn): typeof propertyInterpolate7 {\n  const lView = getLView();\n  const interpolatedValue =\n      interpolation7(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, suffix);\n  if (interpolatedValue !== NO_CHANGE) {\n    const tView = getTView();\n    const tNode = getSelectedTNode();\n    elementPropertyInternal(\n        tView, tNode, lView, propName, interpolatedValue, lView[RENDERER], sanitizer, false);\n    ngDevMode &&\n        storePropertyBindingMetadata(\n            tView.data, tNode, propName, getBindingIndex() - 7, prefix, i0, i1, i2, i3, i4, i5,\n            suffix);\n  }\n  return propertyInterpolate7;\n}\n\n/**\n *\n * Update an interpolated property on an element with 8 bound values surrounded by text.\n *\n * Used when the value passed to a property has 8 interpolated values in it:\n *\n * ```html\n * <div title=\"prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}-{{v4}}-{{v5}}-{{v6}}-{{v7}}suffix\"></div>\n * ```\n *\n * Its compiled representation is::\n *\n * ```ts\n * propertyInterpolate8(\n *  'title', 'prefix', v0, '-', v1, '-', v2, '-', v3, '-', v4, '-', v5, '-', v6, '-', v7, 'suffix');\n * ```\n *\n * If the property name also exists as an input property on one of the element's directives,\n * the component property will be set instead of the element property. This check must\n * be conducted at runtime so child components that add new `@Inputs` don't have to be re-compiled.\n *\n * @param propName The name of the property to update\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param i1 Static value used for concatenation only.\n * @param v2 Value checked for change.\n * @param i2 Static value used for concatenation only.\n * @param v3 Value checked for change.\n * @param i3 Static value used for concatenation only.\n * @param v4 Value checked for change.\n * @param i4 Static value used for concatenation only.\n * @param v5 Value checked for change.\n * @param i5 Static value used for concatenation only.\n * @param v6 Value checked for change.\n * @param i6 Static value used for concatenation only.\n * @param v7 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @param sanitizer An optional sanitizer function\n * @returns itself, so that it may be chained.\n * @codeGenApi\n */\nexport function propertyInterpolate8(\n    propName: string, prefix: string, v0: any, i0: string, v1: any, i1: string, v2: any, i2: string,\n    v3: any, i3: string, v4: any, i4: string, v5: any, i5: string, v6: any, i6: string, v7: any,\n    suffix: string, sanitizer?: SanitizerFn): typeof propertyInterpolate8 {\n  const lView = getLView();\n  const interpolatedValue = interpolation8(\n      lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, i6, v7, suffix);\n  if (interpolatedValue !== NO_CHANGE) {\n    const tView = getTView();\n    const tNode = getSelectedTNode();\n    elementPropertyInternal(\n        tView, tNode, lView, propName, interpolatedValue, lView[RENDERER], sanitizer, false);\n    ngDevMode &&\n        storePropertyBindingMetadata(\n            tView.data, tNode, propName, getBindingIndex() - 8, prefix, i0, i1, i2, i3, i4, i5, i6,\n            suffix);\n  }\n  return propertyInterpolate8;\n}\n\n/**\n * Update an interpolated property on an element with 9 or more bound values surrounded by text.\n *\n * Used when the number of interpolated values exceeds 8.\n *\n * ```html\n * <div\n *  title=\"prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}-{{v4}}-{{v5}}-{{v6}}-{{v7}}-{{v8}}-{{v9}}suffix\"></div>\n * ```\n *\n * Its compiled representation is::\n *\n * ```ts\n * propertyInterpolateV(\n *  'title', ['prefix', v0, '-', v1, '-', v2, '-', v3, '-', v4, '-', v5, '-', v6, '-', v7, '-', v9,\n *  'suffix']);\n * ```\n *\n * If the property name also exists as an input property on one of the element's directives,\n * the component property will be set instead of the element property. This check must\n * be conducted at runtime so child components that add new `@Inputs` don't have to be re-compiled.\n *\n * @param propName The name of the property to update.\n * @param values The collection of values and the strings in between those values, beginning with a\n * string prefix and ending with a string suffix.\n * (e.g. `['prefix', value0, '-', value1, '-', value2, ..., value99, 'suffix']`)\n * @param sanitizer An optional sanitizer function\n * @returns itself, so that it may be chained.\n * @codeGenApi\n */\nexport function propertyInterpolateV(\n    propName: string, values: any[], sanitizer?: SanitizerFn): typeof propertyInterpolateV {\n  const lView = getLView();\n  const interpolatedValue = interpolationV(lView, values);\n  if (interpolatedValue !== NO_CHANGE) {\n    const tView = getTView();\n    const tNode = getSelectedTNode();\n    elementPropertyInternal(\n        tView, tNode, lView, propName, interpolatedValue, lView[RENDERER], sanitizer, false);\n    if (ngDevMode) {\n      const interpolationInBetween = [values[0]];  // prefix\n      for (let i = 2; i < values.length; i += 2) {\n        interpolationInBetween.push(values[i]);\n      }\n      storePropertyBindingMetadata(\n          tView.data, tNode, propName, getBindingIndex() - interpolationInBetween.length + 1,\n          ...interpolationInBetween);\n    }\n  }\n  return propertyInterpolateV;\n}\n"],"names":["ES5_DELEGATE_CTOR","ES2015_INHERITED_CLASS","ES2015_INHERITED_CLASS_WITH_CTOR","ES2015_INHERITED_CLASS_WITH_DELEGATE_CTOR","ReflectionCapabilities","constructor","reflect","this","_reflect","global","factory","t","args","_zipTypesAndAnnotations","paramTypes","paramAnnotations","result","newArray","length","i","Object","concat","_ownParameters","type","parentCtor","typeStr","toString","test","parameters","tsickleCtorParams","ctorParameters","map","ctorParam","convertTsickleDecoratorIntoMetadata","decorators","hasOwnProperty","PARAMETERS","getOwnMetadata","isType","getParentCtor","_ownAnnotations","typeOrFunc","annotations","ANNOTATIONS","ownAnnotations","_ownPropMetadata","propMetadata","propDecorators","keys","forEach","prop","PROP_METADATA","parentPropMetadata","propName","ownPropMetadata","push","hasLifecycleHook","lcProperty","Type","prototype","decoratorInvocations","decoratorInvocation","annotationCls","ctor","parentProto","getPrototypeOf","Attribute","makeParamDecorator","attributeName","__NG_ELEMENT_ID__","injectAttribute","getReflect","reflectDependencies","dep","meta","token","attribute","host","optional","self","skipSelf","Array","isArray","j","param","undefined","proto","Optional","ngMetadataName","SkipSelf","Self","Host","Inject","RuntimeError","ngDevMode","reflectDependency","isModuleWithProviders","value","ngModule","isNgModule","getNgModuleDef","isPipe","getPipeDef","isDirective","getDirectiveDef","isComponent","getComponentDef","verifyStandaloneImport","depType","importingType","isForwardRef","resolveForwardRef","Error","stringifyForError","def","standalone","USE_RUNTIME_DEPS_TRACKER_FOR_JIT","addSet","sourceSet","targetSet","m","add","depsTracker","ownerNgModule","Map","ngModulesWithSomeUnresolvedDecls","Set","ngModulesScopeCache","standaloneComponentsScopeCache","resolveNgModulesDecls","size","moduleType","declarations","decl","maybeUnwrapFn","set","clear","getComponentDependencies","rawImports","scope","getStandaloneComponentScope","compilation","isPoisoned","dependencies","directives","pipes","ngModules","has","getNgModuleScope","get","registerNgModule","scopeInfo","clearScopeCacheFor","delete","computeNgModuleScope","exported","imported","imports","importedScope","isStandalone","exports","exportedScope","ans","computeStandaloneComponentScope","rawImport","flatten","e","isOrphanComponent","cmp","modules","findHostDirectiveDefs","currentDef","matchedDefs","hostDirectiveDefs","hostDirectives","hostDirectiveConfig","hostDirectiveDef","directive","patchDeclaredInputs","declaredInputs","inputs","bindingArrayToMap","bindings","EMPTY_OBJ","exposedInputs","publicName","remappedPublicName","privateName","COPY_DIRECTIVE_FIELDS","COPY_COMPONENT_FIELDS","getTemplateLocationDetails","lView","throwError","hostComponentDef","context","DECLARATION_COMPONENT_VIEW","CONTEXT","getDeclarationComponentDef","componentClassName","name","DeferDependenciesLoadingState","MINIMUM_SLOT","LOADING_AFTER_SLOT","DeferBlockState","DeferBlockInternalState","NEXT_DEFER_BLOCK_STATE","DEFER_BLOCK_STATE","STATE_IS_FROZEN_UNTIL","LOADING_AFTER_CLEANUP_FN","TRIGGER_CLEANUP_FNS","PREFETCH_TRIGGER_CLEANUP_FNS","DeferBlockBehavior","storeTriggerCleanupFn","lDetails","cleanupFn","key","invokeTriggerCleanupFns","cleanupFns","invokeAllTriggerCleanupFns","getDeferBlockDataIndex","deferBlockIndex","getLDeferBlockDetails","tNode","TVIEW","index","getTDeferBlockDetails","tView","slotIndex","data","getMinimumDurationForState","tDetails","currentState","Placeholder","placeholderBlockConfig","Loading","loadingBlockConfig","getLoadingBlockAfter","addDepsToRegistry","currentDeps","newDeps","currentDepSet","from","eventListenerOptions","passive","capture","hoverTriggers","WeakMap","interactionTriggers","viewportTriggers","interactionEventNames","hoverEventNames","intersectionObserver","observedViewportElements","DeferEventEntry","callbacks","listener","callback","onInteraction","trigger","entry","addEventListener","removeEventListener","onHover","onViewport","injector","ngZone","NgZone","runOutsideAngular","IntersectionObserver","entries","current","isIntersecting","target","run","observe","unobserve","disconnect","registerDomTrigger","initialLView","triggerIndex","walkUpTimes","registerFn","INJECTOR","internalAfterNextRender","pollDomTrigger","isDestroyed","renderedState","Initial","triggerLView","deferredHostLView","deferredTNode","walkUpViews","CONTAINER_HEADER_OFFSET","getTriggerLView","element","getNativeByIndex","HEADER_OFFSET","getTriggerElement","cleanup","removeLViewOnDestroy","storeLViewOnDestroy","onIdle","scheduler","IdleScheduler","remove","executingCallbacks","idleId","deferred","inject","requestIdleCallbackFn","requestIdleCallback","setTimeout","bind","globalThis","cancelIdleCallbackFn","cancelIdleCallback","clearTimeout","scheduleIdleCallback","ngOnDestroy","prov","defineInjectable","providedIn","onTimer","delay","scheduleTimerTrigger","TimerScheduler","timeoutId","invokeTimerAt","addToQueue","Date","now","scheduleTimer","removeFromQueue","invokeAt","insertAtIndex","arrayInsert2","arraySplice","lastCallbackIndex","timeout","Math","max","InjectionToken","DEFER_BLOCK_CONFIG","shouldTriggerDeferBlock","config","behavior","Manual","isPlatformBrowser","applyDeferBlockStateWithSchedulingImpl","scheduleDelayedTrigger","scheduleFn","getLView","getCurrentTNode","renderPlaceholder","triggerDeferBlock","scheduleDelayedPrefetching","loadingState","NOT_STARTED","prefetch","triggerPrefetching","renderDeferBlockState","newState","lContainer","skipTimerScheduling","hostLView","PARENT","hostTView","isValidStateChange","applyStateFn","applyDeferBlockState","error","handleError","stateTmplIndex","Complete","primaryTmplIndex","loadingTmplIndex","errorTmplIndex","placeholderTmplIndex","getTemplateIndexForState","adjustedIndex","getTNode","viewIndex","removeLViewFromLContainer","dehydratedView","findMatchingDehydratedView","ssrId","embeddedLView","createAndRenderEmbeddedLView","addLViewToLContainer","shouldAddViewToDom","markViewDirty","applyDeferBlockStateWithScheduling","loadingAfter","inLoadingAfterPhase","duration","scheduleDeferBlockUpdate","nextState","triggerResourceLoading","primaryBlockTNode","getPrimaryBlockTNode","IN_PROGRESS","dependenciesFn","dependencyResolverFn","loadingPromise","Promise","allSettled","then","results","failed","directiveDefs","pipeDefs","status","dependency","directiveDef","pipeDef","FAILED","COMPLETE","primaryBlockTView","directiveRegistry","pipeRegistry","resolve","renderDeferStateAfterResourceLoading","ELEMENT_MARKER","marker","ICU_MARKER","I18nCreateOpCode","getInsertInFrontOfRNodeWithI18n","parentTNode","currentTNode","tNodeInsertBeforeIndex","insertBeforeIndex","getInsertInFrontOfRNodeWithNoI18n","unwrapRNode","processI18nInsertBefore","renderer","childTNode","childRNode","parentRElement","i18nParent","anchorRNode","componentOffset","i18nChild","nativeInsertBefore","addTNodeAndUpdateInsertBeforeIndex","previousTNodes","newTNode","existingTNode","isI18nText","isNewTNodeCreatedBefore","getInsertBeforeIndex","setInsertBeforeIndex","setI18nHandling","getTIcu","createTNodePlaceholder","createTNodeAtIndex","getCurrentICUCaseIndex","tIcu","currentCase","currentCaseLViewIndex","changeMask","changeMaskCounter","applyMutableOpCodes","mutableOpCodes","RENDERER","rootRNode","rootIdx","opCode","textNodeIndex","createTextNode","parentIdx","insertInFrontOf","parentRNode","nativeParentNode","refIdx","child","caseIndex","create","anchorIdx","elementNodeIndex","attrName","attrValue","setElementAttribute","commentValue","commentNodeIndex","commentRNode","createCommentNode","attachPatchData","tagName","elementRNode","createElementNode","applyUpdateOpCodes","updateOpCodes","bindingsStartIndex","checkBit","skipCodes","renderStringify","nodeIndex","sanitizeFn","tNodeOrTagName","elementPropertyInternal","rText","updateTextNode","applyIcuSwitchCase","applyIcuUpdateCase","activeCaseIndex","mask","update","icuExpression","bindingValue","cases","indexOf","resolvedCase","getPluralCase","getLocaleId","getCaseIndex","applyIcuSwitchCaseRemove","removeCodes","nodeOrIcuIndex","rNode","nativeRemoveNode","loadIcuContainerVisitor","_stack","_lView","_removes","_index","enterIcu","EMPTY_ARRAY","icuContainerIteratorNext","removeOpCode","tIcuIndex","pop","tIcuContainerNode","BINDING_REGEXP","ICU_REGEXP","NESTED_ICU","ICU_BLOCK_REGEXP","MARKER","SUBTEMPLATE_REGEXP","PH_REGEXP","NGSP_UNICODE_REGEXP","createTNodeAndAddOpCode","rootTNode","existingTNodes","createOpCodes","text","isICU","i18nNodeIdx","allocExpando","SHIFT","getCurrentParentTNode","APPEND_EAGERLY","COMMENT","ensureIcuContainerVisitorLoaded","tNodeIdx","setCurrentTNode","assertEqual","setTNodeInsertBeforeIndex","i18nStartFirstCreatePassProcessTextNode","hasBinding","match","generateBindingUpdateOpCodes","str","destinationNode","bindingStart","maskIndex","sizeIndex","startIndex","textParts","split","textValue","bindingIndex","parseInt","toMaskBit","countBindings","opCodes","count","min","removeInnerTemplateTranslation","message","tagMatched","res","inTemplate","exec","substring","slice","icuStart","bindingMask","mainBinding","addUpdateIcuSwitch","setTIcu","values","valueArr","nestedIcus","icuIndex","parseIcuCase","join","addUpdateIcuUpdate","parseICUBlock","pattern","icuType","parts","i18nParseTextIntoPartsAndICU","replace","binding","pos","trim","blocks","prevPos","braceStack","braces","lastIndex","block","caseName","unsafeCaseHtml","inertBodyElement","getInertBodyHelper","getDocument","getInertBodyElement","inertRootNode","getTemplateContent","walkIcuTree","sharedUpdateOpCodes","parentNode","depth","currentNode","firstChild","newIndex","nodeType","Node","ELEMENT_NODE","toLowerCase","VALID_ELEMENTS","addCreateNodeAndAppend","elAttrs","attributes","attr","item","lowerAttrName","VALID_ATTRS","URI_ATTRS","_sanitizeUrl","addCreateAttribute","addRemoveNode","TEXT_NODE","textContent","COMMENT_NODE","isNestedIcu","addRemoveNestedIcu","nextSibling","appendToParentIdx","createAtIdx","PP_MULTI_VALUE_PLACEHOLDERS_REGEXP","PP_PLACEHOLDERS_REGEXP","PP_ICU_VARS_REGEXP","PP_ICU_PLACEHOLDERS_REGEXP","PP_ICUS_REGEXP","PP_CLOSE_TEMPLATE_REGEXP","PP_TEMPLATE_ID_REGEXP","i18nStart","messageIndex","subTemplateIndex","getTView","getConstant","consts","firstCreatePass","parentTNodeIndex","existingTNodeStack","isRootTemplateMessage","start","end","search","RegExp","getTranslationForTemplate","msgParts","part","isClosing","charCodeAt","Number","shift","unshift","i18nStartFirstCreatePass","FLAGS","tI18n","sameViewParentTNode","T_HOST","getClosestRElement","isComment","appendNow","createComment","applyCreateOpCodes","setInI18nBlock","i18nEnd","convertToTypeArray","flattenValues","some","maybeUnwrapModuleWithProviders","angularCoreEnv","r3","attributeInterpolate1","prefix","v0","suffix","sanitizer","namespace","interpolatedValue","interpolation1","NO_CHANGE","getSelectedTNode","elementAttributeInternal","attributeInterpolate2","i0","v1","interpolation2","attributeInterpolate3","i1","v2","interpolation3","attributeInterpolate4","i2","v3","interpolation4","attributeInterpolate5","i3","v4","interpolation5","attributeInterpolate6","i4","v5","interpolation6","attributeInterpolate7","i5","v6","interpolation7","attributeInterpolate8","i6","v7","interpolation8","attributeInterpolateV","interpolated","interpolationV","defineInjector","inject","invalidFactoryDep","rawHostDirectives","definition","dir","outputs","superDef","superType","getSuperType","isComponentDef","cmp","dir","defAny","field","styleMap","stylePropInterpolate1","valueSuffix","checkStylingProperty","stylePropInterpolate2","stylePropInterpolate3","stylePropInterpolate4","stylePropInterpolate5","stylePropInterpolate6","stylePropInterpolate7","stylePropInterpolate8","stylePropInterpolateV","loadingConfigIndex","placeholderConfigIndex","enableTimerScheduling","template","performanceMarkFeature","deferBlockConfig","setTDeferBlockDetails","populateDehydratedViewsInLContainer","setLDeferBlockDetails","cleanupTriggersFn","rawValue","nextBindingIndex","bindingUpdated","prevConsumer","setActiveConsumer","Boolean","tViewConsts","attrsIndex","attrs","previousElementIndex","i18nAttributesFirstPass","i18nExp","getBindingIndex","applyI18n","replacements","matches","templateIdsStack","phs","tmpl","content","placeholders","placeholder","templateId","isCloseTemplateTag","currentTemplateId","idx","splice","_type","_idx","list","i18nPostprocess","extractDefListOrFactory","noSideEffects","ngModuleDef","bootstrap","ngModuleType","id","incoming","stringify","assertSameOrNotExisting","console","debugInfo","sanitization","getNativeByTNode","iframe","src","srcdoc","trustedHTMLFromString","errorMessage","forwardRef","moduleQueue","flushingModuleQueue","isResolvedDeclaration","declaration","every","setScopeOnDeclaredComponents","transitiveScopes","transitiveScopesFor","NG_COMP_DEF","component","patchComponentDefWithScope","NG_DIR_DEF","NG_PIPE_DEF","ngSelectorScope","componentDef","filter","pipe","schemas","transitiveCompileScopes","scopes","declared","declaredWithDefs","exportedType","transitiveScopesForNgModule","compilationDepth","compileDirective","ngDirectiveDef","addDirectiveFactoryDef","defineProperty","getDirectiveMetadata","compiler","getCompilerFacade","usage","kind","sourceMapUrl","metadata","configurable","facade","directiveMetadata","typeSourceSpan","createParseSourceSpan","usesInheritance","addDirectiveDefToUndecoratedParents","ngFactoryDef","NG_FACTORY_DEF","compileFactory","typeArgumentCount","deps","FactoryTarget","Directive","extendsDirectlyFromObject","selector","queries","extractQueriesMetadata","isContentQuery","lifecycle","usesOnChanges","exportAs","splitByComma","providers","viewQueries","isViewQuery","isSignal","signals","objPrototype","parent","shouldAddAbstractDirective","convertToR3QueryMetadata","propertyName","ann","predicate","descendants","first","read","static","emitDistinctChangesOnly","isQueryAnn","queriesMeta","isInputAnnotation","piece","LIFECYCLE_HOOKS","hookName","metadataName","getPipeMetadata","pipeName","pure","makeDecorator","Input","c","changeDetection","ChangeDetectionStrategy","Default","ngComponentDef","maybeQueueResolutionOfComponentResources","componentNeedsResolution","templateUrl","styleUrls","JSON","styleUrl","options","getJitOptions","preserveWhitespaces","encapsulation","defaultEncapsulation","ViewEncapsulation","Emulated","template","styles","animations","interpolation","viewProviders","compileComponent","cachedDirectiveDefs","cachedPipeDefs","p","d","seen","rawDep","getStandaloneDefFunctions","flushModuleScopingQueueAsMuchAsPossible","ngPipeDef","Pipe","compilePipe","makePropDecorator","arg","alias","hostPropertyName","eventName","classMapInterpolate1","checkStylingMap","keyValueArraySet","classStringParser","classMapInterpolate2","classMapInterpolate3","classMapInterpolate4","classMapInterpolate5","classMapInterpolate6","classMapInterpolate7","classMapInterpolate8","classMapInterpolateV","propertyInterpolate","propertyInterpolate1","propertyInterpolate2","propertyInterpolate3","propertyInterpolate4","propertyInterpolate5","propertyInterpolate6","propertyInterpolate7","propertyInterpolate8","propertyInterpolateV"],"sourceRoot":""}