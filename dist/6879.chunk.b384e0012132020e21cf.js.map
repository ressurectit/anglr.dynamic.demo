{"version":3,"file":"6879.chunk.b384e0012132020e21cf.js","mappings":"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","sources":["webpack://ng-universal-demo/../../../../src/cdk/a11y/key-manager/list-key-manager.ts","webpack://ng-universal-demo/../../../../src/cdk/coercion/boolean-property.ts","webpack://ng-universal-demo/../../../../src/material/core/common-behaviors/color.ts","webpack://ng-universal-demo/../../../../src/material/core/common-behaviors/disable-ripple.ts","webpack://ng-universal-demo/../../../../src/material/core/common-behaviors/disabled.ts","webpack://ng-universal-demo/../../../../src/material/tabs/module.ts","webpack://ng-universal-demo/../../../../src/material/tabs/tab-config.ts","webpack://ng-universal-demo/../../../../src/material/tabs/tabs-animations.ts","webpack://ng-universal-demo/../../../../src/material/tabs/tab-body.ts","webpack://ng-universal-demo/../../../../src/material/tabs/ink-bar.ts","webpack://ng-universal-demo/../../../../src/material/tabs/tab-label-wrapper.ts","webpack://ng-universal-demo/../../../../src/cdk/a11y/key-manager/focus-key-manager.ts","webpack://ng-universal-demo/../../../../src/material/tabs/paginated-tab-header.ts","webpack://ng-universal-demo/../../../../src/material/tabs/tab-header.ts","webpack://ng-universal-demo/../../../../src/material/tabs/tab-header.html","webpack://ng-universal-demo/../../../../src/material/tabs/tab-group.ts","webpack://ng-universal-demo/../../../../src/material/tabs/tab-group.html","webpack://ng-universal-demo/../../../../src/material/tabs/tab-label.ts","webpack://ng-universal-demo/../../../../src/material/tabs/tab-content.ts","webpack://ng-universal-demo/../../../../src/material/tabs/tab.ts","webpack://ng-universal-demo/../../../../src/material/tabs/tab.html"],"sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {QueryList} from '@angular/core';\nimport {Subject, Subscription} from 'rxjs';\nimport {\n  UP_ARROW,\n  DOWN_ARROW,\n  LEFT_ARROW,\n  RIGHT_ARROW,\n  TAB,\n  A,\n  Z,\n  ZERO,\n  NINE,\n  hasModifierKey,\n  HOME,\n  END,\n  PAGE_UP,\n  PAGE_DOWN,\n} from '@angular/cdk/keycodes';\nimport {debounceTime, filter, map, tap} from 'rxjs/operators';\n\n/** This interface is for items that can be passed to a ListKeyManager. */\nexport interface ListKeyManagerOption {\n  /** Whether the option is disabled. */\n  disabled?: boolean;\n\n  /** Gets the label for this option. */\n  getLabel?(): string;\n}\n\n/** Modifier keys handled by the ListKeyManager. */\nexport type ListKeyManagerModifierKey = 'altKey' | 'ctrlKey' | 'metaKey' | 'shiftKey';\n\n/**\n * This class manages keyboard events for selectable lists. If you pass it a query list\n * of items, it will set the active item correctly when arrow events occur.\n */\nexport class ListKeyManager<T extends ListKeyManagerOption> {\n  private _activeItemIndex = -1;\n  private _activeItem: T | null = null;\n  private _wrap = false;\n  private readonly _letterKeyStream = new Subject<string>();\n  private _typeaheadSubscription = Subscription.EMPTY;\n  private _itemChangesSubscription?: Subscription;\n  private _vertical = true;\n  private _horizontal: 'ltr' | 'rtl' | null;\n  private _allowedModifierKeys: ListKeyManagerModifierKey[] = [];\n  private _homeAndEnd = false;\n  private _pageUpAndDown = {enabled: false, delta: 10};\n\n  /**\n   * Predicate function that can be used to check whether an item should be skipped\n   * by the key manager. By default, disabled items are skipped.\n   */\n  private _skipPredicateFn = (item: T) => item.disabled;\n\n  // Buffer for the letters that the user has pressed when the typeahead option is turned on.\n  private _pressedLetters: string[] = [];\n\n  constructor(private _items: QueryList<T> | T[]) {\n    // We allow for the items to be an array because, in some cases, the consumer may\n    // not have access to a QueryList of the items they want to manage (e.g. when the\n    // items aren't being collected via `ViewChildren` or `ContentChildren`).\n    if (_items instanceof QueryList) {\n      this._itemChangesSubscription = _items.changes.subscribe((newItems: QueryList<T>) => {\n        if (this._activeItem) {\n          const itemArray = newItems.toArray();\n          const newIndex = itemArray.indexOf(this._activeItem);\n\n          if (newIndex > -1 && newIndex !== this._activeItemIndex) {\n            this._activeItemIndex = newIndex;\n          }\n        }\n      });\n    }\n  }\n\n  /**\n   * Stream that emits any time the TAB key is pressed, so components can react\n   * when focus is shifted off of the list.\n   */\n  readonly tabOut = new Subject<void>();\n\n  /** Stream that emits whenever the active item of the list manager changes. */\n  readonly change = new Subject<number>();\n\n  /**\n   * Sets the predicate function that determines which items should be skipped by the\n   * list key manager.\n   * @param predicate Function that determines whether the given item should be skipped.\n   */\n  skipPredicate(predicate: (item: T) => boolean): this {\n    this._skipPredicateFn = predicate;\n    return this;\n  }\n\n  /**\n   * Configures wrapping mode, which determines whether the active item will wrap to\n   * the other end of list when there are no more items in the given direction.\n   * @param shouldWrap Whether the list should wrap when reaching the end.\n   */\n  withWrap(shouldWrap = true): this {\n    this._wrap = shouldWrap;\n    return this;\n  }\n\n  /**\n   * Configures whether the key manager should be able to move the selection vertically.\n   * @param enabled Whether vertical selection should be enabled.\n   */\n  withVerticalOrientation(enabled: boolean = true): this {\n    this._vertical = enabled;\n    return this;\n  }\n\n  /**\n   * Configures the key manager to move the selection horizontally.\n   * Passing in `null` will disable horizontal movement.\n   * @param direction Direction in which the selection can be moved.\n   */\n  withHorizontalOrientation(direction: 'ltr' | 'rtl' | null): this {\n    this._horizontal = direction;\n    return this;\n  }\n\n  /**\n   * Modifier keys which are allowed to be held down and whose default actions will be prevented\n   * as the user is pressing the arrow keys. Defaults to not allowing any modifier keys.\n   */\n  withAllowedModifierKeys(keys: ListKeyManagerModifierKey[]): this {\n    this._allowedModifierKeys = keys;\n    return this;\n  }\n\n  /**\n   * Turns on typeahead mode which allows users to set the active item by typing.\n   * @param debounceInterval Time to wait after the last keystroke before setting the active item.\n   */\n  withTypeAhead(debounceInterval: number = 200): this {\n    if (\n      (typeof ngDevMode === 'undefined' || ngDevMode) &&\n      this._items.length &&\n      this._items.some(item => typeof item.getLabel !== 'function')\n    ) {\n      throw Error('ListKeyManager items in typeahead mode must implement the `getLabel` method.');\n    }\n\n    this._typeaheadSubscription.unsubscribe();\n\n    // Debounce the presses of non-navigational keys, collect the ones that correspond to letters\n    // and convert those letters back into a string. Afterwards find the first item that starts\n    // with that string and select it.\n    this._typeaheadSubscription = this._letterKeyStream\n      .pipe(\n        tap(letter => this._pressedLetters.push(letter)),\n        debounceTime(debounceInterval),\n        filter(() => this._pressedLetters.length > 0),\n        map(() => this._pressedLetters.join('')),\n      )\n      .subscribe(inputString => {\n        const items = this._getItemsArray();\n\n        // Start at 1 because we want to start searching at the item immediately\n        // following the current active item.\n        for (let i = 1; i < items.length + 1; i++) {\n          const index = (this._activeItemIndex + i) % items.length;\n          const item = items[index];\n\n          if (\n            !this._skipPredicateFn(item) &&\n            item.getLabel!().toUpperCase().trim().indexOf(inputString) === 0\n          ) {\n            this.setActiveItem(index);\n            break;\n          }\n        }\n\n        this._pressedLetters = [];\n      });\n\n    return this;\n  }\n\n  /** Cancels the current typeahead sequence. */\n  cancelTypeahead(): this {\n    this._pressedLetters = [];\n    return this;\n  }\n\n  /**\n   * Configures the key manager to activate the first and last items\n   * respectively when the Home or End key is pressed.\n   * @param enabled Whether pressing the Home or End key activates the first/last item.\n   */\n  withHomeAndEnd(enabled: boolean = true): this {\n    this._homeAndEnd = enabled;\n    return this;\n  }\n\n  /**\n   * Configures the key manager to activate every 10th, configured or first/last element in up/down direction\n   * respectively when the Page-Up or Page-Down key is pressed.\n   * @param enabled Whether pressing the Page-Up or Page-Down key activates the first/last item.\n   * @param delta Whether pressing the Home or End key activates the first/last item.\n   */\n  withPageUpDown(enabled: boolean = true, delta: number = 10): this {\n    this._pageUpAndDown = {enabled, delta};\n    return this;\n  }\n\n  /**\n   * Sets the active item to the item at the index specified.\n   * @param index The index of the item to be set as active.\n   */\n  setActiveItem(index: number): void;\n\n  /**\n   * Sets the active item to the specified item.\n   * @param item The item to be set as active.\n   */\n  setActiveItem(item: T): void;\n\n  setActiveItem(item: any): void {\n    const previousActiveItem = this._activeItem;\n\n    this.updateActiveItem(item);\n\n    if (this._activeItem !== previousActiveItem) {\n      this.change.next(this._activeItemIndex);\n    }\n  }\n\n  /**\n   * Sets the active item depending on the key event passed in.\n   * @param event Keyboard event to be used for determining which element should be active.\n   */\n  onKeydown(event: KeyboardEvent): void {\n    const keyCode = event.keyCode;\n    const modifiers: ListKeyManagerModifierKey[] = ['altKey', 'ctrlKey', 'metaKey', 'shiftKey'];\n    const isModifierAllowed = modifiers.every(modifier => {\n      return !event[modifier] || this._allowedModifierKeys.indexOf(modifier) > -1;\n    });\n\n    switch (keyCode) {\n      case TAB:\n        this.tabOut.next();\n        return;\n\n      case DOWN_ARROW:\n        if (this._vertical && isModifierAllowed) {\n          this.setNextItemActive();\n          break;\n        } else {\n          return;\n        }\n\n      case UP_ARROW:\n        if (this._vertical && isModifierAllowed) {\n          this.setPreviousItemActive();\n          break;\n        } else {\n          return;\n        }\n\n      case RIGHT_ARROW:\n        if (this._horizontal && isModifierAllowed) {\n          this._horizontal === 'rtl' ? this.setPreviousItemActive() : this.setNextItemActive();\n          break;\n        } else {\n          return;\n        }\n\n      case LEFT_ARROW:\n        if (this._horizontal && isModifierAllowed) {\n          this._horizontal === 'rtl' ? this.setNextItemActive() : this.setPreviousItemActive();\n          break;\n        } else {\n          return;\n        }\n\n      case HOME:\n        if (this._homeAndEnd && isModifierAllowed) {\n          this.setFirstItemActive();\n          break;\n        } else {\n          return;\n        }\n\n      case END:\n        if (this._homeAndEnd && isModifierAllowed) {\n          this.setLastItemActive();\n          break;\n        } else {\n          return;\n        }\n\n      case PAGE_UP:\n        if (this._pageUpAndDown.enabled && isModifierAllowed) {\n          const targetIndex = this._activeItemIndex - this._pageUpAndDown.delta;\n          this._setActiveItemByIndex(targetIndex > 0 ? targetIndex : 0, 1);\n          break;\n        } else {\n          return;\n        }\n\n      case PAGE_DOWN:\n        if (this._pageUpAndDown.enabled && isModifierAllowed) {\n          const targetIndex = this._activeItemIndex + this._pageUpAndDown.delta;\n          const itemsLength = this._getItemsArray().length;\n          this._setActiveItemByIndex(targetIndex < itemsLength ? targetIndex : itemsLength - 1, -1);\n          break;\n        } else {\n          return;\n        }\n\n      default:\n        if (isModifierAllowed || hasModifierKey(event, 'shiftKey')) {\n          // Attempt to use the `event.key` which also maps it to the user's keyboard language,\n          // otherwise fall back to resolving alphanumeric characters via the keyCode.\n          if (event.key && event.key.length === 1) {\n            this._letterKeyStream.next(event.key.toLocaleUpperCase());\n          } else if ((keyCode >= A && keyCode <= Z) || (keyCode >= ZERO && keyCode <= NINE)) {\n            this._letterKeyStream.next(String.fromCharCode(keyCode));\n          }\n        }\n\n        // Note that we return here, in order to avoid preventing\n        // the default action of non-navigational keys.\n        return;\n    }\n\n    this._pressedLetters = [];\n    event.preventDefault();\n  }\n\n  /** Index of the currently active item. */\n  get activeItemIndex(): number | null {\n    return this._activeItemIndex;\n  }\n\n  /** The active item. */\n  get activeItem(): T | null {\n    return this._activeItem;\n  }\n\n  /** Gets whether the user is currently typing into the manager using the typeahead feature. */\n  isTyping(): boolean {\n    return this._pressedLetters.length > 0;\n  }\n\n  /** Sets the active item to the first enabled item in the list. */\n  setFirstItemActive(): void {\n    this._setActiveItemByIndex(0, 1);\n  }\n\n  /** Sets the active item to the last enabled item in the list. */\n  setLastItemActive(): void {\n    this._setActiveItemByIndex(this._items.length - 1, -1);\n  }\n\n  /** Sets the active item to the next enabled item in the list. */\n  setNextItemActive(): void {\n    this._activeItemIndex < 0 ? this.setFirstItemActive() : this._setActiveItemByDelta(1);\n  }\n\n  /** Sets the active item to a previous enabled item in the list. */\n  setPreviousItemActive(): void {\n    this._activeItemIndex < 0 && this._wrap\n      ? this.setLastItemActive()\n      : this._setActiveItemByDelta(-1);\n  }\n\n  /**\n   * Allows setting the active without any other effects.\n   * @param index Index of the item to be set as active.\n   */\n  updateActiveItem(index: number): void;\n\n  /**\n   * Allows setting the active item without any other effects.\n   * @param item Item to be set as active.\n   */\n  updateActiveItem(item: T): void;\n\n  updateActiveItem(item: any): void {\n    const itemArray = this._getItemsArray();\n    const index = typeof item === 'number' ? item : itemArray.indexOf(item);\n    const activeItem = itemArray[index];\n\n    // Explicitly check for `null` and `undefined` because other falsy values are valid.\n    this._activeItem = activeItem == null ? null : activeItem;\n    this._activeItemIndex = index;\n  }\n\n  /** Cleans up the key manager. */\n  destroy() {\n    this._typeaheadSubscription.unsubscribe();\n    this._itemChangesSubscription?.unsubscribe();\n    this._letterKeyStream.complete();\n    this.tabOut.complete();\n    this.change.complete();\n    this._pressedLetters = [];\n  }\n\n  /**\n   * This method sets the active item, given a list of items and the delta between the\n   * currently active item and the new active item. It will calculate differently\n   * depending on whether wrap mode is turned on.\n   */\n  private _setActiveItemByDelta(delta: -1 | 1): void {\n    this._wrap ? this._setActiveInWrapMode(delta) : this._setActiveInDefaultMode(delta);\n  }\n\n  /**\n   * Sets the active item properly given \"wrap\" mode. In other words, it will continue to move\n   * down the list until it finds an item that is not disabled, and it will wrap if it\n   * encounters either end of the list.\n   */\n  private _setActiveInWrapMode(delta: -1 | 1): void {\n    const items = this._getItemsArray();\n\n    for (let i = 1; i <= items.length; i++) {\n      const index = (this._activeItemIndex + delta * i + items.length) % items.length;\n      const item = items[index];\n\n      if (!this._skipPredicateFn(item)) {\n        this.setActiveItem(index);\n        return;\n      }\n    }\n  }\n\n  /**\n   * Sets the active item properly given the default mode. In other words, it will\n   * continue to move down the list until it finds an item that is not disabled. If\n   * it encounters either end of the list, it will stop and not wrap.\n   */\n  private _setActiveInDefaultMode(delta: -1 | 1): void {\n    this._setActiveItemByIndex(this._activeItemIndex + delta, delta);\n  }\n\n  /**\n   * Sets the active item to the first enabled item starting at the index specified. If the\n   * item is disabled, it will move in the fallbackDelta direction until it either\n   * finds an enabled item or encounters the end of the list.\n   */\n  private _setActiveItemByIndex(index: number, fallbackDelta: -1 | 1): void {\n    const items = this._getItemsArray();\n\n    if (!items[index]) {\n      return;\n    }\n\n    while (this._skipPredicateFn(items[index])) {\n      index += fallbackDelta;\n\n      if (!items[index]) {\n        return;\n      }\n    }\n\n    this.setActiveItem(index);\n  }\n\n  /** Returns the items as an array. */\n  private _getItemsArray(): T[] {\n    return this._items instanceof QueryList ? this._items.toArray() : this._items;\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * Type describing the allowed values for a boolean input.\n * @docs-private\n */\nexport type BooleanInput = string | boolean | null | undefined;\n\n/** Coerces a data-bound value (typically a string) to a boolean. */\nexport function coerceBooleanProperty(value: any): boolean {\n  return value != null && `${value}` !== 'false';\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {AbstractConstructor, Constructor} from './constructor';\nimport {ElementRef} from '@angular/core';\n\n/** @docs-private */\nexport interface CanColor {\n  /** Theme color palette for the component. */\n  color: ThemePalette;\n\n  /** Default color to fall back to if no value is set. */\n  defaultColor: ThemePalette | undefined;\n}\n\ntype CanColorCtor = Constructor<CanColor> & AbstractConstructor<CanColor>;\n\n/** @docs-private */\nexport interface HasElementRef {\n  _elementRef: ElementRef;\n}\n\n/** Possible color palette values. */\nexport type ThemePalette = 'primary' | 'accent' | 'warn' | undefined;\n\n/** Mixin to augment a directive with a `color` property. */\nexport function mixinColor<T extends AbstractConstructor<HasElementRef>>(\n  base: T,\n  defaultColor?: ThemePalette,\n): CanColorCtor & T;\nexport function mixinColor<T extends Constructor<HasElementRef>>(\n  base: T,\n  defaultColor?: ThemePalette,\n): CanColorCtor & T {\n  return class extends base {\n    private _color: ThemePalette;\n    defaultColor = defaultColor;\n\n    get color(): ThemePalette {\n      return this._color;\n    }\n    set color(value: ThemePalette) {\n      const colorPalette = value || this.defaultColor;\n\n      if (colorPalette !== this._color) {\n        if (this._color) {\n          this._elementRef.nativeElement.classList.remove(`mat-${this._color}`);\n        }\n        if (colorPalette) {\n          this._elementRef.nativeElement.classList.add(`mat-${colorPalette}`);\n        }\n\n        this._color = colorPalette;\n      }\n    }\n\n    constructor(...args: any[]) {\n      super(...args);\n\n      // Set the default color that can be specified from the mixin.\n      this.color = defaultColor;\n    }\n  };\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {coerceBooleanProperty} from '@angular/cdk/coercion';\nimport {AbstractConstructor, Constructor} from './constructor';\n\n/** @docs-private */\nexport interface CanDisableRipple {\n  /** Whether ripples are disabled. */\n  disableRipple: boolean;\n}\n\ntype CanDisableRippleCtor = Constructor<CanDisableRipple> & AbstractConstructor<CanDisableRipple>;\n\n/** Mixin to augment a directive with a `disableRipple` property. */\nexport function mixinDisableRipple<T extends AbstractConstructor<{}>>(\n  base: T,\n): CanDisableRippleCtor & T;\nexport function mixinDisableRipple<T extends Constructor<{}>>(base: T): CanDisableRippleCtor & T {\n  return class extends base {\n    private _disableRipple: boolean = false;\n\n    /** Whether the ripple effect is disabled or not. */\n    get disableRipple(): boolean {\n      return this._disableRipple;\n    }\n    set disableRipple(value: any) {\n      this._disableRipple = coerceBooleanProperty(value);\n    }\n\n    constructor(...args: any[]) {\n      super(...args);\n    }\n  };\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {coerceBooleanProperty} from '@angular/cdk/coercion';\nimport {AbstractConstructor, Constructor} from './constructor';\n\n/** @docs-private */\nexport interface CanDisable {\n  /** Whether the component is disabled. */\n  disabled: boolean;\n}\n\ntype CanDisableCtor = Constructor<CanDisable> & AbstractConstructor<CanDisable>;\n\n/** Mixin to augment a directive with a `disabled` property. */\nexport function mixinDisabled<T extends AbstractConstructor<{}>>(base: T): CanDisableCtor & T;\nexport function mixinDisabled<T extends Constructor<{}>>(base: T): CanDisableCtor & T {\n  return class extends base {\n    private _disabled: boolean = false;\n\n    get disabled(): boolean {\n      return this._disabled;\n    }\n    set disabled(value: any) {\n      this._disabled = coerceBooleanProperty(value);\n    }\n\n    constructor(...args: any[]) {\n      super(...args);\n    }\n  };\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {CommonModule} from '@angular/common';\nimport {NgModule} from '@angular/core';\nimport {MatCommonModule, MatRippleModule} from '@angular/material/core';\nimport {PortalModule} from '@angular/cdk/portal';\nimport {ObserversModule} from '@angular/cdk/observers';\nimport {A11yModule} from '@angular/cdk/a11y';\nimport {MatTabBody, MatTabBodyPortal} from './tab-body';\nimport {MatTabContent} from './tab-content';\nimport {MatTabLabel} from './tab-label';\nimport {MatTabLabelWrapper} from './tab-label-wrapper';\nimport {MatTab} from './tab';\nimport {MatTabHeader} from './tab-header';\nimport {MatTabGroup} from './tab-group';\nimport {MatTabNav, MatTabNavPanel, MatTabLink} from './tab-nav-bar/tab-nav-bar';\n\n@NgModule({\n  imports: [\n    CommonModule,\n    MatCommonModule,\n    PortalModule,\n    MatRippleModule,\n    ObserversModule,\n    A11yModule,\n  ],\n  exports: [\n    MatCommonModule,\n    MatTabContent,\n    MatTabLabel,\n    MatTab,\n    MatTabGroup,\n    MatTabNav,\n    MatTabNavPanel,\n    MatTabLink,\n  ],\n  declarations: [\n    MatTabContent,\n    MatTabLabel,\n    MatTab,\n    MatTabGroup,\n    MatTabNav,\n    MatTabNavPanel,\n    MatTabLink,\n\n    // Private directives, should not be exported.\n    MatTabBody,\n    MatTabBodyPortal,\n    MatTabLabelWrapper,\n    MatTabHeader,\n  ],\n})\nexport class MatTabsModule {}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport {InjectionToken} from '@angular/core';\n\n/** Object that can be used to configure the default options for the tabs module. */\nexport interface MatTabsConfig {\n  /** Duration for the tab animation. Must be a valid CSS value (e.g. 600ms). */\n  animationDuration?: string;\n\n  /**\n   * Whether pagination should be disabled. This can be used to avoid unnecessary\n   * layout recalculations if it's known that pagination won't be required.\n   */\n  disablePagination?: boolean;\n\n  /**\n   * Whether the ink bar should fit its width to the size of the tab label content.\n   * This only applies to the MDC-based tabs.\n   */\n  fitInkBarToContent?: boolean;\n\n  /** Whether the tab group should grow to the size of the active tab. */\n  dynamicHeight?: boolean;\n\n  /** `tabindex` to be set on the inner element that wraps the tab content. */\n  contentTabIndex?: number;\n\n  /**\n   * By default tabs remove their content from the DOM while it's off-screen.\n   * Setting this to `true` will keep it in the DOM which will prevent elements\n   * like iframes and videos from reloading next time it comes back into the view.\n   */\n  preserveContent?: boolean;\n\n  /** Whether tabs should be stretched to fill the header. */\n  stretchTabs?: boolean;\n}\n\n/** Injection token that can be used to provide the default options the tabs module. */\nexport const MAT_TABS_CONFIG = new InjectionToken<MatTabsConfig>('MAT_TABS_CONFIG');\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport {\n  animate,\n  state,\n  style,\n  transition,\n  trigger,\n  AnimationTriggerMetadata,\n} from '@angular/animations';\n\n/**\n * Animations used by the Material tabs.\n * @docs-private\n */\nexport const matTabsAnimations: {\n  readonly translateTab: AnimationTriggerMetadata;\n} = {\n  /** Animation translates a tab along the X axis. */\n  translateTab: trigger('translateTab', [\n    // Transitions to `none` instead of 0, because some browsers might blur the content.\n    state('center, void, left-origin-center, right-origin-center', style({transform: 'none'})),\n\n    // If the tab is either on the left or right, we additionally add a `min-height` of 1px\n    // in order to ensure that the element has a height before its state changes. This is\n    // necessary because Chrome does seem to skip the transition in RTL mode if the element does\n    // not have a static height and is not rendered. See related issue: #9465\n    state(\n      'left',\n      style({\n        transform: 'translate3d(-100%, 0, 0)',\n        minHeight: '1px',\n\n        // Normally this is redundant since we detach the content from the DOM, but if the user\n        // opted into keeping the content in the DOM, we have to hide it so it isn't focusable.\n        visibility: 'hidden',\n      }),\n    ),\n    state(\n      'right',\n      style({\n        transform: 'translate3d(100%, 0, 0)',\n        minHeight: '1px',\n        visibility: 'hidden',\n      }),\n    ),\n\n    transition(\n      '* => left, * => right, left => center, right => center',\n      animate('{{animationDuration}} cubic-bezier(0.35, 0, 0.25, 1)'),\n    ),\n    transition('void => left-origin-center', [\n      style({transform: 'translate3d(-100%, 0, 0)', visibility: 'hidden'}),\n      animate('{{animationDuration}} cubic-bezier(0.35, 0, 0.25, 1)'),\n    ]),\n    transition('void => right-origin-center', [\n      style({transform: 'translate3d(100%, 0, 0)', visibility: 'hidden'}),\n      animate('{{animationDuration}} cubic-bezier(0.35, 0, 0.25, 1)'),\n    ]),\n  ]),\n};\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {\n  ChangeDetectionStrategy,\n  ChangeDetectorRef,\n  Component,\n  ComponentFactoryResolver,\n  Directive,\n  ElementRef,\n  EventEmitter,\n  forwardRef,\n  Inject,\n  Input,\n  OnDestroy,\n  OnInit,\n  Optional,\n  Output,\n  ViewChild,\n  ViewContainerRef,\n  ViewEncapsulation,\n} from '@angular/core';\nimport {CdkPortalOutlet, TemplatePortal} from '@angular/cdk/portal';\nimport {Direction, Directionality} from '@angular/cdk/bidi';\nimport {DOCUMENT} from '@angular/common';\nimport {Subject, Subscription} from 'rxjs';\nimport {distinctUntilChanged, startWith} from 'rxjs/operators';\nimport {AnimationEvent} from '@angular/animations';\nimport {matTabsAnimations} from './tabs-animations';\n\n/**\n * The portal host directive for the contents of the tab.\n * @docs-private\n */\n@Directive({\n  selector: '[matTabBodyHost]',\n})\nexport class MatTabBodyPortal extends CdkPortalOutlet implements OnInit, OnDestroy {\n  /** Subscription to events for when the tab body begins centering. */\n  private _centeringSub = Subscription.EMPTY;\n  /** Subscription to events for when the tab body finishes leaving from center position. */\n  private _leavingSub = Subscription.EMPTY;\n\n  constructor(\n    componentFactoryResolver: ComponentFactoryResolver,\n    viewContainerRef: ViewContainerRef,\n    @Inject(forwardRef(() => MatTabBody)) private _host: MatTabBody,\n    @Inject(DOCUMENT) _document: any,\n  ) {\n    super(componentFactoryResolver, viewContainerRef, _document);\n  }\n\n  /** Set initial visibility or set up subscription for changing visibility. */\n  override ngOnInit(): void {\n    super.ngOnInit();\n\n    this._centeringSub = this._host._beforeCentering\n      .pipe(startWith(this._host._isCenterPosition(this._host._position)))\n      .subscribe((isCentering: boolean) => {\n        if (isCentering && !this.hasAttached()) {\n          this.attach(this._host._content);\n        }\n      });\n\n    this._leavingSub = this._host._afterLeavingCenter.subscribe(() => {\n      if (!this._host.preserveContent) {\n        this.detach();\n      }\n    });\n  }\n\n  /** Clean up centering subscription. */\n  override ngOnDestroy(): void {\n    super.ngOnDestroy();\n    this._centeringSub.unsubscribe();\n    this._leavingSub.unsubscribe();\n  }\n}\n\n/**\n * These position states are used internally as animation states for the tab body. Setting the\n * position state to left, right, or center will transition the tab body from its current\n * position to its respective state. If there is not current position (void, in the case of a new\n * tab body), then there will be no transition animation to its state.\n *\n * In the case of a new tab body that should immediately be centered with an animating transition,\n * then left-origin-center or right-origin-center can be used, which will use left or right as its\n * pseudo-prior state.\n */\nexport type MatTabBodyPositionState =\n  | 'left'\n  | 'center'\n  | 'right'\n  | 'left-origin-center'\n  | 'right-origin-center';\n\n/**\n * Wrapper for the contents of a tab.\n * @docs-private\n */\n@Component({\n  selector: 'mat-tab-body',\n  templateUrl: 'tab-body.html',\n  styleUrls: ['tab-body.css'],\n  encapsulation: ViewEncapsulation.None,\n  // tslint:disable-next-line:validate-decorators\n  changeDetection: ChangeDetectionStrategy.Default,\n  animations: [matTabsAnimations.translateTab],\n  host: {\n    'class': 'mat-mdc-tab-body',\n  },\n})\nexport class MatTabBody implements OnInit, OnDestroy {\n  /** Current position of the tab-body in the tab-group. Zero means that the tab is visible. */\n  private _positionIndex: number;\n\n  /** Subscription to the directionality change observable. */\n  private _dirChangeSubscription = Subscription.EMPTY;\n\n  /** Tab body position state. Used by the animation trigger for the current state. */\n  _position: MatTabBodyPositionState;\n\n  /** Emits when an animation on the tab is complete. */\n  readonly _translateTabComplete = new Subject<AnimationEvent>();\n\n  /** Event emitted when the tab begins to animate towards the center as the active tab. */\n  @Output() readonly _onCentering: EventEmitter<number> = new EventEmitter<number>();\n\n  /** Event emitted before the centering of the tab begins. */\n  @Output() readonly _beforeCentering: EventEmitter<boolean> = new EventEmitter<boolean>();\n\n  /** Event emitted before the centering of the tab begins. */\n  @Output() readonly _afterLeavingCenter: EventEmitter<void> = new EventEmitter<void>();\n\n  /** Event emitted when the tab completes its animation towards the center. */\n  @Output() readonly _onCentered: EventEmitter<void> = new EventEmitter<void>(true);\n\n  /** The portal host inside of this container into which the tab body content will be loaded. */\n  @ViewChild(CdkPortalOutlet) _portalHost: CdkPortalOutlet;\n\n  /** The tab body content to display. */\n  @Input('content') _content: TemplatePortal;\n\n  /** Position that will be used when the tab is immediately becoming visible after creation. */\n  @Input() origin: number | null;\n\n  // Note that the default value will always be overwritten by `MatTabBody`, but we need one\n  // anyway to prevent the animations module from throwing an error if the body is used on its own.\n  /** Duration for the tab's animation. */\n  @Input() animationDuration: string = '500ms';\n\n  /** Whether the tab's content should be kept in the DOM while it's off-screen. */\n  @Input() preserveContent: boolean = false;\n\n  /** The shifted index position of the tab body, where zero represents the active center tab. */\n  @Input()\n  set position(position: number) {\n    this._positionIndex = position;\n    this._computePositionAnimationState();\n  }\n\n  constructor(\n    private _elementRef: ElementRef<HTMLElement>,\n    @Optional() private _dir: Directionality,\n    changeDetectorRef: ChangeDetectorRef,\n  ) {\n    if (_dir) {\n      this._dirChangeSubscription = _dir.change.subscribe((dir: Direction) => {\n        this._computePositionAnimationState(dir);\n        changeDetectorRef.markForCheck();\n      });\n    }\n\n    // Ensure that we get unique animation events, because the `.done` callback can get\n    // invoked twice in some browsers. See https://github.com/angular/angular/issues/24084.\n    this._translateTabComplete\n      .pipe(\n        distinctUntilChanged((x, y) => {\n          return x.fromState === y.fromState && x.toState === y.toState;\n        }),\n      )\n      .subscribe(event => {\n        // If the transition to the center is complete, emit an event.\n        if (this._isCenterPosition(event.toState) && this._isCenterPosition(this._position)) {\n          this._onCentered.emit();\n        }\n\n        if (this._isCenterPosition(event.fromState) && !this._isCenterPosition(this._position)) {\n          this._afterLeavingCenter.emit();\n        }\n      });\n  }\n\n  /**\n   * After initialized, check if the content is centered and has an origin. If so, set the\n   * special position states that transition the tab from the left or right before centering.\n   */\n  ngOnInit() {\n    if (this._position == 'center' && this.origin != null) {\n      this._position = this._computePositionFromOrigin(this.origin);\n    }\n  }\n\n  ngOnDestroy() {\n    this._dirChangeSubscription.unsubscribe();\n    this._translateTabComplete.complete();\n  }\n\n  _onTranslateTabStarted(event: AnimationEvent): void {\n    const isCentering = this._isCenterPosition(event.toState);\n    this._beforeCentering.emit(isCentering);\n    if (isCentering) {\n      this._onCentering.emit(this._elementRef.nativeElement.clientHeight);\n    }\n  }\n\n  /** The text direction of the containing app. */\n  _getLayoutDirection(): Direction {\n    return this._dir && this._dir.value === 'rtl' ? 'rtl' : 'ltr';\n  }\n\n  /** Whether the provided position state is considered center, regardless of origin. */\n  _isCenterPosition(position: MatTabBodyPositionState | string): boolean {\n    return (\n      position == 'center' || position == 'left-origin-center' || position == 'right-origin-center'\n    );\n  }\n\n  /** Computes the position state that will be used for the tab-body animation trigger. */\n  private _computePositionAnimationState(dir: Direction = this._getLayoutDirection()) {\n    if (this._positionIndex < 0) {\n      this._position = dir == 'ltr' ? 'left' : 'right';\n    } else if (this._positionIndex > 0) {\n      this._position = dir == 'ltr' ? 'right' : 'left';\n    } else {\n      this._position = 'center';\n    }\n  }\n\n  /**\n   * Computes the position state based on the specified origin position. This is used if the\n   * tab is becoming visible immediately after creation.\n   */\n  private _computePositionFromOrigin(origin: number): MatTabBodyPositionState {\n    const dir = this._getLayoutDirection();\n\n    if ((dir == 'ltr' && origin <= 0) || (dir == 'rtl' && origin > 0)) {\n      return 'left-origin-center';\n    }\n\n    return 'right-origin-center';\n  }\n}\n\n/**\n * The origin state is an internally used state that is set on a new tab body indicating if it\n * began to the left or right of the prior selected index. For example, if the selected index was\n * set to 1, and a new tab is created and selected at index 2, then the tab body would have an\n * origin of right because its index was greater than the prior selected index.\n */\nexport type MatTabBodyOriginState = 'left' | 'right';\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {BooleanInput, coerceBooleanProperty} from '@angular/cdk/coercion';\nimport {ElementRef, InjectionToken, OnDestroy, OnInit, QueryList} from '@angular/core';\n\n/**\n * Item inside a tab header relative to which the ink bar can be aligned.\n * @docs-private\n */\nexport interface MatInkBarItem extends OnInit, OnDestroy {\n  elementRef: ElementRef<HTMLElement>;\n  activateInkBar(previousIndicatorClientRect?: ClientRect): void;\n  deactivateInkBar(): void;\n  fitInkBarToContent: boolean;\n}\n\n/** Class that is applied when a tab indicator is active. */\nconst ACTIVE_CLASS = 'mdc-tab-indicator--active';\n\n/** Class that is applied when the tab indicator should not transition. */\nconst NO_TRANSITION_CLASS = 'mdc-tab-indicator--no-transition';\n\n/**\n * Abstraction around the MDC tab indicator that acts as the tab header's ink bar.\n * @docs-private\n */\nexport class MatInkBar {\n  /** Item to which the ink bar is aligned currently. */\n  private _currentItem: MatInkBarItem | undefined;\n\n  constructor(private _items: QueryList<MatInkBarItem>) {}\n\n  /** Hides the ink bar. */\n  hide() {\n    this._items.forEach(item => item.deactivateInkBar());\n  }\n\n  /** Aligns the ink bar to a DOM node. */\n  alignToElement(element: HTMLElement) {\n    const correspondingItem = this._items.find(item => item.elementRef.nativeElement === element);\n    const currentItem = this._currentItem;\n\n    if (correspondingItem === currentItem) {\n      return;\n    }\n\n    currentItem?.deactivateInkBar();\n\n    if (correspondingItem) {\n      const clientRect = currentItem?.elementRef.nativeElement.getBoundingClientRect?.();\n\n      // The ink bar won't animate unless we give it the `ClientRect` of the previous item.\n      correspondingItem.activateInkBar(clientRect);\n      this._currentItem = correspondingItem;\n    }\n  }\n}\n\n/**\n * Mixin that can be used to apply the `MatInkBarItem` behavior to a class.\n * Base on MDC's `MDCSlidingTabIndicatorFoundation`:\n * https://github.com/material-components/material-components-web/blob/c0a11ef0d000a098fd0c372be8f12d6a99302855/packages/mdc-tab-indicator/sliding-foundation.ts\n * @docs-private\n */\nexport function mixinInkBarItem<\n  T extends new (...args: any[]) => {elementRef: ElementRef<HTMLElement>},\n>(base: T): T & (new (...args: any[]) => MatInkBarItem) {\n  return class extends base {\n    constructor(...args: any[]) {\n      super(...args);\n    }\n\n    private _inkBarElement: HTMLElement | null;\n    private _inkBarContentElement: HTMLElement | null;\n    private _fitToContent = false;\n\n    /** Whether the ink bar should fit to the entire tab or just its content. */\n    get fitInkBarToContent(): boolean {\n      return this._fitToContent;\n    }\n    set fitInkBarToContent(v: BooleanInput) {\n      const newValue = coerceBooleanProperty(v);\n\n      if (this._fitToContent !== newValue) {\n        this._fitToContent = newValue;\n\n        if (this._inkBarElement) {\n          this._appendInkBarElement();\n        }\n      }\n    }\n\n    /** Aligns the ink bar to the current item. */\n    activateInkBar(previousIndicatorClientRect?: ClientRect) {\n      const element = this.elementRef.nativeElement;\n\n      // Early exit if no indicator is present to handle cases where an indicator\n      // may be activated without a prior indicator state\n      if (\n        !previousIndicatorClientRect ||\n        !element.getBoundingClientRect ||\n        !this._inkBarContentElement\n      ) {\n        element.classList.add(ACTIVE_CLASS);\n        return;\n      }\n\n      // This animation uses the FLIP approach. You can read more about it at the link below:\n      // https://aerotwist.com/blog/flip-your-animations/\n\n      // Calculate the dimensions based on the dimensions of the previous indicator\n      const currentClientRect = element.getBoundingClientRect();\n      const widthDelta = previousIndicatorClientRect.width / currentClientRect.width;\n      const xPosition = previousIndicatorClientRect.left - currentClientRect.left;\n      element.classList.add(NO_TRANSITION_CLASS);\n      this._inkBarContentElement.style.setProperty(\n        'transform',\n        `translateX(${xPosition}px) scaleX(${widthDelta})`,\n      );\n\n      // Force repaint before updating classes and transform to ensure the transform properly takes effect\n      element.getBoundingClientRect();\n\n      element.classList.remove(NO_TRANSITION_CLASS);\n      element.classList.add(ACTIVE_CLASS);\n      this._inkBarContentElement.style.setProperty('transform', '');\n    }\n\n    /** Removes the ink bar from the current item. */\n    deactivateInkBar() {\n      this.elementRef.nativeElement.classList.remove(ACTIVE_CLASS);\n    }\n\n    /** Initializes the foundation. */\n    ngOnInit() {\n      this._createInkBarElement();\n    }\n\n    /** Destroys the foundation. */\n    ngOnDestroy() {\n      this._inkBarElement?.remove();\n      this._inkBarElement = this._inkBarContentElement = null!;\n    }\n\n    /** Creates and appends the ink bar element. */\n    private _createInkBarElement() {\n      const documentNode = this.elementRef.nativeElement.ownerDocument || document;\n      this._inkBarElement = documentNode.createElement('span');\n      this._inkBarContentElement = documentNode.createElement('span');\n\n      this._inkBarElement.className = 'mdc-tab-indicator';\n      this._inkBarContentElement.className =\n        'mdc-tab-indicator__content mdc-tab-indicator__content--underline';\n\n      this._inkBarElement.appendChild(this._inkBarContentElement);\n      this._appendInkBarElement();\n    }\n\n    /**\n     * Appends the ink bar to the tab host element or content, depending on whether\n     * the ink bar should fit to content.\n     */\n    private _appendInkBarElement() {\n      if (!this._inkBarElement && (typeof ngDevMode === 'undefined' || ngDevMode)) {\n        throw Error('Ink bar element has not been created and cannot be appended');\n      }\n\n      const parentElement = this._fitToContent\n        ? this.elementRef.nativeElement.querySelector('.mdc-tab__content')\n        : this.elementRef.nativeElement;\n\n      if (!parentElement && (typeof ngDevMode === 'undefined' || ngDevMode)) {\n        throw Error('Missing element to host the ink bar');\n      }\n\n      parentElement!.appendChild(this._inkBarElement!);\n    }\n  };\n}\n\n/**\n * Interface for a MatInkBar positioner method, defining the positioning and width of the ink\n * bar in a set of tabs.\n */\nexport interface _MatInkBarPositioner {\n  (element: HTMLElement): {left: string; width: string};\n}\n\n/**\n * The default positioner function for the MatInkBar.\n * @docs-private\n */\nexport function _MAT_INK_BAR_POSITIONER_FACTORY(): _MatInkBarPositioner {\n  const method = (element: HTMLElement) => ({\n    left: element ? (element.offsetLeft || 0) + 'px' : '0',\n    width: element ? (element.offsetWidth || 0) + 'px' : '0',\n  });\n\n  return method;\n}\n\n/** Injection token for the MatInkBar's Positioner. */\nexport const _MAT_INK_BAR_POSITIONER = new InjectionToken<_MatInkBarPositioner>(\n  'MatInkBarPositioner',\n  {\n    providedIn: 'root',\n    factory: _MAT_INK_BAR_POSITIONER_FACTORY,\n  },\n);\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {Directive, ElementRef} from '@angular/core';\nimport {mixinInkBarItem} from './ink-bar';\nimport {CanDisable, mixinDisabled} from '@angular/material/core';\n\n// Boilerplate for applying mixins to MatTabLabelWrapper.\n/** @docs-private */\nconst _MatTabLabelWrapperMixinBase = mixinInkBarItem(\n  mixinDisabled(\n    class {\n      elementRef: ElementRef;\n    },\n  ),\n);\n\n/**\n * Used in the `mat-tab-group` view to display tab labels.\n * @docs-private\n */\n@Directive({\n  selector: '[matTabLabelWrapper]',\n  inputs: ['disabled', 'fitInkBarToContent'],\n  host: {\n    '[class.mat-mdc-tab-disabled]': 'disabled',\n    '[attr.aria-disabled]': '!!disabled',\n  },\n})\nexport class MatTabLabelWrapper extends _MatTabLabelWrapperMixinBase implements CanDisable {\n  constructor(override elementRef: ElementRef) {\n    super();\n  }\n\n  /** Sets focus on the wrapper element */\n  focus(): void {\n    this.elementRef.nativeElement.focus();\n  }\n\n  getOffsetLeft(): number {\n    return this.elementRef.nativeElement.offsetLeft;\n  }\n\n  getOffsetWidth(): number {\n    return this.elementRef.nativeElement.offsetWidth;\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {ListKeyManager, ListKeyManagerOption} from './list-key-manager';\nimport {FocusOrigin} from '../focus-monitor/focus-monitor';\n\n/**\n * This is the interface for focusable items (used by the FocusKeyManager).\n * Each item must know how to focus itself, whether or not it is currently disabled\n * and be able to supply its label.\n */\nexport interface FocusableOption extends ListKeyManagerOption {\n  /** Focuses the `FocusableOption`. */\n  focus(origin?: FocusOrigin): void;\n}\n\nexport class FocusKeyManager<T> extends ListKeyManager<FocusableOption & T> {\n  private _origin: FocusOrigin = 'program';\n\n  /**\n   * Sets the focus origin that will be passed in to the items for any subsequent `focus` calls.\n   * @param origin Focus origin to be used when focusing items.\n   */\n  setFocusOrigin(origin: FocusOrigin): this {\n    this._origin = origin;\n    return this;\n  }\n\n  /**\n   * Sets the active item to the item at the specified\n   * index and focuses the newly active item.\n   * @param index Index of the item to be set as active.\n   */\n  override setActiveItem(index: number): void;\n\n  /**\n   * Sets the active item to the item that is specified and focuses it.\n   * @param item Item to be set as active.\n   */\n  override setActiveItem(item: T): void;\n\n  override setActiveItem(item: any): void {\n    super.setActiveItem(item);\n\n    if (this.activeItem) {\n      this.activeItem.focus(this._origin);\n    }\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {\n  ChangeDetectorRef,\n  ElementRef,\n  NgZone,\n  Optional,\n  QueryList,\n  EventEmitter,\n  AfterContentChecked,\n  AfterContentInit,\n  AfterViewInit,\n  OnDestroy,\n  Directive,\n  Inject,\n  Input,\n} from '@angular/core';\nimport {Direction, Directionality} from '@angular/cdk/bidi';\nimport {\n  BooleanInput,\n  coerceBooleanProperty,\n  coerceNumberProperty,\n  NumberInput,\n} from '@angular/cdk/coercion';\nimport {ViewportRuler} from '@angular/cdk/scrolling';\nimport {FocusKeyManager, FocusableOption} from '@angular/cdk/a11y';\nimport {ENTER, SPACE, hasModifierKey} from '@angular/cdk/keycodes';\nimport {\n  merge,\n  of as observableOf,\n  Subject,\n  EMPTY,\n  Observer,\n  Observable,\n  timer,\n  fromEvent,\n} from 'rxjs';\nimport {take, switchMap, startWith, skip, takeUntil, filter} from 'rxjs/operators';\nimport {Platform, normalizePassiveListenerOptions} from '@angular/cdk/platform';\nimport {ANIMATION_MODULE_TYPE} from '@angular/platform-browser/animations';\n\n/** Config used to bind passive event listeners */\nconst passiveEventListenerOptions = normalizePassiveListenerOptions({\n  passive: true,\n}) as EventListenerOptions;\n\n/**\n * The directions that scrolling can go in when the header's tabs exceed the header width. 'After'\n * will scroll the header towards the end of the tabs list and 'before' will scroll towards the\n * beginning of the list.\n */\nexport type ScrollDirection = 'after' | 'before';\n\n/**\n * Amount of milliseconds to wait before starting to scroll the header automatically.\n * Set a little conservatively in order to handle fake events dispatched on touch devices.\n */\nconst HEADER_SCROLL_DELAY = 650;\n\n/**\n * Interval in milliseconds at which to scroll the header\n * while the user is holding their pointer.\n */\nconst HEADER_SCROLL_INTERVAL = 100;\n\n/** Item inside a paginated tab header. */\nexport type MatPaginatedTabHeaderItem = FocusableOption & {elementRef: ElementRef};\n\n/**\n * Base class for a tab header that supported pagination.\n * @docs-private\n */\n@Directive()\nexport abstract class MatPaginatedTabHeader\n  implements AfterContentChecked, AfterContentInit, AfterViewInit, OnDestroy\n{\n  abstract _items: QueryList<MatPaginatedTabHeaderItem>;\n  abstract _inkBar: {hide: () => void; alignToElement: (element: HTMLElement) => void};\n  abstract _tabListContainer: ElementRef<HTMLElement>;\n  abstract _tabList: ElementRef<HTMLElement>;\n  abstract _tabListInner: ElementRef<HTMLElement>;\n  abstract _nextPaginator: ElementRef<HTMLElement>;\n  abstract _previousPaginator: ElementRef<HTMLElement>;\n\n  /** The distance in pixels that the tab labels should be translated to the left. */\n  private _scrollDistance = 0;\n\n  /** Whether the header should scroll to the selected index after the view has been checked. */\n  private _selectedIndexChanged = false;\n\n  /** Emits when the component is destroyed. */\n  protected readonly _destroyed = new Subject<void>();\n\n  /** Whether the controls for pagination should be displayed */\n  _showPaginationControls = false;\n\n  /** Whether the tab list can be scrolled more towards the end of the tab label list. */\n  _disableScrollAfter = true;\n\n  /** Whether the tab list can be scrolled more towards the beginning of the tab label list. */\n  _disableScrollBefore = true;\n\n  /**\n   * The number of tab labels that are displayed on the header. When this changes, the header\n   * should re-evaluate the scroll position.\n   */\n  private _tabLabelCount: number;\n\n  /** Whether the scroll distance has changed and should be applied after the view is checked. */\n  private _scrollDistanceChanged: boolean;\n\n  /** Used to manage focus between the tabs. */\n  private _keyManager: FocusKeyManager<MatPaginatedTabHeaderItem>;\n\n  /** Cached text content of the header. */\n  private _currentTextContent: string;\n\n  /** Stream that will stop the automated scrolling. */\n  private _stopScrolling = new Subject<void>();\n\n  /**\n   * Whether pagination should be disabled. This can be used to avoid unnecessary\n   * layout recalculations if it's known that pagination won't be required.\n   */\n  @Input()\n  get disablePagination(): boolean {\n    return this._disablePagination;\n  }\n  set disablePagination(value: BooleanInput) {\n    this._disablePagination = coerceBooleanProperty(value);\n  }\n  private _disablePagination: boolean = false;\n\n  /** The index of the active tab. */\n  get selectedIndex(): number {\n    return this._selectedIndex;\n  }\n  set selectedIndex(value: NumberInput) {\n    value = coerceNumberProperty(value);\n\n    if (this._selectedIndex != value) {\n      this._selectedIndexChanged = true;\n      this._selectedIndex = value;\n\n      if (this._keyManager) {\n        this._keyManager.updateActiveItem(value);\n      }\n    }\n  }\n  private _selectedIndex: number = 0;\n\n  /** Event emitted when the option is selected. */\n  readonly selectFocusedIndex: EventEmitter<number> = new EventEmitter<number>();\n\n  /** Event emitted when a label is focused. */\n  readonly indexFocused: EventEmitter<number> = new EventEmitter<number>();\n\n  constructor(\n    protected _elementRef: ElementRef<HTMLElement>,\n    protected _changeDetectorRef: ChangeDetectorRef,\n    private _viewportRuler: ViewportRuler,\n    @Optional() private _dir: Directionality,\n    private _ngZone: NgZone,\n    private _platform: Platform,\n    @Optional() @Inject(ANIMATION_MODULE_TYPE) public _animationMode?: string,\n  ) {\n    // Bind the `mouseleave` event on the outside since it doesn't change anything in the view.\n    _ngZone.runOutsideAngular(() => {\n      fromEvent(_elementRef.nativeElement, 'mouseleave')\n        .pipe(takeUntil(this._destroyed))\n        .subscribe(() => {\n          this._stopInterval();\n        });\n    });\n  }\n\n  /** Called when the user has selected an item via the keyboard. */\n  protected abstract _itemSelected(event: KeyboardEvent): void;\n\n  ngAfterViewInit() {\n    // We need to handle these events manually, because we want to bind passive event listeners.\n    fromEvent(this._previousPaginator.nativeElement, 'touchstart', passiveEventListenerOptions)\n      .pipe(takeUntil(this._destroyed))\n      .subscribe(() => {\n        this._handlePaginatorPress('before');\n      });\n\n    fromEvent(this._nextPaginator.nativeElement, 'touchstart', passiveEventListenerOptions)\n      .pipe(takeUntil(this._destroyed))\n      .subscribe(() => {\n        this._handlePaginatorPress('after');\n      });\n  }\n\n  ngAfterContentInit() {\n    const dirChange = this._dir ? this._dir.change : observableOf('ltr');\n    const resize = this._viewportRuler.change(150);\n    const realign = () => {\n      this.updatePagination();\n      this._alignInkBarToSelectedTab();\n    };\n\n    this._keyManager = new FocusKeyManager<MatPaginatedTabHeaderItem>(this._items)\n      .withHorizontalOrientation(this._getLayoutDirection())\n      .withHomeAndEnd()\n      .withWrap()\n      // Allow focus to land on disabled tabs, as per https://w3c.github.io/aria-practices/#kbd_disabled_controls\n      .skipPredicate(() => false);\n\n    this._keyManager.updateActiveItem(this._selectedIndex);\n\n    // Defer the first call in order to allow for slower browsers to lay out the elements.\n    // This helps in cases where the user lands directly on a page with paginated tabs.\n    // Note that we use `onStable` instead of `requestAnimationFrame`, because the latter\n    // can hold up tests that are in a background tab.\n    this._ngZone.onStable.pipe(take(1)).subscribe(realign);\n\n    // On dir change or window resize, realign the ink bar and update the orientation of\n    // the key manager if the direction has changed.\n    merge(dirChange, resize, this._items.changes, this._itemsResized())\n      .pipe(takeUntil(this._destroyed))\n      .subscribe(() => {\n        // We need to defer this to give the browser some time to recalculate\n        // the element dimensions. The call has to be wrapped in `NgZone.run`,\n        // because the viewport change handler runs outside of Angular.\n        this._ngZone.run(() => {\n          Promise.resolve().then(() => {\n            // Clamp the scroll distance, because it can change with the number of tabs.\n            this._scrollDistance = Math.max(\n              0,\n              Math.min(this._getMaxScrollDistance(), this._scrollDistance),\n            );\n            realign();\n          });\n        });\n        this._keyManager.withHorizontalOrientation(this._getLayoutDirection());\n      });\n\n    // If there is a change in the focus key manager we need to emit the `indexFocused`\n    // event in order to provide a public event that notifies about focus changes. Also we realign\n    // the tabs container by scrolling the new focused tab into the visible section.\n    this._keyManager.change.subscribe(newFocusIndex => {\n      this.indexFocused.emit(newFocusIndex);\n      this._setTabFocus(newFocusIndex);\n    });\n  }\n\n  /** Sends any changes that could affect the layout of the items. */\n  private _itemsResized(): Observable<ResizeObserverEntry[]> {\n    if (typeof ResizeObserver !== 'function') {\n      return EMPTY;\n    }\n\n    return this._items.changes.pipe(\n      startWith(this._items),\n      switchMap(\n        (tabItems: QueryList<MatPaginatedTabHeaderItem>) =>\n          new Observable((observer: Observer<ResizeObserverEntry[]>) =>\n            this._ngZone.runOutsideAngular(() => {\n              const resizeObserver = new ResizeObserver(entries => observer.next(entries));\n              tabItems.forEach(item => resizeObserver.observe(item.elementRef.nativeElement));\n              return () => {\n                resizeObserver.disconnect();\n              };\n            }),\n          ),\n      ),\n      // Skip the first emit since the resize observer emits when an item\n      // is observed for new items when the tab is already inserted\n      skip(1),\n      // Skip emissions where all the elements are invisible since we don't want\n      // the header to try and re-render with invalid measurements. See #25574.\n      filter(entries => entries.some(e => e.contentRect.width > 0 && e.contentRect.height > 0)),\n    );\n  }\n\n  ngAfterContentChecked(): void {\n    // If the number of tab labels have changed, check if scrolling should be enabled\n    if (this._tabLabelCount != this._items.length) {\n      this.updatePagination();\n      this._tabLabelCount = this._items.length;\n      this._changeDetectorRef.markForCheck();\n    }\n\n    // If the selected index has changed, scroll to the label and check if the scrolling controls\n    // should be disabled.\n    if (this._selectedIndexChanged) {\n      this._scrollToLabel(this._selectedIndex);\n      this._checkScrollingControls();\n      this._alignInkBarToSelectedTab();\n      this._selectedIndexChanged = false;\n      this._changeDetectorRef.markForCheck();\n    }\n\n    // If the scroll distance has been changed (tab selected, focused, scroll controls activated),\n    // then translate the header to reflect this.\n    if (this._scrollDistanceChanged) {\n      this._updateTabScrollPosition();\n      this._scrollDistanceChanged = false;\n      this._changeDetectorRef.markForCheck();\n    }\n  }\n\n  ngOnDestroy() {\n    this._keyManager?.destroy();\n    this._destroyed.next();\n    this._destroyed.complete();\n    this._stopScrolling.complete();\n  }\n\n  /** Handles keyboard events on the header. */\n  _handleKeydown(event: KeyboardEvent) {\n    // We don't handle any key bindings with a modifier key.\n    if (hasModifierKey(event)) {\n      return;\n    }\n\n    switch (event.keyCode) {\n      case ENTER:\n      case SPACE:\n        if (this.focusIndex !== this.selectedIndex) {\n          const item = this._items.get(this.focusIndex);\n\n          if (item && !item.disabled) {\n            this.selectFocusedIndex.emit(this.focusIndex);\n            this._itemSelected(event);\n          }\n        }\n        break;\n      default:\n        this._keyManager.onKeydown(event);\n    }\n  }\n\n  /**\n   * Callback for when the MutationObserver detects that the content has changed.\n   */\n  _onContentChanges() {\n    const textContent = this._elementRef.nativeElement.textContent;\n\n    // We need to diff the text content of the header, because the MutationObserver callback\n    // will fire even if the text content didn't change which is inefficient and is prone\n    // to infinite loops if a poorly constructed expression is passed in (see #14249).\n    if (textContent !== this._currentTextContent) {\n      this._currentTextContent = textContent || '';\n\n      // The content observer runs outside the `NgZone` by default, which\n      // means that we need to bring the callback back in ourselves.\n      this._ngZone.run(() => {\n        this.updatePagination();\n        this._alignInkBarToSelectedTab();\n        this._changeDetectorRef.markForCheck();\n      });\n    }\n  }\n\n  /**\n   * Updates the view whether pagination should be enabled or not.\n   *\n   * WARNING: Calling this method can be very costly in terms of performance. It should be called\n   * as infrequently as possible from outside of the Tabs component as it causes a reflow of the\n   * page.\n   */\n  updatePagination() {\n    this._checkPaginationEnabled();\n    this._checkScrollingControls();\n    this._updateTabScrollPosition();\n  }\n\n  /** Tracks which element has focus; used for keyboard navigation */\n  get focusIndex(): number {\n    return this._keyManager ? this._keyManager.activeItemIndex! : 0;\n  }\n\n  /** When the focus index is set, we must manually send focus to the correct label */\n  set focusIndex(value: number) {\n    if (!this._isValidIndex(value) || this.focusIndex === value || !this._keyManager) {\n      return;\n    }\n\n    this._keyManager.setActiveItem(value);\n  }\n\n  /**\n   * Determines if an index is valid.  If the tabs are not ready yet, we assume that the user is\n   * providing a valid index and return true.\n   */\n  _isValidIndex(index: number): boolean {\n    return this._items ? !!this._items.toArray()[index] : true;\n  }\n\n  /**\n   * Sets focus on the HTML element for the label wrapper and scrolls it into the view if\n   * scrolling is enabled.\n   */\n  _setTabFocus(tabIndex: number) {\n    if (this._showPaginationControls) {\n      this._scrollToLabel(tabIndex);\n    }\n\n    if (this._items && this._items.length) {\n      this._items.toArray()[tabIndex].focus();\n\n      // Do not let the browser manage scrolling to focus the element, this will be handled\n      // by using translation. In LTR, the scroll left should be 0. In RTL, the scroll width\n      // should be the full width minus the offset width.\n      const containerEl = this._tabListContainer.nativeElement;\n      const dir = this._getLayoutDirection();\n\n      if (dir == 'ltr') {\n        containerEl.scrollLeft = 0;\n      } else {\n        containerEl.scrollLeft = containerEl.scrollWidth - containerEl.offsetWidth;\n      }\n    }\n  }\n\n  /** The layout direction of the containing app. */\n  _getLayoutDirection(): Direction {\n    return this._dir && this._dir.value === 'rtl' ? 'rtl' : 'ltr';\n  }\n\n  /** Performs the CSS transformation on the tab list that will cause the list to scroll. */\n  _updateTabScrollPosition() {\n    if (this.disablePagination) {\n      return;\n    }\n\n    const scrollDistance = this.scrollDistance;\n    const translateX = this._getLayoutDirection() === 'ltr' ? -scrollDistance : scrollDistance;\n\n    // Don't use `translate3d` here because we don't want to create a new layer. A new layer\n    // seems to cause flickering and overflow in Internet Explorer. For example, the ink bar\n    // and ripples will exceed the boundaries of the visible tab bar.\n    // See: https://github.com/angular/components/issues/10276\n    // We round the `transform` here, because transforms with sub-pixel precision cause some\n    // browsers to blur the content of the element.\n    this._tabList.nativeElement.style.transform = `translateX(${Math.round(translateX)}px)`;\n\n    // Setting the `transform` on IE will change the scroll offset of the parent, causing the\n    // position to be thrown off in some cases. We have to reset it ourselves to ensure that\n    // it doesn't get thrown off. Note that we scope it only to IE and Edge, because messing\n    // with the scroll position throws off Chrome 71+ in RTL mode (see #14689).\n    if (this._platform.TRIDENT || this._platform.EDGE) {\n      this._tabListContainer.nativeElement.scrollLeft = 0;\n    }\n  }\n\n  /** Sets the distance in pixels that the tab header should be transformed in the X-axis. */\n  get scrollDistance(): number {\n    return this._scrollDistance;\n  }\n  set scrollDistance(value: number) {\n    this._scrollTo(value);\n  }\n\n  /**\n   * Moves the tab list in the 'before' or 'after' direction (towards the beginning of the list or\n   * the end of the list, respectively). The distance to scroll is computed to be a third of the\n   * length of the tab list view window.\n   *\n   * This is an expensive call that forces a layout reflow to compute box and scroll metrics and\n   * should be called sparingly.\n   */\n  _scrollHeader(direction: ScrollDirection) {\n    const viewLength = this._tabListContainer.nativeElement.offsetWidth;\n\n    // Move the scroll distance one-third the length of the tab list's viewport.\n    const scrollAmount = ((direction == 'before' ? -1 : 1) * viewLength) / 3;\n\n    return this._scrollTo(this._scrollDistance + scrollAmount);\n  }\n\n  /** Handles click events on the pagination arrows. */\n  _handlePaginatorClick(direction: ScrollDirection) {\n    this._stopInterval();\n    this._scrollHeader(direction);\n  }\n\n  /**\n   * Moves the tab list such that the desired tab label (marked by index) is moved into view.\n   *\n   * This is an expensive call that forces a layout reflow to compute box and scroll metrics and\n   * should be called sparingly.\n   */\n  _scrollToLabel(labelIndex: number) {\n    if (this.disablePagination) {\n      return;\n    }\n\n    const selectedLabel = this._items ? this._items.toArray()[labelIndex] : null;\n\n    if (!selectedLabel) {\n      return;\n    }\n\n    // The view length is the visible width of the tab labels.\n    const viewLength = this._tabListContainer.nativeElement.offsetWidth;\n    const {offsetLeft, offsetWidth} = selectedLabel.elementRef.nativeElement;\n\n    let labelBeforePos: number, labelAfterPos: number;\n    if (this._getLayoutDirection() == 'ltr') {\n      labelBeforePos = offsetLeft;\n      labelAfterPos = labelBeforePos + offsetWidth;\n    } else {\n      labelAfterPos = this._tabListInner.nativeElement.offsetWidth - offsetLeft;\n      labelBeforePos = labelAfterPos - offsetWidth;\n    }\n\n    const beforeVisiblePos = this.scrollDistance;\n    const afterVisiblePos = this.scrollDistance + viewLength;\n\n    if (labelBeforePos < beforeVisiblePos) {\n      // Scroll header to move label to the before direction\n      this.scrollDistance -= beforeVisiblePos - labelBeforePos;\n    } else if (labelAfterPos > afterVisiblePos) {\n      // Scroll header to move label to the after direction\n      this.scrollDistance += Math.min(\n        labelAfterPos - afterVisiblePos,\n        labelBeforePos - beforeVisiblePos,\n      );\n    }\n  }\n\n  /**\n   * Evaluate whether the pagination controls should be displayed. If the scroll width of the\n   * tab list is wider than the size of the header container, then the pagination controls should\n   * be shown.\n   *\n   * This is an expensive call that forces a layout reflow to compute box and scroll metrics and\n   * should be called sparingly.\n   */\n  _checkPaginationEnabled() {\n    if (this.disablePagination) {\n      this._showPaginationControls = false;\n    } else {\n      const isEnabled =\n        this._tabListInner.nativeElement.scrollWidth > this._elementRef.nativeElement.offsetWidth;\n\n      if (!isEnabled) {\n        this.scrollDistance = 0;\n      }\n\n      if (isEnabled !== this._showPaginationControls) {\n        this._changeDetectorRef.markForCheck();\n      }\n\n      this._showPaginationControls = isEnabled;\n    }\n  }\n\n  /**\n   * Evaluate whether the before and after controls should be enabled or disabled.\n   * If the header is at the beginning of the list (scroll distance is equal to 0) then disable the\n   * before button. If the header is at the end of the list (scroll distance is equal to the\n   * maximum distance we can scroll), then disable the after button.\n   *\n   * This is an expensive call that forces a layout reflow to compute box and scroll metrics and\n   * should be called sparingly.\n   */\n  _checkScrollingControls() {\n    if (this.disablePagination) {\n      this._disableScrollAfter = this._disableScrollBefore = true;\n    } else {\n      // Check if the pagination arrows should be activated.\n      this._disableScrollBefore = this.scrollDistance == 0;\n      this._disableScrollAfter = this.scrollDistance == this._getMaxScrollDistance();\n      this._changeDetectorRef.markForCheck();\n    }\n  }\n\n  /**\n   * Determines what is the maximum length in pixels that can be set for the scroll distance. This\n   * is equal to the difference in width between the tab list container and tab header container.\n   *\n   * This is an expensive call that forces a layout reflow to compute box and scroll metrics and\n   * should be called sparingly.\n   */\n  _getMaxScrollDistance(): number {\n    const lengthOfTabList = this._tabListInner.nativeElement.scrollWidth;\n    const viewLength = this._tabListContainer.nativeElement.offsetWidth;\n    return lengthOfTabList - viewLength || 0;\n  }\n\n  /** Tells the ink-bar to align itself to the current label wrapper */\n  _alignInkBarToSelectedTab(): void {\n    const selectedItem =\n      this._items && this._items.length ? this._items.toArray()[this.selectedIndex] : null;\n    const selectedLabelWrapper = selectedItem ? selectedItem.elementRef.nativeElement : null;\n\n    if (selectedLabelWrapper) {\n      this._inkBar.alignToElement(selectedLabelWrapper);\n    } else {\n      this._inkBar.hide();\n    }\n  }\n\n  /** Stops the currently-running paginator interval.  */\n  _stopInterval() {\n    this._stopScrolling.next();\n  }\n\n  /**\n   * Handles the user pressing down on one of the paginators.\n   * Starts scrolling the header after a certain amount of time.\n   * @param direction In which direction the paginator should be scrolled.\n   */\n  _handlePaginatorPress(direction: ScrollDirection, mouseEvent?: MouseEvent) {\n    // Don't start auto scrolling for right mouse button clicks. Note that we shouldn't have to\n    // null check the `button`, but we do it so we don't break tests that use fake events.\n    if (mouseEvent && mouseEvent.button != null && mouseEvent.button !== 0) {\n      return;\n    }\n\n    // Avoid overlapping timers.\n    this._stopInterval();\n\n    // Start a timer after the delay and keep firing based on the interval.\n    timer(HEADER_SCROLL_DELAY, HEADER_SCROLL_INTERVAL)\n      // Keep the timer going until something tells it to stop or the component is destroyed.\n      .pipe(takeUntil(merge(this._stopScrolling, this._destroyed)))\n      .subscribe(() => {\n        const {maxScrollDistance, distance} = this._scrollHeader(direction);\n\n        // Stop the timer if we've reached the start or the end.\n        if (distance === 0 || distance >= maxScrollDistance) {\n          this._stopInterval();\n        }\n      });\n  }\n\n  /**\n   * Scrolls the header to a given position.\n   * @param position Position to which to scroll.\n   * @returns Information on the current scroll distance and the maximum.\n   */\n  private _scrollTo(position: number) {\n    if (this.disablePagination) {\n      return {maxScrollDistance: 0, distance: 0};\n    }\n\n    const maxScrollDistance = this._getMaxScrollDistance();\n    this._scrollDistance = Math.max(0, Math.min(maxScrollDistance, position));\n\n    // Mark that the scroll distance has changed so that after the view is checked, the CSS\n    // transformation can move the header.\n    this._scrollDistanceChanged = true;\n    this._checkScrollingControls();\n\n    return {maxScrollDistance, distance: this._scrollDistance};\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {\n  AfterContentChecked,\n  AfterContentInit,\n  AfterViewInit,\n  ChangeDetectionStrategy,\n  ChangeDetectorRef,\n  Component,\n  ContentChildren,\n  ElementRef,\n  Inject,\n  Input,\n  NgZone,\n  OnDestroy,\n  Optional,\n  QueryList,\n  ViewChild,\n  ViewEncapsulation,\n} from '@angular/core';\nimport {ViewportRuler} from '@angular/cdk/scrolling';\nimport {Platform} from '@angular/cdk/platform';\nimport {Directionality} from '@angular/cdk/bidi';\nimport {ANIMATION_MODULE_TYPE} from '@angular/platform-browser/animations';\nimport {MatTabLabelWrapper} from './tab-label-wrapper';\nimport {MatInkBar} from './ink-bar';\nimport {MatPaginatedTabHeader} from './paginated-tab-header';\nimport {BooleanInput, coerceBooleanProperty} from '@angular/cdk/coercion';\n\n/**\n * The header of the tab group which displays a list of all the tabs in the tab group. Includes\n * an ink bar that follows the currently selected tab. When the tabs list's width exceeds the\n * width of the header container, then arrows will be displayed to allow the user to scroll\n * left and right across the header.\n * @docs-private\n */\n@Component({\n  selector: 'mat-tab-header',\n  templateUrl: 'tab-header.html',\n  styleUrls: ['tab-header.css'],\n  inputs: ['selectedIndex'],\n  outputs: ['selectFocusedIndex', 'indexFocused'],\n  encapsulation: ViewEncapsulation.None,\n  // tslint:disable-next-line:validate-decorators\n  changeDetection: ChangeDetectionStrategy.Default,\n  host: {\n    'class': 'mat-mdc-tab-header',\n    '[class.mat-mdc-tab-header-pagination-controls-enabled]': '_showPaginationControls',\n    '[class.mat-mdc-tab-header-rtl]': \"_getLayoutDirection() == 'rtl'\",\n  },\n})\nexport class MatTabHeader\n  extends MatPaginatedTabHeader\n  implements AfterContentChecked, AfterContentInit, AfterViewInit, OnDestroy\n{\n  @ContentChildren(MatTabLabelWrapper, {descendants: false}) _items: QueryList<MatTabLabelWrapper>;\n  @ViewChild('tabListContainer', {static: true}) _tabListContainer: ElementRef;\n  @ViewChild('tabList', {static: true}) _tabList: ElementRef;\n  @ViewChild('tabListInner', {static: true}) _tabListInner: ElementRef;\n  @ViewChild('nextPaginator') _nextPaginator: ElementRef<HTMLElement>;\n  @ViewChild('previousPaginator') _previousPaginator: ElementRef<HTMLElement>;\n  _inkBar: MatInkBar;\n\n  /** Whether the ripple effect is disabled or not. */\n  @Input()\n  get disableRipple(): boolean {\n    return this._disableRipple;\n  }\n\n  set disableRipple(value: BooleanInput) {\n    this._disableRipple = coerceBooleanProperty(value);\n  }\n\n  private _disableRipple: boolean = false;\n\n  constructor(\n    elementRef: ElementRef,\n    changeDetectorRef: ChangeDetectorRef,\n    viewportRuler: ViewportRuler,\n    @Optional() dir: Directionality,\n    ngZone: NgZone,\n    platform: Platform,\n    @Optional() @Inject(ANIMATION_MODULE_TYPE) animationMode?: string,\n  ) {\n    super(elementRef, changeDetectorRef, viewportRuler, dir, ngZone, platform, animationMode);\n  }\n\n  override ngAfterContentInit() {\n    this._inkBar = new MatInkBar(this._items);\n    super.ngAfterContentInit();\n  }\n\n  protected _itemSelected(event: KeyboardEvent) {\n    event.preventDefault();\n  }\n}\n","<!-- TODO: this also had `mat-elevation-z4`. Figure out what we should do with it. -->\n<button class=\"mat-mdc-tab-header-pagination mat-mdc-tab-header-pagination-before\"\n     #previousPaginator\n     aria-hidden=\"true\"\n     type=\"button\"\n     mat-ripple\n     tabindex=\"-1\"\n     [matRippleDisabled]=\"_disableScrollBefore || disableRipple\"\n     [class.mat-mdc-tab-header-pagination-disabled]=\"_disableScrollBefore\"\n     [disabled]=\"_disableScrollBefore || null\"\n     (click)=\"_handlePaginatorClick('before')\"\n     (mousedown)=\"_handlePaginatorPress('before', $event)\"\n     (touchend)=\"_stopInterval()\">\n  <div class=\"mat-mdc-tab-header-pagination-chevron\"></div>\n</button>\n\n<div\n  class=\"mat-mdc-tab-label-container\"\n  #tabListContainer\n  (keydown)=\"_handleKeydown($event)\"\n  [class._mat-animation-noopable]=\"_animationMode === 'NoopAnimations'\">\n  <div\n    #tabList\n    class=\"mat-mdc-tab-list\"\n    role=\"tablist\"\n    (cdkObserveContent)=\"_onContentChanges()\">\n    <div class=\"mat-mdc-tab-labels\" #tabListInner>\n      <ng-content></ng-content>\n    </div>\n  </div>\n</div>\n\n<!-- TODO: this also had `mat-elevation-z4`. Figure out what we should do with it. -->\n<button class=\"mat-mdc-tab-header-pagination mat-mdc-tab-header-pagination-after\"\n     #nextPaginator\n     aria-hidden=\"true\"\n     type=\"button\"\n     mat-ripple\n     [matRippleDisabled]=\"_disableScrollAfter || disableRipple\"\n     [class.mat-mdc-tab-header-pagination-disabled]=\"_disableScrollAfter\"\n     [disabled]=\"_disableScrollAfter || null\"\n     tabindex=\"-1\"\n     (mousedown)=\"_handlePaginatorPress('after', $event)\"\n     (click)=\"_handlePaginatorClick('after')\"\n     (touchend)=\"_stopInterval()\">\n  <div class=\"mat-mdc-tab-header-pagination-chevron\"></div>\n</button>\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {\n  AfterContentChecked,\n  AfterContentInit,\n  ChangeDetectionStrategy,\n  ChangeDetectorRef,\n  Component,\n  ContentChildren,\n  ElementRef,\n  EventEmitter,\n  Inject,\n  Input,\n  OnDestroy,\n  Optional,\n  Output,\n  QueryList,\n  ViewChild,\n  ViewEncapsulation,\n} from '@angular/core';\nimport {ANIMATION_MODULE_TYPE} from '@angular/platform-browser/animations';\nimport {MAT_TAB_GROUP, MatTab} from './tab';\nimport {MatTabHeader} from './tab-header';\nimport {\n  BooleanInput,\n  coerceBooleanProperty,\n  coerceNumberProperty,\n  NumberInput,\n} from '@angular/cdk/coercion';\nimport {\n  CanColor,\n  CanDisableRipple,\n  mixinColor,\n  mixinDisableRipple,\n  ThemePalette,\n} from '@angular/material/core';\nimport {merge, Subscription} from 'rxjs';\nimport {MAT_TABS_CONFIG, MatTabsConfig} from './tab-config';\nimport {startWith} from 'rxjs/operators';\nimport {FocusOrigin} from '@angular/cdk/a11y';\n\n/** Used to generate unique ID's for each tab component */\nlet nextId = 0;\n\n// Boilerplate for applying mixins to MatTabGroup.\n/** @docs-private */\nconst _MatTabGroupMixinBase = mixinColor(\n  mixinDisableRipple(\n    class {\n      constructor(public _elementRef: ElementRef) {}\n    },\n  ),\n  'primary',\n);\n\n/** @docs-private */\nexport interface MatTabGroupBaseHeader {\n  _alignInkBarToSelectedTab(): void;\n  updatePagination(): void;\n  focusIndex: number;\n}\n\n/** Possible positions for the tab header. */\nexport type MatTabHeaderPosition = 'above' | 'below';\n\n/**\n * Material design tab-group component. Supports basic tab pairs (label + content) and includes\n * animated ink-bar, keyboard navigation, and screen reader.\n * See: https://material.io/design/components/tabs.html\n */\n@Component({\n  selector: 'mat-tab-group',\n  exportAs: 'matTabGroup',\n  templateUrl: 'tab-group.html',\n  styleUrls: ['tab-group.css'],\n  encapsulation: ViewEncapsulation.None,\n  // tslint:disable-next-line:validate-decorators\n  changeDetection: ChangeDetectionStrategy.Default,\n  inputs: ['color', 'disableRipple'],\n  providers: [\n    {\n      provide: MAT_TAB_GROUP,\n      useExisting: MatTabGroup,\n    },\n  ],\n  host: {\n    'ngSkipHydration': '',\n    'class': 'mat-mdc-tab-group',\n    '[class.mat-mdc-tab-group-dynamic-height]': 'dynamicHeight',\n    '[class.mat-mdc-tab-group-inverted-header]': 'headerPosition === \"below\"',\n    '[class.mat-mdc-tab-group-stretch-tabs]': 'stretchTabs',\n    '[style.--mat-tab-animation-duration]': 'animationDuration',\n  },\n})\nexport class MatTabGroup\n  extends _MatTabGroupMixinBase\n  implements AfterContentInit, AfterContentChecked, OnDestroy, CanColor, CanDisableRipple\n{\n  /**\n   * All tabs inside the tab group. This includes tabs that belong to groups that are nested\n   * inside the current one. We filter out only the tabs that belong to this group in `_tabs`.\n   */\n  @ContentChildren(MatTab, {descendants: true}) _allTabs: QueryList<MatTab>;\n  @ViewChild('tabBodyWrapper') _tabBodyWrapper: ElementRef;\n  @ViewChild('tabHeader') _tabHeader: MatTabHeader;\n\n  /** All of the tabs that belong to the group. */\n  _tabs: QueryList<MatTab> = new QueryList<MatTab>();\n\n  /** The tab index that should be selected after the content has been checked. */\n  private _indexToSelect: number | null = 0;\n\n  /** Index of the tab that was focused last. */\n  private _lastFocusedTabIndex: number | null = null;\n\n  /** Snapshot of the height of the tab body wrapper before another tab is activated. */\n  private _tabBodyWrapperHeight: number = 0;\n\n  /** Subscription to tabs being added/removed. */\n  private _tabsSubscription = Subscription.EMPTY;\n\n  /** Subscription to changes in the tab labels. */\n  private _tabLabelSubscription = Subscription.EMPTY;\n\n  /** Whether the ink bar should fit its width to the size of the tab label content. */\n  @Input()\n  get fitInkBarToContent(): boolean {\n    return this._fitInkBarToContent;\n  }\n  set fitInkBarToContent(v: BooleanInput) {\n    this._fitInkBarToContent = coerceBooleanProperty(v);\n    this._changeDetectorRef.markForCheck();\n  }\n  private _fitInkBarToContent = false;\n\n  /** Whether tabs should be stretched to fill the header. */\n  @Input('mat-stretch-tabs')\n  get stretchTabs(): boolean {\n    return this._stretchTabs;\n  }\n  set stretchTabs(v: BooleanInput) {\n    this._stretchTabs = coerceBooleanProperty(v);\n  }\n  private _stretchTabs = true;\n\n  /** Whether the tab group should grow to the size of the active tab. */\n  @Input()\n  get dynamicHeight(): boolean {\n    return this._dynamicHeight;\n  }\n\n  set dynamicHeight(value: BooleanInput) {\n    this._dynamicHeight = coerceBooleanProperty(value);\n  }\n\n  private _dynamicHeight: boolean = false;\n\n  /** The index of the active tab. */\n  @Input()\n  get selectedIndex(): number | null {\n    return this._selectedIndex;\n  }\n\n  set selectedIndex(value: NumberInput) {\n    this._indexToSelect = coerceNumberProperty(value, null);\n  }\n\n  private _selectedIndex: number | null = null;\n\n  /** Position of the tab header. */\n  @Input() headerPosition: MatTabHeaderPosition = 'above';\n\n  /** Duration for the tab animation. Will be normalized to milliseconds if no units are set. */\n  @Input()\n  get animationDuration(): string {\n    return this._animationDuration;\n  }\n\n  set animationDuration(value: NumberInput) {\n    this._animationDuration = /^\\d+$/.test(value + '') ? value + 'ms' : (value as string);\n  }\n\n  private _animationDuration: string;\n\n  /**\n   * `tabindex` to be set on the inner element that wraps the tab content. Can be used for improved\n   * accessibility when the tab does not have focusable elements or if it has scrollable content.\n   * The `tabindex` will be removed automatically for inactive tabs.\n   * Read more at https://www.w3.org/TR/wai-aria-practices/examples/tabs/tabs-2/tabs.html\n   */\n  @Input()\n  get contentTabIndex(): number | null {\n    return this._contentTabIndex;\n  }\n\n  set contentTabIndex(value: NumberInput) {\n    this._contentTabIndex = coerceNumberProperty(value, null);\n  }\n\n  private _contentTabIndex: number | null;\n\n  /**\n   * Whether pagination should be disabled. This can be used to avoid unnecessary\n   * layout recalculations if it's known that pagination won't be required.\n   */\n  @Input()\n  get disablePagination(): boolean {\n    return this._disablePagination;\n  }\n\n  set disablePagination(value: BooleanInput) {\n    this._disablePagination = coerceBooleanProperty(value);\n  }\n\n  private _disablePagination: boolean = false;\n\n  /**\n   * By default tabs remove their content from the DOM while it's off-screen.\n   * Setting this to `true` will keep it in the DOM which will prevent elements\n   * like iframes and videos from reloading next time it comes back into the view.\n   */\n  @Input()\n  get preserveContent(): boolean {\n    return this._preserveContent;\n  }\n\n  set preserveContent(value: BooleanInput) {\n    this._preserveContent = coerceBooleanProperty(value);\n  }\n\n  private _preserveContent: boolean = false;\n\n  /** Background color of the tab group. */\n  @Input()\n  get backgroundColor(): ThemePalette {\n    return this._backgroundColor;\n  }\n\n  set backgroundColor(value: ThemePalette) {\n    const classList: DOMTokenList = this._elementRef.nativeElement.classList;\n\n    classList.remove('mat-tabs-with-background', `mat-background-${this.backgroundColor}`);\n\n    if (value) {\n      classList.add('mat-tabs-with-background', `mat-background-${value}`);\n    }\n\n    this._backgroundColor = value;\n  }\n\n  private _backgroundColor: ThemePalette;\n\n  /** Output to enable support for two-way binding on `[(selectedIndex)]` */\n  @Output() readonly selectedIndexChange: EventEmitter<number> = new EventEmitter<number>();\n\n  /** Event emitted when focus has changed within a tab group. */\n  @Output() readonly focusChange: EventEmitter<MatTabChangeEvent> =\n    new EventEmitter<MatTabChangeEvent>();\n\n  /** Event emitted when the body animation has completed */\n  @Output() readonly animationDone: EventEmitter<void> = new EventEmitter<void>();\n\n  /** Event emitted when the tab selection has changed. */\n  @Output() readonly selectedTabChange: EventEmitter<MatTabChangeEvent> =\n    new EventEmitter<MatTabChangeEvent>(true);\n\n  private _groupId: number;\n\n  constructor(\n    elementRef: ElementRef,\n    private _changeDetectorRef: ChangeDetectorRef,\n    @Inject(MAT_TABS_CONFIG) @Optional() defaultConfig?: MatTabsConfig,\n    @Optional() @Inject(ANIMATION_MODULE_TYPE) public _animationMode?: string,\n  ) {\n    super(elementRef);\n    this._groupId = nextId++;\n    this.animationDuration =\n      defaultConfig && defaultConfig.animationDuration ? defaultConfig.animationDuration : '500ms';\n    this.disablePagination =\n      defaultConfig && defaultConfig.disablePagination != null\n        ? defaultConfig.disablePagination\n        : false;\n    this.dynamicHeight =\n      defaultConfig && defaultConfig.dynamicHeight != null ? defaultConfig.dynamicHeight : false;\n    this.contentTabIndex = defaultConfig?.contentTabIndex ?? null;\n    this.preserveContent = !!defaultConfig?.preserveContent;\n    this.fitInkBarToContent =\n      defaultConfig && defaultConfig.fitInkBarToContent != null\n        ? defaultConfig.fitInkBarToContent\n        : false;\n    this.stretchTabs =\n      defaultConfig && defaultConfig.stretchTabs != null ? defaultConfig.stretchTabs : true;\n  }\n\n  /**\n   * After the content is checked, this component knows what tabs have been defined\n   * and what the selected index should be. This is where we can know exactly what position\n   * each tab should be in according to the new selected index, and additionally we know how\n   * a new selected tab should transition in (from the left or right).\n   */\n  ngAfterContentChecked() {\n    // Don't clamp the `indexToSelect` immediately in the setter because it can happen that\n    // the amount of tabs changes before the actual change detection runs.\n    const indexToSelect = (this._indexToSelect = this._clampTabIndex(this._indexToSelect));\n\n    // If there is a change in selected index, emit a change event. Should not trigger if\n    // the selected index has not yet been initialized.\n    if (this._selectedIndex != indexToSelect) {\n      const isFirstRun = this._selectedIndex == null;\n\n      if (!isFirstRun) {\n        this.selectedTabChange.emit(this._createChangeEvent(indexToSelect));\n        // Preserve the height so page doesn't scroll up during tab change.\n        // Fixes https://stackblitz.com/edit/mat-tabs-scroll-page-top-on-tab-change\n        const wrapper = this._tabBodyWrapper.nativeElement;\n        wrapper.style.minHeight = wrapper.clientHeight + 'px';\n      }\n\n      // Changing these values after change detection has run\n      // since the checked content may contain references to them.\n      Promise.resolve().then(() => {\n        this._tabs.forEach((tab, index) => (tab.isActive = index === indexToSelect));\n\n        if (!isFirstRun) {\n          this.selectedIndexChange.emit(indexToSelect);\n          // Clear the min-height, this was needed during tab change to avoid\n          // unnecessary scrolling.\n          this._tabBodyWrapper.nativeElement.style.minHeight = '';\n        }\n      });\n    }\n\n    // Setup the position for each tab and optionally setup an origin on the next selected tab.\n    this._tabs.forEach((tab: MatTab, index: number) => {\n      tab.position = index - indexToSelect;\n\n      // If there is already a selected tab, then set up an origin for the next selected tab\n      // if it doesn't have one already.\n      if (this._selectedIndex != null && tab.position == 0 && !tab.origin) {\n        tab.origin = indexToSelect - this._selectedIndex;\n      }\n    });\n\n    if (this._selectedIndex !== indexToSelect) {\n      this._selectedIndex = indexToSelect;\n      this._lastFocusedTabIndex = null;\n      this._changeDetectorRef.markForCheck();\n    }\n  }\n\n  ngAfterContentInit() {\n    this._subscribeToAllTabChanges();\n    this._subscribeToTabLabels();\n\n    // Subscribe to changes in the amount of tabs, in order to be\n    // able to re-render the content as new tabs are added or removed.\n    this._tabsSubscription = this._tabs.changes.subscribe(() => {\n      const indexToSelect = this._clampTabIndex(this._indexToSelect);\n\n      // Maintain the previously-selected tab if a new tab is added or removed and there is no\n      // explicit change that selects a different tab.\n      if (indexToSelect === this._selectedIndex) {\n        const tabs = this._tabs.toArray();\n        let selectedTab: MatTab | undefined;\n\n        for (let i = 0; i < tabs.length; i++) {\n          if (tabs[i].isActive) {\n            // Assign both to the `_indexToSelect` and `_selectedIndex` so we don't fire a changed\n            // event, otherwise the consumer may end up in an infinite loop in some edge cases like\n            // adding a tab within the `selectedIndexChange` event.\n            this._indexToSelect = this._selectedIndex = i;\n            this._lastFocusedTabIndex = null;\n            selectedTab = tabs[i];\n            break;\n          }\n        }\n\n        // If we haven't found an active tab and a tab exists at the selected index, it means\n        // that the active tab was swapped out. Since this won't be picked up by the rendering\n        // loop in `ngAfterContentChecked`, we need to sync it up manually.\n        if (!selectedTab && tabs[indexToSelect]) {\n          Promise.resolve().then(() => {\n            tabs[indexToSelect].isActive = true;\n            this.selectedTabChange.emit(this._createChangeEvent(indexToSelect));\n          });\n        }\n      }\n\n      this._changeDetectorRef.markForCheck();\n    });\n  }\n\n  /** Listens to changes in all of the tabs. */\n  private _subscribeToAllTabChanges() {\n    // Since we use a query with `descendants: true` to pick up the tabs, we may end up catching\n    // some that are inside of nested tab groups. We filter them out manually by checking that\n    // the closest group to the tab is the current one.\n    this._allTabs.changes.pipe(startWith(this._allTabs)).subscribe((tabs: QueryList<MatTab>) => {\n      this._tabs.reset(\n        tabs.filter(tab => {\n          return tab._closestTabGroup === this || !tab._closestTabGroup;\n        }),\n      );\n      this._tabs.notifyOnChanges();\n    });\n  }\n\n  ngOnDestroy() {\n    this._tabs.destroy();\n    this._tabsSubscription.unsubscribe();\n    this._tabLabelSubscription.unsubscribe();\n  }\n\n  /** Re-aligns the ink bar to the selected tab element. */\n  realignInkBar() {\n    if (this._tabHeader) {\n      this._tabHeader._alignInkBarToSelectedTab();\n    }\n  }\n\n  /**\n   * Recalculates the tab group's pagination dimensions.\n   *\n   * WARNING: Calling this method can be very costly in terms of performance. It should be called\n   * as infrequently as possible from outside of the Tabs component as it causes a reflow of the\n   * page.\n   */\n  updatePagination() {\n    if (this._tabHeader) {\n      this._tabHeader.updatePagination();\n    }\n  }\n\n  /**\n   * Sets focus to a particular tab.\n   * @param index Index of the tab to be focused.\n   */\n  focusTab(index: number) {\n    const header = this._tabHeader;\n\n    if (header) {\n      header.focusIndex = index;\n    }\n  }\n\n  _focusChanged(index: number) {\n    this._lastFocusedTabIndex = index;\n    this.focusChange.emit(this._createChangeEvent(index));\n  }\n\n  private _createChangeEvent(index: number): MatTabChangeEvent {\n    const event = new MatTabChangeEvent();\n    event.index = index;\n    if (this._tabs && this._tabs.length) {\n      event.tab = this._tabs.toArray()[index];\n    }\n    return event;\n  }\n\n  /**\n   * Subscribes to changes in the tab labels. This is needed, because the @Input for the label is\n   * on the MatTab component, whereas the data binding is inside the MatTabGroup. In order for the\n   * binding to be updated, we need to subscribe to changes in it and trigger change detection\n   * manually.\n   */\n  private _subscribeToTabLabels() {\n    if (this._tabLabelSubscription) {\n      this._tabLabelSubscription.unsubscribe();\n    }\n\n    this._tabLabelSubscription = merge(...this._tabs.map(tab => tab._stateChanges)).subscribe(() =>\n      this._changeDetectorRef.markForCheck(),\n    );\n  }\n\n  /** Clamps the given index to the bounds of 0 and the tabs length. */\n  private _clampTabIndex(index: number | null): number {\n    // Note the `|| 0`, which ensures that values like NaN can't get through\n    // and which would otherwise throw the component into an infinite loop\n    // (since Math.max(NaN, 0) === NaN).\n    return Math.min(this._tabs.length - 1, Math.max(index || 0, 0));\n  }\n\n  /** Returns a unique id for each tab label element */\n  _getTabLabelId(i: number): string {\n    return `mat-tab-label-${this._groupId}-${i}`;\n  }\n\n  /** Returns a unique id for each tab content element */\n  _getTabContentId(i: number): string {\n    return `mat-tab-content-${this._groupId}-${i}`;\n  }\n\n  /**\n   * Sets the height of the body wrapper to the height of the activating tab if dynamic\n   * height property is true.\n   */\n  _setTabBodyWrapperHeight(tabHeight: number): void {\n    if (!this._dynamicHeight || !this._tabBodyWrapperHeight) {\n      return;\n    }\n\n    const wrapper: HTMLElement = this._tabBodyWrapper.nativeElement;\n\n    wrapper.style.height = this._tabBodyWrapperHeight + 'px';\n\n    // This conditional forces the browser to paint the height so that\n    // the animation to the new height can have an origin.\n    if (this._tabBodyWrapper.nativeElement.offsetHeight) {\n      wrapper.style.height = tabHeight + 'px';\n    }\n  }\n\n  /** Removes the height of the tab body wrapper. */\n  _removeTabBodyWrapperHeight(): void {\n    const wrapper = this._tabBodyWrapper.nativeElement;\n    this._tabBodyWrapperHeight = wrapper.clientHeight;\n    wrapper.style.height = '';\n    this.animationDone.emit();\n  }\n\n  /** Handle click events, setting new selected index if appropriate. */\n  _handleClick(tab: MatTab, tabHeader: MatTabGroupBaseHeader, index: number) {\n    tabHeader.focusIndex = index;\n\n    if (!tab.disabled) {\n      this.selectedIndex = index;\n    }\n  }\n\n  /** Retrieves the tabindex for the tab. */\n  _getTabIndex(index: number): number {\n    const targetIndex = this._lastFocusedTabIndex ?? this.selectedIndex;\n    return index === targetIndex ? 0 : -1;\n  }\n\n  /** Callback for when the focused state of a tab has changed. */\n  _tabFocusChanged(focusOrigin: FocusOrigin, index: number) {\n    // Mouse/touch focus happens during the `mousedown`/`touchstart` phase which\n    // can cause the tab to be moved out from under the pointer, interrupting the\n    // click sequence (see #21898). We don't need to scroll the tab into view for\n    // such cases anyway, because it will be done when the tab becomes selected.\n    if (focusOrigin && focusOrigin !== 'mouse' && focusOrigin !== 'touch') {\n      this._tabHeader.focusIndex = index;\n    }\n  }\n}\n\n/** A simple change event emitted on focus or selection changes. */\nexport class MatTabChangeEvent {\n  /** Index of the currently-selected tab. */\n  index: number;\n  /** Reference to the currently-selected tab. */\n  tab: MatTab;\n}\n","<mat-tab-header #tabHeader\n                [selectedIndex]=\"selectedIndex || 0\"\n                [disableRipple]=\"disableRipple\"\n                [disablePagination]=\"disablePagination\"\n                (indexFocused)=\"_focusChanged($event)\"\n                (selectFocusedIndex)=\"selectedIndex = $event\">\n\n  @for (tab of _tabs; track tab; let i = $index) {\n    <div class=\"mdc-tab mat-mdc-tab mat-mdc-focus-indicator\"\n        #tabNode\n        role=\"tab\"\n        matTabLabelWrapper\n        cdkMonitorElementFocus\n        [id]=\"_getTabLabelId(i)\"\n        [attr.tabIndex]=\"_getTabIndex(i)\"\n        [attr.aria-posinset]=\"i + 1\"\n        [attr.aria-setsize]=\"_tabs.length\"\n        [attr.aria-controls]=\"_getTabContentId(i)\"\n        [attr.aria-selected]=\"selectedIndex === i\"\n        [attr.aria-label]=\"tab.ariaLabel || null\"\n        [attr.aria-labelledby]=\"(!tab.ariaLabel && tab.ariaLabelledby) ? tab.ariaLabelledby : null\"\n        [class.mdc-tab--active]=\"selectedIndex === i\"\n        [ngClass]=\"tab.labelClass\"\n        [disabled]=\"tab.disabled\"\n        [fitInkBarToContent]=\"fitInkBarToContent\"\n        (click)=\"_handleClick(tab, tabHeader, i)\"\n        (cdkFocusChange)=\"_tabFocusChanged($event, i)\">\n      <span class=\"mdc-tab__ripple\"></span>\n\n      <!-- Needs to be a separate element, because we can't put\n          `overflow: hidden` on tab due to the ink bar. -->\n      <div\n        class=\"mat-mdc-tab-ripple\"\n        mat-ripple\n        [matRippleTrigger]=\"tabNode\"\n        [matRippleDisabled]=\"tab.disabled || disableRipple\"></div>\n\n      <span class=\"mdc-tab__content\">\n        <span class=\"mdc-tab__text-label\">\n          <!--\n            If there is a label template, use it, otherwise fall back to the text label.\n            Note that we don't have indentation around the text label, because it adds\n            whitespace around the text which breaks some internal tests.\n          -->\n          @if (tab.templateLabel) {\n            <ng-template [cdkPortalOutlet]=\"tab.templateLabel\"></ng-template>\n          } @else {{{tab.textLabel}}}\n        </span>\n      </span>\n    </div>\n  }\n</mat-tab-header>\n\n<div\n  class=\"mat-mdc-tab-body-wrapper\"\n  [class._mat-animation-noopable]=\"_animationMode === 'NoopAnimations'\"\n  #tabBodyWrapper>\n  @for (tab of _tabs; track tab; let i = $index) {\n    <mat-tab-body role=\"tabpanel\"\n                 [id]=\"_getTabContentId(i)\"\n                 [attr.tabindex]=\"(contentTabIndex != null && selectedIndex === i) ? contentTabIndex : null\"\n                 [attr.aria-labelledby]=\"_getTabLabelId(i)\"\n                 [attr.aria-hidden]=\"selectedIndex !== i\"\n                 [class.mat-mdc-tab-body-active]=\"selectedIndex === i\"\n                 [ngClass]=\"tab.bodyClass\"\n                 [content]=\"tab.content!\"\n                 [position]=\"tab.position!\"\n                 [origin]=\"tab.origin\"\n                 [animationDuration]=\"animationDuration\"\n                 [preserveContent]=\"preserveContent\"\n                 (_onCentered)=\"_removeTabBodyWrapperHeight()\"\n                 (_onCentering)=\"_setTabBodyWrapperHeight($event)\">\n    </mat-tab-body>\n  }\n</div>\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {\n  Directive,\n  Inject,\n  InjectionToken,\n  Optional,\n  TemplateRef,\n  ViewContainerRef,\n} from '@angular/core';\nimport {CdkPortal} from '@angular/cdk/portal';\n\n/**\n * Injection token that can be used to reference instances of `MatTabLabel`. It serves as\n * alternative token to the actual `MatTabLabel` class which could cause unnecessary\n * retention of the class and its directive metadata.\n */\nexport const MAT_TAB_LABEL = new InjectionToken<MatTabLabel>('MatTabLabel');\n\n/**\n * Used to provide a tab label to a tab without causing a circular dependency.\n * @docs-private\n */\nexport const MAT_TAB = new InjectionToken<any>('MAT_TAB');\n\n/** Used to flag tab labels for use with the portal directive */\n@Directive({\n  selector: '[mat-tab-label], [matTabLabel]',\n  providers: [{provide: MAT_TAB_LABEL, useExisting: MatTabLabel}],\n})\nexport class MatTabLabel extends CdkPortal {\n  constructor(\n    templateRef: TemplateRef<any>,\n    viewContainerRef: ViewContainerRef,\n    @Inject(MAT_TAB) @Optional() public _closestTab: any,\n  ) {\n    super(templateRef, viewContainerRef);\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {Directive, InjectionToken, TemplateRef} from '@angular/core';\n\n/**\n * Injection token that can be used to reference instances of `MatTabContent`. It serves as\n * alternative token to the actual `MatTabContent` class which could cause unnecessary\n * retention of the class and its directive metadata.\n */\nexport const MAT_TAB_CONTENT = new InjectionToken<MatTabContent>('MatTabContent');\n\n/** Decorates the `ng-template` tags and reads out the template from it. */\n@Directive({\n  selector: '[matTabContent]',\n  providers: [{provide: MAT_TAB_CONTENT, useExisting: MatTabContent}],\n})\nexport class MatTabContent {\n  constructor(/** Content for the tab. */ public template: TemplateRef<any>) {}\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {\n  ChangeDetectionStrategy,\n  Component,\n  ContentChild,\n  Inject,\n  InjectionToken,\n  Input,\n  OnChanges,\n  OnDestroy,\n  OnInit,\n  Optional,\n  SimpleChanges,\n  TemplateRef,\n  ViewChild,\n  ViewContainerRef,\n  ViewEncapsulation,\n} from '@angular/core';\nimport {MatTabContent} from './tab-content';\nimport {MAT_TAB, MatTabLabel} from './tab-label';\nimport {CanDisable, mixinDisabled} from '@angular/material/core';\nimport {TemplatePortal} from '@angular/cdk/portal';\nimport {Subject} from 'rxjs';\n\n// Boilerplate for applying mixins to MatTab.\n/** @docs-private */\nconst _MatTabMixinBase = mixinDisabled(class {});\n\n/**\n * Used to provide a tab group to a tab without causing a circular dependency.\n * @docs-private\n */\nexport const MAT_TAB_GROUP = new InjectionToken<any>('MAT_TAB_GROUP');\n\n@Component({\n  selector: 'mat-tab',\n\n  // Note that usually we'd go through a bit more trouble and set up another class so that\n  // the inlined template of `MatTab` isn't duplicated, however the template is small enough\n  // that creating the extra class will generate more code than just duplicating the template.\n  templateUrl: 'tab.html',\n  inputs: ['disabled'],\n  // tslint:disable-next-line:validate-decorators\n  changeDetection: ChangeDetectionStrategy.Default,\n  encapsulation: ViewEncapsulation.None,\n  exportAs: 'matTab',\n  providers: [{provide: MAT_TAB, useExisting: MatTab}],\n})\nexport class MatTab extends _MatTabMixinBase implements CanDisable, OnInit, OnChanges, OnDestroy {\n  /** Content for the tab label given by `<ng-template mat-tab-label>`. */\n  private _templateLabel: MatTabLabel;\n  @ContentChild(MatTabLabel)\n  get templateLabel(): MatTabLabel {\n    return this._templateLabel;\n  }\n  set templateLabel(value: MatTabLabel) {\n    this._setTemplateLabelInput(value);\n  }\n\n  /**\n   * Template provided in the tab content that will be used if present, used to enable lazy-loading\n   */\n  @ContentChild(MatTabContent, {read: TemplateRef, static: true})\n  // We need an initializer here to avoid a TS error. The value will be set in `ngAfterViewInit`.\n  private _explicitContent: TemplateRef<any> = undefined!;\n\n  /** Template inside the MatTab view that contains an `<ng-content>`. */\n  @ViewChild(TemplateRef, {static: true}) _implicitContent: TemplateRef<any>;\n\n  /** Plain text label for the tab, used when there is no template label. */\n  @Input('label') textLabel: string = '';\n\n  /** Aria label for the tab. */\n  @Input('aria-label') ariaLabel: string;\n\n  /**\n   * Reference to the element that the tab is labelled by.\n   * Will be cleared if `aria-label` is set at the same time.\n   */\n  @Input('aria-labelledby') ariaLabelledby: string;\n\n  /**\n   * Classes to be passed to the tab label inside the mat-tab-header container.\n   * Supports string and string array values, same as `ngClass`.\n   */\n  @Input() labelClass: string | string[];\n\n  /**\n   * Classes to be passed to the tab mat-tab-body container.\n   * Supports string and string array values, same as `ngClass`.\n   */\n  @Input() bodyClass: string | string[];\n\n  /** Portal that will be the hosted content of the tab */\n  private _contentPortal: TemplatePortal | null = null;\n\n  /** @docs-private */\n  get content(): TemplatePortal | null {\n    return this._contentPortal;\n  }\n\n  /** Emits whenever the internal state of the tab changes. */\n  readonly _stateChanges = new Subject<void>();\n\n  /**\n   * The relatively indexed position where 0 represents the center, negative is left, and positive\n   * represents the right.\n   */\n  position: number | null = null;\n\n  /**\n   * The initial relatively index origin of the tab if it was created and selected after there\n   * was already a selected tab. Provides context of what position the tab should originate from.\n   */\n  origin: number | null = null;\n\n  /**\n   * Whether the tab is currently active.\n   */\n  isActive = false;\n\n  constructor(\n    private _viewContainerRef: ViewContainerRef,\n    @Inject(MAT_TAB_GROUP) @Optional() public _closestTabGroup: any,\n  ) {\n    super();\n  }\n\n  ngOnChanges(changes: SimpleChanges): void {\n    if (changes.hasOwnProperty('textLabel') || changes.hasOwnProperty('disabled')) {\n      this._stateChanges.next();\n    }\n  }\n\n  ngOnDestroy(): void {\n    this._stateChanges.complete();\n  }\n\n  ngOnInit(): void {\n    this._contentPortal = new TemplatePortal(\n      this._explicitContent || this._implicitContent,\n      this._viewContainerRef,\n    );\n  }\n\n  /**\n   * This has been extracted to a util because of TS 4 and VE.\n   * View Engine doesn't support property rename inheritance.\n   * TS 4.0 doesn't allow properties to override accessors or vice-versa.\n   * @docs-private\n   */\n  private _setTemplateLabelInput(value: MatTabLabel | undefined) {\n    // Only update the label if the query managed to find one. This works around an issue where a\n    // user may have manually set `templateLabel` during creation mode, which would then get\n    // clobbered by `undefined` when the query resolves. Also note that we check that the closest\n    // tab matches the current one so that we don't pick up labels from nested tabs.\n    if (value && value._closestTab === this) {\n      this._templateLabel = value;\n    }\n  }\n}\n","<!-- Create a template for the content of the <mat-tab> so that we can grab a reference to this\n    TemplateRef and use it in a Portal to render the tab content in the appropriate place in the\n    tab-group. -->\n<ng-template><ng-content></ng-content></ng-template>\n"],"names":["ListKeyManager","constructor","_items","_activeItemIndex","_activeItem","_wrap","_letterKeyStream","Subject","_typeaheadSubscription","Subscription","EMPTY","_vertical","_allowedModifierKeys","_homeAndEnd","_pageUpAndDown","enabled","delta","_skipPredicateFn","item","disabled","_pressedLetters","tabOut","change","QueryList","this","_itemChangesSubscription","changes","subscribe","newItems","newIndex","toArray","indexOf","skipPredicate","predicate","withWrap","shouldWrap","withVerticalOrientation","withHorizontalOrientation","direction","_horizontal","withAllowedModifierKeys","keys","withTypeAhead","debounceInterval","unsubscribe","pipe","tap","letter","push","debounceTime","filter","length","map","join","inputString","items","_getItemsArray","i","index","getLabel","toUpperCase","trim","setActiveItem","cancelTypeahead","withHomeAndEnd","withPageUpDown","previousActiveItem","updateActiveItem","next","onKeydown","event","keyCode","isModifierAllowed","every","modifier","TAB","DOWN_ARROW","setNextItemActive","UP_ARROW","setPreviousItemActive","RIGHT_ARROW","LEFT_ARROW","HOME","setFirstItemActive","END","setLastItemActive","PAGE_UP","targetIndex","_setActiveItemByIndex","PAGE_DOWN","itemsLength","hasModifierKey","key","toLocaleUpperCase","A","Z","ZERO","NINE","String","fromCharCode","preventDefault","activeItemIndex","activeItem","isTyping","_setActiveItemByDelta","itemArray","destroy","complete","_setActiveInWrapMode","_setActiveInDefaultMode","fallbackDelta","coerceBooleanProperty","value","mixinColor","base","defaultColor","color","_color","colorPalette","_elementRef","nativeElement","classList","remove","add","args","super","mixinDisableRipple","disableRipple","_disableRipple","mixinDisabled","_disabled","MatTabsModule","CommonModule","MatCommonModule","PortalModule","MatRippleModule","ObserversModule","A11yModule","MAT_TABS_CONFIG","InjectionToken","matTabsAnimations","translateTab","trigger","state","style","transform","minHeight","visibility","transition","animate","MatTabBody_ng_template_2_Template","rf","ctx","_c0","a0","animationDuration","_c1","a1","params","MatTabBodyPortal","CdkPortalOutlet","componentFactoryResolver","viewContainerRef","_host","_document","_centeringSub","_leavingSub","ngOnInit","_beforeCentering","startWith","_isCenterPosition","_position","isCentering","hasAttached","attach","_content","_afterLeavingCenter","preserveContent","detach","ngOnDestroy","i0","forwardRef","MatTabBody","DOCUMENT","selectors","features","position","_positionIndex","_computePositionAnimationState","_dir","changeDetectorRef","_dirChangeSubscription","_translateTabComplete","_onCentering","EventEmitter","_onCentered","dir","markForCheck","distinctUntilChanged","x","y","fromState","toState","emit","origin","_computePositionFromOrigin","_onTranslateTabStarted","clientHeight","_getLayoutDirection","i1","viewQuery","_t","$event","styles","encapsulation","data","animation","ACTIVE_CLASS","NO_TRANSITION_CLASS","MatInkBar","hide","forEach","deactivateInkBar","alignToElement","element","correspondingItem","find","elementRef","currentItem","_currentItem","clientRect","getBoundingClientRect","activateInkBar","providedIn","factory","left","offsetLeft","width","offsetWidth","_MatTabLabelWrapperMixinBase","_fitToContent","fitInkBarToContent","v","newValue","_inkBarElement","_appendInkBarElement","previousIndicatorClientRect","_inkBarContentElement","currentClientRect","widthDelta","xPosition","setProperty","_createInkBarElement","documentNode","ownerDocument","document","createElement","className","appendChild","querySelector","MatTabLabelWrapper","focus","getOffsetLeft","getOffsetWidth","hostVars","hostBindings","FocusKeyManager","_origin","setFocusOrigin","passiveEventListenerOptions","normalizePassiveListenerOptions","passive","MatPaginatedTabHeader","disablePagination","_disablePagination","selectedIndex","_selectedIndex","coerceNumberProperty","_selectedIndexChanged","_keyManager","_changeDetectorRef","_viewportRuler","_ngZone","_platform","_animationMode","_scrollDistance","_destroyed","_showPaginationControls","_disableScrollAfter","_disableScrollBefore","_stopScrolling","selectFocusedIndex","indexFocused","runOutsideAngular","fromEvent","takeUntil","_stopInterval","ngAfterViewInit","_previousPaginator","_handlePaginatorPress","_nextPaginator","ngAfterContentInit","dirChange","observableOf","resize","realign","updatePagination","_alignInkBarToSelectedTab","onStable","take","merge","_itemsResized","run","Promise","resolve","then","Math","max","min","_getMaxScrollDistance","newFocusIndex","_setTabFocus","ResizeObserver","switchMap","tabItems","Observable","observer","resizeObserver","entries","observe","disconnect","skip","some","e","contentRect","height","ngAfterContentChecked","_tabLabelCount","_scrollToLabel","_checkScrollingControls","_scrollDistanceChanged","_updateTabScrollPosition","_handleKeydown","ENTER","SPACE","focusIndex","get","_itemSelected","_onContentChanges","textContent","_currentTextContent","_checkPaginationEnabled","_isValidIndex","tabIndex","containerEl","_tabListContainer","scrollLeft","scrollWidth","scrollDistance","translateX","_tabList","round","TRIDENT","EDGE","_scrollTo","_scrollHeader","scrollAmount","_handlePaginatorClick","labelIndex","selectedLabel","viewLength","labelBeforePos","labelAfterPos","_tabListInner","beforeVisiblePos","afterVisiblePos","isEnabled","selectedItem","selectedLabelWrapper","_inkBar","mouseEvent","button","timer","maxScrollDistance","distance","i2","i3","ANIMATION_MODULE_TYPE","inputs","_c2","_c3","_c4","_c5","MatTabHeader","viewportRuler","ngZone","platform","animationMode","contentQueries","dirIndex","dependencies","i4","i5","MatTabGroup_For_3_Conditional_6_ng_template_0_Template","MatTabGroup_For_3_Conditional_6_Template","tab_r4","MatTabGroup_For_3_Conditional_7_Template","MatTabGroup_For_3_Template","_r16","ctx_r15","_handleClick","_r0","i_r5","ctx_r17","_tabFocusChanged","$implicit","$index","_r9","labelClass","ctx_r1","_tabs","_getTabContentId","ariaLabel","ariaLabelledby","MatTabGroup_For_7_Template","_r24","ctx_r23","_removeTabBodyWrapperHeight","ctx_r25","_setTabBodyWrapperHeight","tab_r18","i_r19","ctx_r3","bodyClass","content","_getTabLabelId","nextId","_MatTabGroupMixinBase","MatTabGroup","_fitInkBarToContent","stretchTabs","_stretchTabs","dynamicHeight","_dynamicHeight","_indexToSelect","_animationDuration","test","contentTabIndex","_contentTabIndex","_preserveContent","backgroundColor","_backgroundColor","defaultConfig","_lastFocusedTabIndex","_tabBodyWrapperHeight","_tabsSubscription","_tabLabelSubscription","headerPosition","selectedIndexChange","focusChange","animationDone","selectedTabChange","_groupId","indexToSelect","_clampTabIndex","isFirstRun","_createChangeEvent","wrapper","_tabBodyWrapper","tab","isActive","_subscribeToAllTabChanges","_subscribeToTabLabels","tabs","selectedTab","_allTabs","reset","_closestTabGroup","notifyOnChanges","realignInkBar","_tabHeader","focusTab","header","_focusChanged","MatTabChangeEvent","_stateChanges","tabHeight","offsetHeight","tabHeader","_getTabIndex","focusOrigin","MatTab","provide","MAT_TAB_GROUP","useExisting","i6","i7","MAT_TAB_LABEL","MAT_TAB","MatTabLabel","CdkPortal","templateRef","_closestTab","MAT_TAB_CONTENT","MatTabContent","template","MatTab_ng_template_0_Template","_MatTabMixinBase","templateLabel","_templateLabel","_setTemplateLabelInput","_contentPortal","_viewContainerRef","_explicitContent","undefined","textLabel","ngOnChanges","hasOwnProperty","TemplatePortal","_implicitContent","TemplateRef"],"sourceRoot":""}