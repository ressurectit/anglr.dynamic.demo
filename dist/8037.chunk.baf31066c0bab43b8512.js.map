{"version":3,"file":"8037.chunk.baf31066c0bab43b8512.js","mappings":"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","sources":["webpack://ng-universal-demo/../form/src/components/formComponentBase/formComponentBase.ts","webpack://ng-universal-demo/../form/src/misc/enums.ts","webpack://ng-universal-demo/../form/src/misc/tokens.ts","webpack://ng-universal-demo/../form/src/pipes/control/control.pipe.ts","webpack://ng-universal-demo/../layout-editor/src/decorators/layoutEditorMetadata/layoutEditorMetadata.decorator.ts","webpack://ng-universal-demo/../layout/src/components/layoutComponentBase/layoutComponentBase.ts","webpack://ng-universal-demo/../layout/src/extensions/componentStyling/componentStyling.extension.ts","webpack://ng-universal-demo/../../../../src/material/radio/radio-module.ts","webpack://ng-universal-demo/../material-components/src/dynamicItems/radio/radio.metadata.ts","webpack://ng-universal-demo/../../../../src/cdk/collections/unique-selection-dispatcher.ts","webpack://ng-universal-demo/../../../../src/material/radio/radio.ts","webpack://ng-universal-demo/../../src/material/radio/radio.html","webpack://ng-universal-demo/../../../../src/material/radio/radio.html","webpack://ng-universal-demo/../material-components/src/dynamicItems/radio/radio.component.ts","webpack://ng-universal-demo/../material-components/src/dynamicItems/radio/radio.component.html","webpack://ng-universal-demo/../material-components/src/dynamicItems/radio/type.ts","webpack://ng-universal-demo/../src/misc/dynamicItemExtensionBase.ts","webpack://ng-universal-demo/../../../../forms/src/modules/formPipes/pipes/asFormControl/asFormControl.pipe.ts","webpack://ng-universal-demo/../../../../src/modules/castPipes/pipes/asRequired/asRequired.pipe.ts"],"sourcesContent":["import {ChangeDetectorRef, Directive, ElementRef, Inject, Injector, Optional} from '@angular/core';\nimport {AbstractControl} from '@angular/forms';\nimport {LayoutComponentBase} from '@anglr/dynamic/layout';\nimport {LOGGER, Logger} from '@anglr/common';\n\nimport {FORM_COMPONENT_CONTROL} from '../../misc/tokens';\nimport {FormComponentOptions} from '../../misc/formComponentBase.options';\n\n/**\n * Base component for form component\n */\n@Directive()\nexport abstract class FormComponentBase<TOptions extends FormComponentOptions> extends LayoutComponentBase<TOptions>\n{\n    constructor(_changeDetector: ChangeDetectorRef,\n                _element: ElementRef<HTMLElement>,\n                _injector: Injector,\n                @Inject(FORM_COMPONENT_CONTROL) @Optional() protected _control?: AbstractControl,\n                @Inject(LOGGER) @Optional() _logger?: Logger,)\n    {\n        super(_changeDetector, _element, _injector, _logger);\n    }\n}","export enum FormComponentControlType\n{\n    FormControl = 'FormControl',\n    FormArray = 'FormArray',\n    FormGroup = 'FormGroup',\n}\n","import {InjectionToken} from '@angular/core';\nimport {AbstractControl} from '@angular/forms';\n\n/**\n * Injection token for form component control\n */\nexport const FORM_COMPONENT_CONTROL : InjectionToken<AbstractControl> = new InjectionToken<AbstractControl>('FORM_COMPONENT_CONTROL');","import {Inject, Pipe, PipeTransform} from '@angular/core';\nimport {AbstractControl, FormArray, FormControl, FormGroup} from '@angular/forms';\nimport {LOGGER, Logger} from '@anglr/common';\n\nimport {FormComponentControlType} from '../../misc/enums';\n\n/**\n * Transforms control name to FormControl|FormArray|FormGroup\n */\n@Pipe({name: 'formComponentControl', standalone: true})\nexport class FormComponentControlSAPipe implements PipeTransform\n{\n    constructor(@Inject(LOGGER) protected _logger: Logger,)\n    {}\n\n    //######################### public methods - implementation of PipeTransform #########################\n\n    /**\n     * Transforms control name to FormControl|FormArray|FormGroup\n     */\n    public transform(controlName: string|null|undefined, parentControl: AbstractControl|undefined, defaultControlType: FormComponentControlType = FormComponentControlType.FormControl): AbstractControl\n    {\n        if (!parentControl ||\n            !controlName)\n        {\n            return this._getControlForType(defaultControlType);\n        }\n\n        const control = parentControl.get(controlName);\n\n        if (!control)\n        {\n            this._logger?.warn('FormComponentControlSAPipe: Unable to find control with name {@name}', {name: controlName});\n        }\n\n        return control ?? this._getControlForType(defaultControlType);\n    }\n\n    //######################### private methods ########################\n\n    /**\n     * Generate dummy abstract control of specified type\n     * @param type \n     * @returns \n     */\n    private _getControlForType(type: FormComponentControlType): FormControl|FormArray|FormGroup\n    {\n        switch (type)\n        {\n            case FormComponentControlType.FormArray:\n                return new FormArray<any>([]);\n            case FormComponentControlType.FormGroup:\n                return new FormGroup({});\n            default:\n                return new FormControl();\n        }\n    }\n}","import {DynamicClassMetadata, DynamicMetadataLoader} from '@anglr/dynamic';\n\nimport {LayoutEditorMetadataDescriptor, LayoutEditorMetadataType} from '../../decorators';\n\n/**\n * Sets layout editor metadata to class on which is this decorator applied\n * @param metadataLoader - Layout editor metadata loader function used for obtaining metadata\n */\nexport function LayoutEditorMetadata(metadataLoader: DynamicMetadataLoader<LayoutEditorMetadataDescriptor>): ClassDecorator\n{\n    return DynamicClassMetadata<LayoutEditorMetadataDescriptor, LayoutEditorMetadataType>(metadataLoader, 'layoutEditorMetadata');\n}","import {ChangeDetectorRef, Directive, ElementRef, Inject, Injector, OnDestroy, Optional, SimpleChanges} from '@angular/core';\nimport {Logger, LOGGER} from '@anglr/common';\nimport {DynamicItemExtension} from '@anglr/dynamic';\nimport {nameof, PromiseOr} from '@jscrpt/common';\n\nimport {LayoutComponent} from '../../interfaces';\n\n/**\n * Base component for layout component\n */\n@Directive()\nexport abstract class LayoutComponentBase<TOptions> implements LayoutComponent<TOptions>, OnDestroy\n{\n    //######################### protected fields #########################\n\n    /**\n     * Array of extensions that are registered for component\n     */\n    protected _extensions: DynamicItemExtension<TOptions>[] = [];\n\n    /**\n     * Indication whether initialization was already done\n     */\n    protected _initialized: boolean = false;\n\n    /**\n     * Indication whether was component destroyed\n     */\n    protected destroyed: boolean = false;\n\n    //######################### protected properties #########################\n\n    /**\n     * Gets element that is used within extension\n     */\n    protected get element(): ElementRef<HTMLElement>\n    {\n        return this._element;\n    }\n\n    /**\n     * Gets options that are used within extension\n     */\n    protected get extensionsOptions(): any|undefined|null\n    {\n        return this.options;\n    }\n\n    //######################### public properties - implementation of LayoutComponent #########################\n\n    /**\n     * @inheritdoc\n     */\n    public options: TOptions|undefined|null;\n\n    //######################### constructor #########################\n    constructor(protected _changeDetector: ChangeDetectorRef,\n                protected _element: ElementRef<HTMLElement>,\n                protected _injector: Injector,\n                @Inject(LOGGER) @Optional() protected _logger?: Logger,)\n    {\n    }\n\n    //######################### public methods - implementation of OnDestroy #########################\n    \n    /**\n     * Called when component is destroyed\n     */\n    public ngOnDestroy(): void\n    {\n        if(this.destroyed)\n        {\n            return;\n        }\n\n        this.destroyed = true;\n\n        for(const ext of this._extensions)\n        {\n            ext.destroy();\n        }\n\n        this._onDestroy();\n    }\n\n    //######################### public methods - implementation of LayoutComponent #########################\n\n    /**\n     * @inheritdoc\n     */\n    public async ngOnInit(): Promise<void>\n    {\n        if(this._initialized)\n        {\n            return;\n        }\n\n        this._initialized = true;\n        const extensionsOptions = this.extensionsOptions;\n        \n        await this._onInit();\n        await this._onOptionsSet();\n\n        if(extensionsOptions)\n        {\n            for(const extension of this._extensions)\n            {\n                await extension.initialize(this._injector, this.element, this);\n            }\n        }\n    }\n\n    /**\n     * @inheritdoc\n     */\n    public async ngOnChanges(changes: SimpleChanges): Promise<void>\n    {\n        //options has changed\n        if(nameof<LayoutComponentBase<TOptions>>('options') in changes)\n        {\n            await this._onOptionsSet();\n\n            const extensionsOptions = this.extensionsOptions;\n\n            //set options in extensions\n            if(extensionsOptions)\n            {\n                for(const extension of this._extensions)\n                {\n                    await extension.optionsChange(extensionsOptions);\n                }\n            }\n\n            if(!this._initialized)\n            {\n                return;\n            }\n\n            await this._onOptionsChange();\n        }\n    }\n\n    /**\n     * @inheritdoc\n     */\n    public registerExtensions(extensions: DynamicItemExtension[]): void\n    {\n        this._extensions = extensions;\n    }\n\n    /**\n     * @inheritdoc\n     */\n    public invalidateVisuals(): void\n    {\n        this._changeDetector.detectChanges();\n    }\n\n    //######################### protected methods #########################\n\n    /**\n     * Called on initialzation of component, options are already set\n     */\n    protected _onInit(): PromiseOr<void>\n    {\n    }\n\n    /**\n     * Called on change of options, after initialization\n     */\n    protected _onOptionsChange(): PromiseOr<void>\n    {\n    }\n\n    /**\n     * Called everytime options are set, after initialization and later\n     */\n    protected _onOptionsSet(): PromiseOr<void>\n    {\n    }\n\n    /**\n     * Called when component is being destroyed\n     */\n    protected _onDestroy(): void\n    {\n    }\n}","import {DynamicItemExtension, DynamicItemExtensionBase} from '@anglr/dynamic';\nimport {isPresent} from '@jscrpt/common';\n\nimport {ComponentStylingOptions} from '../../interfaces';\n\n/**\n * Extension that applies common component styling to component\n */\nexport class ComponentStylingExtension extends DynamicItemExtensionBase<ComponentStylingOptions> implements DynamicItemExtension<ComponentStylingOptions>\n{\n    //######################### protected properties #########################\n\n    /**\n     * Value of last css class\n     */\n    protected lastCssClass: string|undefined|null;\n\n    //######################### public methods - overrides #########################\n\n    /**\n     * @inheritdoc\n     */\n    protected override _onInit(): void\n    {\n        this._applyStyling();\n    }\n\n    /**\n     * @inheritdoc\n     */\n    protected override _onOptionsChange(): void\n    {\n        this._applyStyling();\n    }\n\n    //######################### protected methods #########################\n\n    /**\n     * Applies component styling to element\n     */\n    protected _applyStyling(): void\n    {\n        const options = this._options;\n        const style = this._element?.nativeElement.style;\n\n        if(this._element)\n        {\n            if(isPresent(this.lastCssClass))\n            {\n                this._element.nativeElement.classList.remove(this.lastCssClass);\n            }\n\n            this.lastCssClass = options?.cssClass;\n\n            if(options?.cssClass)\n            {\n                this._element?.nativeElement.classList.add(options.cssClass);\n            }\n        }\n\n        if(isPresent(style))\n        {\n            if(options?.margin)\n            {\n                if(isPresent(options.margin.bottom))\n                {\n                    style.marginBottom = options.margin.bottom;\n                }\n\n                if(isPresent(options.margin.right))\n                {\n                    style.marginRight = options.margin.right;\n                }\n\n                if(isPresent(options.margin.top))\n                {\n                    style.marginTop = options.margin.top;\n                }\n\n                if(isPresent(options.margin.left))\n                {\n                    style.marginLeft = options.margin.left;\n                }\n            }\n\n            if(options?.padding)\n            {\n                if(isPresent(options.padding.bottom))\n                {\n                    style.paddingBottom = options.padding.bottom;\n                }\n\n                if(isPresent(options.padding.right))\n                {\n                    style.paddingRight = options.padding.right;\n                }\n\n                if(isPresent(options.padding.top))\n                {\n                    style.paddingTop = options.padding.top;\n                }\n\n                if(isPresent(options.padding.left))\n                {\n                    style.paddingLeft = options.padding.left;\n                }\n            }\n\n            if(options?.textStyling)\n            {\n                if(isPresent(options.textStyling.fontSize))\n                {\n                    style.fontSize = options.textStyling.fontSize;\n                }\n\n                if(isPresent(options.textStyling.fontWeight))\n                {\n                    style.fontWeight = options.textStyling.fontWeight.toString();\n                }\n            }\n        }\n    }\n}","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {NgModule} from '@angular/core';\nimport {MatCommonModule, MatRippleModule} from '@angular/material/core';\nimport {MatRadioButton, MatRadioGroup} from './radio';\n\n@NgModule({\n  imports: [MatRippleModule, MatCommonModule],\n  exports: [MatRadioGroup, MatRadioButton, MatCommonModule],\n  declarations: [MatRadioGroup, MatRadioButton],\n})\nexport class MatRadioModule {}\n","import {DynamicMetadataLoader} from '@anglr/dynamic';\nimport {LayoutEditorMetadataDescriptor} from '@anglr/dynamic/layout-editor';\n\nimport {MaterialRadioComponentOptions} from './radio.options';\n\n/**\n * Material radio layout metadata loader\n */\nexport const MaterialRadioLayoutMetadataLoader: DynamicMetadataLoader<LayoutEditorMetadataDescriptor<MaterialRadioComponentOptions>> = async () => new (await import('./metadata/radio.layoutMetadata')).MaterialRadioLayoutEditorMetadata();","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {Injectable, OnDestroy} from '@angular/core';\n\n// Users of the Dispatcher never need to see this type, but TypeScript requires it to be exported.\nexport type UniqueSelectionDispatcherListener = (id: string, name: string) => void;\n\n/**\n * Class to coordinate unique selection based on name.\n * Intended to be consumed as an Angular service.\n * This service is needed because native radio change events are only fired on the item currently\n * being selected, and we still need to uncheck the previous selection.\n *\n * This service does not *store* any IDs and names because they may change at any time, so it is\n * less error-prone if they are simply passed through when the events occur.\n */\n@Injectable({providedIn: 'root'})\nexport class UniqueSelectionDispatcher implements OnDestroy {\n  private _listeners: UniqueSelectionDispatcherListener[] = [];\n\n  /**\n   * Notify other items that selection for the given name has been set.\n   * @param id ID of the item.\n   * @param name Name of the item.\n   */\n  notify(id: string, name: string) {\n    for (let listener of this._listeners) {\n      listener(id, name);\n    }\n  }\n\n  /**\n   * Listen for future changes to item selection.\n   * @return Function used to deregister listener\n   */\n  listen(listener: UniqueSelectionDispatcherListener): () => void {\n    this._listeners.push(listener);\n    return () => {\n      this._listeners = this._listeners.filter((registered: UniqueSelectionDispatcherListener) => {\n        return listener !== registered;\n      });\n    };\n  }\n\n  ngOnDestroy() {\n    this._listeners = [];\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {FocusMonitor, FocusOrigin} from '@angular/cdk/a11y';\nimport {BooleanInput, coerceBooleanProperty, coerceNumberProperty} from '@angular/cdk/coercion';\nimport {UniqueSelectionDispatcher} from '@angular/cdk/collections';\nimport {\n  AfterContentInit,\n  AfterViewInit,\n  Attribute,\n  ChangeDetectionStrategy,\n  ChangeDetectorRef,\n  Component,\n  ContentChildren,\n  Directive,\n  DoCheck,\n  ElementRef,\n  EventEmitter,\n  forwardRef,\n  Inject,\n  InjectionToken,\n  Input,\n  OnDestroy,\n  OnInit,\n  Optional,\n  Output,\n  QueryList,\n  ViewChild,\n  ViewEncapsulation,\n} from '@angular/core';\nimport {ControlValueAccessor, NG_VALUE_ACCESSOR} from '@angular/forms';\nimport {\n  CanDisableRipple,\n  HasTabIndex,\n  mixinDisableRipple,\n  mixinTabIndex,\n  ThemePalette,\n} from '@angular/material/core';\nimport {ANIMATION_MODULE_TYPE} from '@angular/platform-browser/animations';\n\nexport interface MatRadioDefaultOptions {\n  color: ThemePalette;\n}\n\nexport const MAT_RADIO_DEFAULT_OPTIONS = new InjectionToken<MatRadioDefaultOptions>(\n  'mat-radio-default-options',\n  {\n    providedIn: 'root',\n    factory: MAT_RADIO_DEFAULT_OPTIONS_FACTORY,\n  },\n);\n\nexport function MAT_RADIO_DEFAULT_OPTIONS_FACTORY(): MatRadioDefaultOptions {\n  return {\n    color: 'accent',\n  };\n}\n\n// Increasing integer for generating unique ids for radio components.\nlet nextUniqueId = 0;\n\n/**\n * Provider Expression that allows mat-radio-group to register as a ControlValueAccessor. This\n * allows it to support [(ngModel)] and ngControl.\n * @docs-private\n */\nexport const MAT_RADIO_GROUP_CONTROL_VALUE_ACCESSOR: any = {\n  provide: NG_VALUE_ACCESSOR,\n  useExisting: forwardRef(() => MatRadioGroup),\n  multi: true,\n};\n\n/** Change event object emitted by MatRadio and MatRadioGroup. */\nexport class MatRadioChange {\n  constructor(\n    /** The MatRadioButton that emits the change event. */\n    public source: _MatRadioButtonBase,\n    /** The value of the MatRadioButton. */\n    public value: any,\n  ) {}\n}\n\n/**\n * Injection token that can be used to inject instances of `MatRadioGroup`. It serves as\n * alternative token to the actual `MatRadioGroup` class which could cause unnecessary\n * retention of the class and its component metadata.\n */\nexport const MAT_RADIO_GROUP = new InjectionToken<_MatRadioGroupBase<_MatRadioButtonBase>>(\n  'MatRadioGroup',\n);\n\n/**\n * Base class with all of the `MatRadioGroup` functionality.\n * @docs-private\n */\n@Directive()\nexport abstract class _MatRadioGroupBase<T extends _MatRadioButtonBase>\n  implements AfterContentInit, ControlValueAccessor\n{\n  /** Selected value for the radio group. */\n  private _value: any = null;\n\n  /** The HTML name attribute applied to radio buttons in this group. */\n  private _name: string = `mat-radio-group-${nextUniqueId++}`;\n\n  /** The currently selected radio button. Should match value. */\n  private _selected: T | null = null;\n\n  /** Whether the `value` has been set to its initial value. */\n  private _isInitialized: boolean = false;\n\n  /** Whether the labels should appear after or before the radio-buttons. Defaults to 'after' */\n  private _labelPosition: 'before' | 'after' = 'after';\n\n  /** Whether the radio group is disabled. */\n  private _disabled: boolean = false;\n\n  /** Whether the radio group is required. */\n  private _required: boolean = false;\n\n  /** The method to be called in order to update ngModel */\n  _controlValueAccessorChangeFn: (value: any) => void = () => {};\n\n  /**\n   * onTouch function registered via registerOnTouch (ControlValueAccessor).\n   * @docs-private\n   */\n  onTouched: () => any = () => {};\n\n  /**\n   * Event emitted when the group value changes.\n   * Change events are only emitted when the value changes due to user interaction with\n   * a radio button (the same behavior as `<input type-\"radio\">`).\n   */\n  @Output() readonly change: EventEmitter<MatRadioChange> = new EventEmitter<MatRadioChange>();\n\n  /** Child radio buttons. */\n  abstract _radios: QueryList<T>;\n\n  /** Theme color for all of the radio buttons in the group. */\n  @Input() color: ThemePalette;\n\n  /** Name of the radio button group. All radio buttons inside this group will use this name. */\n  @Input()\n  get name(): string {\n    return this._name;\n  }\n  set name(value: string) {\n    this._name = value;\n    this._updateRadioButtonNames();\n  }\n\n  /** Whether the labels should appear after or before the radio-buttons. Defaults to 'after' */\n  @Input()\n  get labelPosition(): 'before' | 'after' {\n    return this._labelPosition;\n  }\n  set labelPosition(v) {\n    this._labelPosition = v === 'before' ? 'before' : 'after';\n    this._markRadiosForCheck();\n  }\n\n  /**\n   * Value for the radio-group. Should equal the value of the selected radio button if there is\n   * a corresponding radio button with a matching value. If there is not such a corresponding\n   * radio button, this value persists to be applied in case a new radio button is added with a\n   * matching value.\n   */\n  @Input()\n  get value(): any {\n    return this._value;\n  }\n  set value(newValue: any) {\n    if (this._value !== newValue) {\n      // Set this before proceeding to ensure no circular loop occurs with selection.\n      this._value = newValue;\n\n      this._updateSelectedRadioFromValue();\n      this._checkSelectedRadioButton();\n    }\n  }\n\n  _checkSelectedRadioButton() {\n    if (this._selected && !this._selected.checked) {\n      this._selected.checked = true;\n    }\n  }\n\n  /**\n   * The currently selected radio button. If set to a new radio button, the radio group value\n   * will be updated to match the new selected button.\n   */\n  @Input()\n  get selected() {\n    return this._selected;\n  }\n  set selected(selected: T | null) {\n    this._selected = selected;\n    this.value = selected ? selected.value : null;\n    this._checkSelectedRadioButton();\n  }\n\n  /** Whether the radio group is disabled */\n  @Input()\n  get disabled(): boolean {\n    return this._disabled;\n  }\n  set disabled(value: BooleanInput) {\n    this._disabled = coerceBooleanProperty(value);\n    this._markRadiosForCheck();\n  }\n\n  /** Whether the radio group is required */\n  @Input()\n  get required(): boolean {\n    return this._required;\n  }\n  set required(value: BooleanInput) {\n    this._required = coerceBooleanProperty(value);\n    this._markRadiosForCheck();\n  }\n\n  constructor(private _changeDetector: ChangeDetectorRef) {}\n\n  /**\n   * Initialize properties once content children are available.\n   * This allows us to propagate relevant attributes to associated buttons.\n   */\n  ngAfterContentInit() {\n    // Mark this component as initialized in AfterContentInit because the initial value can\n    // possibly be set by NgModel on MatRadioGroup, and it is possible that the OnInit of the\n    // NgModel occurs *after* the OnInit of the MatRadioGroup.\n    this._isInitialized = true;\n  }\n\n  /**\n   * Mark this group as being \"touched\" (for ngModel). Meant to be called by the contained\n   * radio buttons upon their blur.\n   */\n  _touch() {\n    if (this.onTouched) {\n      this.onTouched();\n    }\n  }\n\n  private _updateRadioButtonNames(): void {\n    if (this._radios) {\n      this._radios.forEach(radio => {\n        radio.name = this.name;\n        radio._markForCheck();\n      });\n    }\n  }\n\n  /** Updates the `selected` radio button from the internal _value state. */\n  private _updateSelectedRadioFromValue(): void {\n    // If the value already matches the selected radio, do nothing.\n    const isAlreadySelected = this._selected !== null && this._selected.value === this._value;\n\n    if (this._radios && !isAlreadySelected) {\n      this._selected = null;\n      this._radios.forEach(radio => {\n        radio.checked = this.value === radio.value;\n        if (radio.checked) {\n          this._selected = radio;\n        }\n      });\n    }\n  }\n\n  /** Dispatch change event with current selection and group value. */\n  _emitChangeEvent(): void {\n    if (this._isInitialized) {\n      this.change.emit(new MatRadioChange(this._selected!, this._value));\n    }\n  }\n\n  _markRadiosForCheck() {\n    if (this._radios) {\n      this._radios.forEach(radio => radio._markForCheck());\n    }\n  }\n\n  /**\n   * Sets the model value. Implemented as part of ControlValueAccessor.\n   * @param value\n   */\n  writeValue(value: any) {\n    this.value = value;\n    this._changeDetector.markForCheck();\n  }\n\n  /**\n   * Registers a callback to be triggered when the model value changes.\n   * Implemented as part of ControlValueAccessor.\n   * @param fn Callback to be registered.\n   */\n  registerOnChange(fn: (value: any) => void) {\n    this._controlValueAccessorChangeFn = fn;\n  }\n\n  /**\n   * Registers a callback to be triggered when the control is touched.\n   * Implemented as part of ControlValueAccessor.\n   * @param fn Callback to be registered.\n   */\n  registerOnTouched(fn: any) {\n    this.onTouched = fn;\n  }\n\n  /**\n   * Sets the disabled state of the control. Implemented as a part of ControlValueAccessor.\n   * @param isDisabled Whether the control should be disabled.\n   */\n  setDisabledState(isDisabled: boolean) {\n    this.disabled = isDisabled;\n    this._changeDetector.markForCheck();\n  }\n}\n\n/**\n * A group of radio buttons. May contain one or more `<mat-radio-button>` elements.\n */\n@Directive({\n  selector: 'mat-radio-group',\n  exportAs: 'matRadioGroup',\n  providers: [\n    MAT_RADIO_GROUP_CONTROL_VALUE_ACCESSOR,\n    {provide: MAT_RADIO_GROUP, useExisting: MatRadioGroup},\n  ],\n  host: {\n    'role': 'radiogroup',\n    'class': 'mat-radio-group',\n  },\n})\nexport class MatRadioGroup extends _MatRadioGroupBase<MatRadioButton> {\n  @ContentChildren(forwardRef(() => MatRadioButton), {descendants: true})\n  _radios: QueryList<MatRadioButton>;\n}\n\n// Boilerplate for applying mixins to MatRadioButton.\n/** @docs-private */\nabstract class MatRadioButtonBase {\n  // Since the disabled property is manually defined for the MatRadioButton and isn't set up in\n  // the mixin base class. To be able to use the tabindex mixin, a disabled property must be\n  // defined to properly work.\n  abstract disabled: boolean;\n  constructor(public _elementRef: ElementRef) {}\n}\n\nconst _MatRadioButtonMixinBase = mixinDisableRipple(mixinTabIndex(MatRadioButtonBase));\n\n/**\n * Base class with all of the `MatRadioButton` functionality.\n * @docs-private\n */\n@Directive()\nexport abstract class _MatRadioButtonBase\n  extends _MatRadioButtonMixinBase\n  implements OnInit, AfterViewInit, DoCheck, OnDestroy, CanDisableRipple, HasTabIndex\n{\n  private _uniqueId: string = `mat-radio-${++nextUniqueId}`;\n\n  /** The unique ID for the radio button. */\n  @Input() id: string = this._uniqueId;\n\n  /** Analog to HTML 'name' attribute used to group radios for unique selection. */\n  @Input() name: string;\n\n  /** Used to set the 'aria-label' attribute on the underlying input element. */\n  @Input('aria-label') ariaLabel: string;\n\n  /** The 'aria-labelledby' attribute takes precedence as the element's text alternative. */\n  @Input('aria-labelledby') ariaLabelledby: string;\n\n  /** The 'aria-describedby' attribute is read after the element's label and field type. */\n  @Input('aria-describedby') ariaDescribedby: string;\n\n  /** Whether this radio button is checked. */\n  @Input()\n  get checked(): boolean {\n    return this._checked;\n  }\n  set checked(value: BooleanInput) {\n    const newCheckedState = coerceBooleanProperty(value);\n    if (this._checked !== newCheckedState) {\n      this._checked = newCheckedState;\n      if (newCheckedState && this.radioGroup && this.radioGroup.value !== this.value) {\n        this.radioGroup.selected = this;\n      } else if (!newCheckedState && this.radioGroup && this.radioGroup.value === this.value) {\n        // When unchecking the selected radio button, update the selected radio\n        // property on the group.\n        this.radioGroup.selected = null;\n      }\n\n      if (newCheckedState) {\n        // Notify all radio buttons with the same name to un-check.\n        this._radioDispatcher.notify(this.id, this.name);\n      }\n      this._changeDetector.markForCheck();\n    }\n  }\n\n  /** The value of this radio button. */\n  @Input()\n  get value(): any {\n    return this._value;\n  }\n  set value(value: any) {\n    if (this._value !== value) {\n      this._value = value;\n      if (this.radioGroup !== null) {\n        if (!this.checked) {\n          // Update checked when the value changed to match the radio group's value\n          this.checked = this.radioGroup.value === value;\n        }\n        if (this.checked) {\n          this.radioGroup.selected = this;\n        }\n      }\n    }\n  }\n\n  /** Whether the label should appear after or before the radio button. Defaults to 'after' */\n  @Input()\n  get labelPosition(): 'before' | 'after' {\n    return this._labelPosition || (this.radioGroup && this.radioGroup.labelPosition) || 'after';\n  }\n  set labelPosition(value) {\n    this._labelPosition = value;\n  }\n  private _labelPosition: 'before' | 'after';\n\n  /** Whether the radio button is disabled. */\n  @Input()\n  get disabled(): boolean {\n    return this._disabled || (this.radioGroup !== null && this.radioGroup.disabled);\n  }\n  set disabled(value: BooleanInput) {\n    this._setDisabled(coerceBooleanProperty(value));\n  }\n\n  /** Whether the radio button is required. */\n  @Input()\n  get required(): boolean {\n    return this._required || (this.radioGroup && this.radioGroup.required);\n  }\n  set required(value: BooleanInput) {\n    this._required = coerceBooleanProperty(value);\n  }\n\n  /** Theme color of the radio button. */\n  @Input()\n  get color(): ThemePalette {\n    // As per Material design specifications the selection control radio should use the accent color\n    // palette by default. https://material.io/guidelines/components/selection-controls.html\n    return (\n      this._color ||\n      (this.radioGroup && this.radioGroup.color) ||\n      (this._providerOverride && this._providerOverride.color) ||\n      'accent'\n    );\n  }\n  set color(newValue: ThemePalette) {\n    this._color = newValue;\n  }\n  private _color: ThemePalette;\n\n  /**\n   * Event emitted when the checked state of this radio button changes.\n   * Change events are only emitted when the value changes due to user interaction with\n   * the radio button (the same behavior as `<input type-\"radio\">`).\n   */\n  @Output() readonly change: EventEmitter<MatRadioChange> = new EventEmitter<MatRadioChange>();\n\n  /** The parent radio group. May or may not be present. */\n  radioGroup: _MatRadioGroupBase<_MatRadioButtonBase>;\n\n  /** ID of the native input element inside `<mat-radio-button>` */\n  get inputId(): string {\n    return `${this.id || this._uniqueId}-input`;\n  }\n\n  /** Whether this radio is checked. */\n  private _checked: boolean = false;\n\n  /** Whether this radio is disabled. */\n  private _disabled: boolean;\n\n  /** Whether this radio is required. */\n  private _required: boolean;\n\n  /** Value assigned to this radio. */\n  private _value: any = null;\n\n  /** Unregister function for _radioDispatcher */\n  private _removeUniqueSelectionListener: () => void = () => {};\n\n  /** Previous value of the input's tabindex. */\n  private _previousTabIndex: number | undefined;\n\n  /** The native `<input type=radio>` element */\n  @ViewChild('input') _inputElement: ElementRef<HTMLInputElement>;\n\n  /** Whether animations are disabled. */\n  _noopAnimations: boolean;\n\n  constructor(\n    radioGroup: _MatRadioGroupBase<_MatRadioButtonBase>,\n    elementRef: ElementRef,\n    protected _changeDetector: ChangeDetectorRef,\n    private _focusMonitor: FocusMonitor,\n    private _radioDispatcher: UniqueSelectionDispatcher,\n    animationMode?: string,\n    private _providerOverride?: MatRadioDefaultOptions,\n    tabIndex?: string,\n  ) {\n    super(elementRef);\n\n    // Assertions. Ideally these should be stripped out by the compiler.\n    // TODO(jelbourn): Assert that there's no name binding AND a parent radio group.\n    this.radioGroup = radioGroup;\n    this._noopAnimations = animationMode === 'NoopAnimations';\n\n    if (tabIndex) {\n      this.tabIndex = coerceNumberProperty(tabIndex, 0);\n    }\n\n    this._removeUniqueSelectionListener = _radioDispatcher.listen((id: string, name: string) => {\n      if (id !== this.id && name === this.name) {\n        this.checked = false;\n      }\n    });\n  }\n\n  /** Focuses the radio button. */\n  focus(options?: FocusOptions, origin?: FocusOrigin): void {\n    if (origin) {\n      this._focusMonitor.focusVia(this._inputElement, origin, options);\n    } else {\n      this._inputElement.nativeElement.focus(options);\n    }\n  }\n\n  /**\n   * Marks the radio button as needing checking for change detection.\n   * This method is exposed because the parent radio group will directly\n   * update bound properties of the radio button.\n   */\n  _markForCheck() {\n    // When group value changes, the button will not be notified. Use `markForCheck` to explicit\n    // update radio button's status\n    this._changeDetector.markForCheck();\n  }\n\n  ngOnInit() {\n    if (this.radioGroup) {\n      // If the radio is inside a radio group, determine if it should be checked\n      this.checked = this.radioGroup.value === this._value;\n\n      if (this.checked) {\n        this.radioGroup.selected = this;\n      }\n\n      // Copy name from parent radio group\n      this.name = this.radioGroup.name;\n    }\n  }\n\n  ngDoCheck(): void {\n    this._updateTabIndex();\n  }\n\n  ngAfterViewInit() {\n    this._updateTabIndex();\n    this._focusMonitor.monitor(this._elementRef, true).subscribe(focusOrigin => {\n      if (!focusOrigin && this.radioGroup) {\n        this.radioGroup._touch();\n      }\n    });\n  }\n\n  ngOnDestroy() {\n    this._focusMonitor.stopMonitoring(this._elementRef);\n    this._removeUniqueSelectionListener();\n  }\n\n  /** Dispatch change event with current value. */\n  private _emitChangeEvent(): void {\n    this.change.emit(new MatRadioChange(this, this._value));\n  }\n\n  _isRippleDisabled() {\n    return this.disableRipple || this.disabled;\n  }\n\n  _onInputClick(event: Event) {\n    // We have to stop propagation for click events on the visual hidden input element.\n    // By default, when a user clicks on a label element, a generated click event will be\n    // dispatched on the associated input element. Since we are using a label element as our\n    // root container, the click event on the `radio-button` will be executed twice.\n    // The real click event will bubble up, and the generated click event also tries to bubble up.\n    // This will lead to multiple click events.\n    // Preventing bubbling for the second event will solve that issue.\n    event.stopPropagation();\n  }\n\n  /** Triggered when the radio button receives an interaction from the user. */\n  _onInputInteraction(event: Event) {\n    // We always have to stop propagation on the change event.\n    // Otherwise the change event, from the input element, will bubble up and\n    // emit its event object to the `change` output.\n    event.stopPropagation();\n\n    if (!this.checked && !this.disabled) {\n      const groupValueChanged = this.radioGroup && this.value !== this.radioGroup.value;\n      this.checked = true;\n      this._emitChangeEvent();\n\n      if (this.radioGroup) {\n        this.radioGroup._controlValueAccessorChangeFn(this.value);\n        if (groupValueChanged) {\n          this.radioGroup._emitChangeEvent();\n        }\n      }\n    }\n  }\n\n  /** Sets the disabled state and marks for check if a change occurred. */\n  protected _setDisabled(value: boolean) {\n    if (this._disabled !== value) {\n      this._disabled = value;\n      this._changeDetector.markForCheck();\n    }\n  }\n\n  /** Gets the tabindex for the underlying input element. */\n  private _updateTabIndex() {\n    const group = this.radioGroup;\n    let value: number;\n\n    // Implement a roving tabindex if the button is inside a group. For most cases this isn't\n    // necessary, because the browser handles the tab order for inputs inside a group automatically,\n    // but we need an explicitly higher tabindex for the selected button in order for things like\n    // the focus trap to pick it up correctly.\n    if (!group || !group.selected || this.disabled) {\n      value = this.tabIndex;\n    } else {\n      value = group.selected === this ? this.tabIndex : -1;\n    }\n\n    if (value !== this._previousTabIndex) {\n      // We have to set the tabindex directly on the DOM node, because it depends on\n      // the selected state which is prone to \"changed after checked errors\".\n      const input: HTMLInputElement | undefined = this._inputElement?.nativeElement;\n\n      if (input) {\n        input.setAttribute('tabindex', value + '');\n        this._previousTabIndex = value;\n      }\n    }\n  }\n}\n\n/**\n * A Material design radio-button. Typically placed inside of `<mat-radio-group>` elements.\n */\n@Component({\n  selector: 'mat-radio-button',\n  templateUrl: 'radio.html',\n  styleUrls: ['radio.css'],\n  inputs: ['disableRipple', 'tabIndex'],\n  encapsulation: ViewEncapsulation.None,\n  exportAs: 'matRadioButton',\n  host: {\n    'class': 'mat-radio-button',\n    '[class.mat-radio-checked]': 'checked',\n    '[class.mat-radio-disabled]': 'disabled',\n    '[class._mat-animation-noopable]': '_noopAnimations',\n    '[class.mat-primary]': 'color === \"primary\"',\n    '[class.mat-accent]': 'color === \"accent\"',\n    '[class.mat-warn]': 'color === \"warn\"',\n    // Needs to be removed since it causes some a11y issues (see #21266).\n    '[attr.tabindex]': 'null',\n    '[attr.id]': 'id',\n    '[attr.aria-label]': 'null',\n    '[attr.aria-labelledby]': 'null',\n    '[attr.aria-describedby]': 'null',\n    // Note: under normal conditions focus shouldn't land on this element, however it may be\n    // programmatically set, for example inside of a focus trap, in this case we want to forward\n    // the focus to the native element.\n    '(focus)': '_inputElement.nativeElement.focus()',\n  },\n  changeDetection: ChangeDetectionStrategy.OnPush,\n})\nexport class MatRadioButton extends _MatRadioButtonBase {\n  constructor(\n    @Optional() @Inject(MAT_RADIO_GROUP) radioGroup: MatRadioGroup,\n    elementRef: ElementRef,\n    changeDetector: ChangeDetectorRef,\n    focusMonitor: FocusMonitor,\n    radioDispatcher: UniqueSelectionDispatcher,\n    @Optional() @Inject(ANIMATION_MODULE_TYPE) animationMode?: string,\n    @Optional()\n    @Inject(MAT_RADIO_DEFAULT_OPTIONS)\n    providerOverride?: MatRadioDefaultOptions,\n    @Attribute('tabindex') tabIndex?: string,\n  ) {\n    super(\n      radioGroup,\n      elementRef,\n      changeDetector,\n      focusMonitor,\n      radioDispatcher,\n      animationMode,\n      providerOverride,\n      tabIndex,\n    );\n  }\n}\n",null,"<!-- TODO(jelbourn): render the radio on either side of the content -->\n<!-- TODO(mtlin): Evaluate trade-offs of using native radio vs. cost of additional bindings. -->\n<label [attr.for]=\"inputId\" class=\"mat-radio-label\" #label>\n  <!-- The actual 'radio' part of the control. -->\n  <span class=\"mat-radio-container\">\n    <span class=\"mat-radio-outer-circle\"></span>\n    <span class=\"mat-radio-inner-circle\"></span>\n    <input #input class=\"mat-radio-input\" type=\"radio\"\n        [id]=\"inputId\"\n        [checked]=\"checked\"\n        [disabled]=\"disabled\"\n        [attr.name]=\"name\"\n        [attr.value]=\"value\"\n        [required]=\"required\"\n        [attr.aria-label]=\"ariaLabel\"\n        [attr.aria-labelledby]=\"ariaLabelledby\"\n        [attr.aria-describedby]=\"ariaDescribedby\"\n        (change)=\"_onInputInteraction($event)\"\n        (click)=\"_onInputClick($event)\">\n\n    <!-- The ripple comes after the input so that we can target it with a CSS\n         sibling selector when the input is focused. -->\n    <span mat-ripple class=\"mat-radio-ripple mat-focus-indicator\"\n         [matRippleTrigger]=\"label\"\n         [matRippleDisabled]=\"_isRippleDisabled()\"\n         [matRippleCentered]=\"true\"\n         [matRippleRadius]=\"20\"\n         [matRippleAnimation]=\"{enterDuration: _noopAnimations ? 0 : 150}\">\n\n      <span class=\"mat-ripple-element mat-radio-persistent-ripple\"></span>\n    </span>\n  </span>\n\n  <!-- The label content for radio control. -->\n  <span class=\"mat-radio-label-content\" [class.mat-radio-label-before]=\"labelPosition == 'before'\">\n    <!-- Add an invisible span so JAWS can read the label -->\n    <span style=\"display:none\">&nbsp;</span>\n    <ng-content></ng-content>\n  </span>\n</label>\n","import {Component, ChangeDetectionStrategy} from '@angular/core';\nimport {ReactiveFormsModule} from '@angular/forms';\nimport {MatRadioModule} from '@angular/material/radio';\nimport {LayoutEditorMetadata} from '@anglr/dynamic/layout-editor';\nimport {CastPipesModule, HostDisplayBlockStyle} from '@anglr/common';\nimport {FormPipesModule} from '@anglr/common/forms';\nimport {FormComponent, FormComponentBase, FormComponentControlSAPipe} from '@anglr/dynamic/form';\n\nimport {MaterialRadioLayoutMetadataLoader} from './radio.metadata';\nimport {MaterialRadioComponentOptions} from './radio.options';\n\n/**\n * Component used for displaying material radio\n */\n@Component(\n{\n    selector: 'material-radio',\n    templateUrl: 'radio.component.html',\n    styles: [HostDisplayBlockStyle],\n    standalone: true,\n    changeDetection: ChangeDetectionStrategy.OnPush,\n    imports:\n    [\n        FormPipesModule,\n        CastPipesModule,\n        FormComponentControlSAPipe,\n        ReactiveFormsModule,\n        MatRadioModule,\n    ]\n})\n@LayoutEditorMetadata(MaterialRadioLayoutMetadataLoader)\nexport class MaterialRadioSAComponent extends FormComponentBase<MaterialRadioComponentOptions> implements FormComponent<MaterialRadioComponentOptions>\n{}","<mat-radio-group [formControl]=\"options?.controlName|formComponentControl:_control|asFormControl|asRequired\">\n    <mat-radio-button value=\"1\">{{options?.options}}</mat-radio-button>\n</mat-radio-group>","import {ComponentStylingExtension} from '@anglr/dynamic/layout';\n\nimport {MaterialRadioSAComponent} from './radio.component';\n\n\nexport default MaterialRadioSAComponent;\n\nexport const extensions = [ComponentStylingExtension];","import {ElementRef, Injector} from '@angular/core';\nimport {PromiseOr} from '@jscrpt/common';\n\nimport {DynamicItem, DynamicItemExtension, DynamicItemMetadata} from '../interfaces';\n\n/**\n * Dynamic item extension base class\n */\nexport abstract class DynamicItemExtensionBase<TOptions = unknown, TInstance extends DynamicItem = any> implements DynamicItemExtension<TOptions, TInstance>\n{\n    //######################### protected fields #########################\n\n    /**\n     * Injector from extended component\n     */\n    protected _injector?: Injector;\n\n    /**\n     * Element that could be extended\n     */\n    protected _element?: ElementRef<HTMLElement>;\n\n    /**\n     * Options that stores extension and component data\n     */\n    protected _options?: TOptions;\n\n    /**\n     * Instance of dynamic item that is being extended\n     */\n    protected _instance?: TInstance;\n\n    /**\n     * Indication whether was extension initialized\n     */\n    protected _initialized: boolean = false;\n\n    //######################### constructor #########################\n    constructor(protected _metadata: DynamicItemMetadata)\n    {\n    }\n\n    //######################### public methods - implementation of DynamicItemExtension #########################\n\n    /**\n     * @inheritdoc\n     */\n    public async initialize(injector: Injector, element: ElementRef<HTMLElement>, instance: TInstance): Promise<void>\n    {\n        this._initialized = true;\n\n        this._injector = injector;\n        this._element = element;\n        this._instance = instance;\n\n        await this._onInit();\n    }\n\n    /**\n     * @inheritdoc\n     */\n    public async optionsChange(options: TOptions): Promise<void>\n    {\n        this._options = options;\n\n        if(!this._initialized)\n        {\n            return;\n        }\n\n        await this._onOptionsChange();\n    }\n\n    /**\n     * @inheritdoc\n     */\n    public destroy(): void\n    {\n        this._onDestroy();\n    }\n\n    //######################### protected methods #########################\n\n    /**\n     * Called on initialization of component\n     */\n    protected _onInit(): PromiseOr<void>\n    {\n    }\n\n    /**\n     * Called on change of options of component\n     */\n    protected _onOptionsChange(): PromiseOr<void>\n    {\n    }\n\n    /**\n     * Called on destruction of component\n     */\n    protected _onDestroy(): void\n    {\n    }\n}","import {Inject, Optional, Pipe} from '@angular/core';\nimport {AbstractControl, FormControl} from '@angular/forms';\nimport {Logger, LOGGER} from '@anglr/common';\nimport {isBlank} from '@jscrpt/common';\n\n/**\n * Tries to convert `AbstractControl` to `FormControl`\n */\n@Pipe({name: 'asFormControl'})\nexport class AsFormControlPipe\n{\n    //######################### constructors #########################\n    constructor(@Optional() @Inject(LOGGER) private _logger?: Logger)\n    {\n    }\n\n    //######################### public methods - implementation of PipeTransform #########################\n\n    /**\n     * Allows casting of `AbstractControl` to `FormControl`\n     * @param value - `AbstractControl` to be cast to `FormControl`\n     * @param _valueHash - Parameter that can be used to change value, indicates that pipe input value has changed\n     */\n    public transform<TModel>(value: AbstractControl<TModel>|null|undefined, _valueHash?: any): FormControl<TModel>|null\n    {\n        if(isBlank(value))\n        {\n            return null;\n        }\n\n        if(value instanceof FormControl)\n        {\n            return value as FormControl<TModel>;\n        }\n\n        this._logger?.warn('Failed to cast AbstractControl to FormControl');\n\n        return null;\n    }\n}","import {Pipe, PipeTransform} from '@angular/core';\n\n/**\n * Transforms type to required from nullable or undefined type\n */\n@Pipe({name: 'asRequired'})\nexport class AsRequiredTypePipe<TType> implements PipeTransform\n{\n    /**\n     * Transforms type to required from nullable or undefined type\n     * @param value - Value to be transformed\n     * @param defaultValue - Default value to be used if undefined or null\n     * @param _valueHash - Parameter that can be used to change value, indicates that pipe input value has changed\n     */\n    public transform(value: TType|null|undefined, defaultValue: TType, _valueHash?: any): TType\n    {\n        return value ?? defaultValue;\n    }\n}"],"names":["FormComponentBase","LayoutComponentBase","constructor","_changeDetector","_element","_injector","_control","_logger","super","i0","FORM_COMPONENT_CONTROL","LOGGER","features","FormComponentControlType","InjectionToken","FormComponentControlSAPipe","transform","controlName","parentControl","defaultControlType","this","_getControlForType","control","get","warn","name","type","FormArray","FormGroup","FormControl","pure","standalone","LayoutEditorMetadata","metadataLoader","DynamicClassMetadata","_extensions","_initialized","destroyed","element","extensionsOptions","options","ngOnDestroy","ext","destroy","_onDestroy","ngOnInit","_onInit","_onOptionsSet","extension","initialize","ngOnChanges","changes","nameof","optionsChange","_onOptionsChange","registerExtensions","extensions","invalidateVisuals","detectChanges","ComponentStylingExtension","DynamicItemExtensionBase","_applyStyling","_options","style","nativeElement","isPresent","lastCssClass","classList","remove","cssClass","add","margin","bottom","marginBottom","right","marginRight","top","marginTop","left","marginLeft","padding","paddingBottom","paddingRight","paddingTop","paddingLeft","textStyling","fontSize","fontWeight","toString","MatRadioModule","MatRippleModule","MatCommonModule","MaterialRadioLayoutMetadataLoader","MaterialRadioLayoutEditorMetadata","UniqueSelectionDispatcher","_listeners","notify","id","listener","listen","push","filter","registered","MAT_RADIO_DEFAULT_OPTIONS","providedIn","factory","color","nextUniqueId","MAT_RADIO_GROUP_CONTROL_VALUE_ACCESSOR","provide","NG_VALUE_ACCESSOR","useExisting","forwardRef","MatRadioGroup","multi","MatRadioChange","source","value","MAT_RADIO_GROUP","_MatRadioGroupBase","_value","_name","_selected","_isInitialized","_labelPosition","_disabled","_required","_controlValueAccessorChangeFn","onTouched","change","EventEmitter","_updateRadioButtonNames","labelPosition","v","_markRadiosForCheck","newValue","_updateSelectedRadioFromValue","_checkSelectedRadioButton","checked","selected","disabled","coerceBooleanProperty","required","ngAfterContentInit","_touch","_radios","forEach","radio","_markForCheck","isAlreadySelected","_emitChangeEvent","emit","writeValue","markForCheck","registerOnChange","fn","registerOnTouched","setDisabledState","isDisabled","MatRadioButton","_MatRadioButtonMixinBase","mixinDisableRipple","mixinTabIndex","_elementRef","_MatRadioButtonBase","radioGroup","elementRef","_focusMonitor","_radioDispatcher","animationMode","_providerOverride","tabIndex","_uniqueId","_checked","_removeUniqueSelectionListener","_noopAnimations","coerceNumberProperty","newCheckedState","_setDisabled","_color","inputId","focus","origin","focusVia","_inputElement","ngDoCheck","_updateTabIndex","ngAfterViewInit","monitor","subscribe","focusOrigin","stopMonitoring","_isRippleDisabled","disableRipple","_onInputClick","event","stopPropagation","_onInputInteraction","groupValueChanged","group","_previousTabIndex","input","setAttribute","changeDetector","focusMonitor","radioDispatcher","providerOverride","ANIMATION_MODULE_TYPE","i3","MaterialRadioSAComponent","t","selectors","decls","vars","consts","template","FormPipesModule","i1","CastPipesModule","i2","ReactiveFormsModule","i4","styles","changeDetection","_metadata","injector","instance","_instance","AsFormControlPipe","_valueHash","isBlank","AsRequiredTypePipe","defaultValue"],"sourceRoot":""}