{"version":3,"file":"4130.chunk.53322aed3d3bd7e056d8.js","mappings":"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","sources":["webpack://ng-universal-demo/../../../../src/cdk/a11y/key-manager/list-key-manager.ts","webpack://ng-universal-demo/../../../../packages/core/src/render3/instructions/class_map_interpolation.ts","webpack://ng-universal-demo/../../../../src/material/core/common-behaviors/disable-ripple.ts","webpack://ng-universal-demo/../../../../src/material/core/common-behaviors/disabled.ts","webpack://ng-universal-demo/../../../../src/material/core/common-behaviors/tabindex.ts","webpack://ng-universal-demo/../../../../src/material/core/option/optgroup.ts","webpack://ng-universal-demo/../../../../src/material/core/option/optgroup.html","webpack://ng-universal-demo/../../../../src/material/core/option/option-parent.ts","webpack://ng-universal-demo/../../../../src/material/core/selection/pseudo-checkbox/pseudo-checkbox.ts","webpack://ng-universal-demo/../../../../src/material/core/option/option.ts","webpack://ng-universal-demo/../../../../src/material/core/option/option.html","webpack://ng-universal-demo/../../../../src/material/core/selection/pseudo-checkbox/pseudo-checkbox-module.ts","webpack://ng-universal-demo/../../../../src/material/core/option/index.ts","webpack://ng-universal-demo/../../../../src/material/select/module.ts","webpack://ng-universal-demo/../../../../src/cdk/a11y/aria-describer/aria-reference.ts","webpack://ng-universal-demo/../../../../src/cdk/a11y/key-manager/activedescendant-key-manager.ts","webpack://ng-universal-demo/../../../../src/cdk/collections/selection-model.ts","webpack://ng-universal-demo/../../../../src/material/select/select-animations.ts","webpack://ng-universal-demo/../../../../src/cdk/a11y/live-announcer/live-announcer-tokens.ts","webpack://ng-universal-demo/../../../../src/cdk/a11y/live-announcer/live-announcer.ts","webpack://ng-universal-demo/../../../../src/material/select/select.ts","webpack://ng-universal-demo/../../../../src/material/select/select.html"],"sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {QueryList} from '@angular/core';\nimport {Subject, Subscription} from 'rxjs';\nimport {\n  UP_ARROW,\n  DOWN_ARROW,\n  LEFT_ARROW,\n  RIGHT_ARROW,\n  TAB,\n  A,\n  Z,\n  ZERO,\n  NINE,\n  hasModifierKey,\n  HOME,\n  END,\n  PAGE_UP,\n  PAGE_DOWN,\n} from '@angular/cdk/keycodes';\nimport {debounceTime, filter, map, tap} from 'rxjs/operators';\n\n/** This interface is for items that can be passed to a ListKeyManager. */\nexport interface ListKeyManagerOption {\n  /** Whether the option is disabled. */\n  disabled?: boolean;\n\n  /** Gets the label for this option. */\n  getLabel?(): string;\n}\n\n/** Modifier keys handled by the ListKeyManager. */\nexport type ListKeyManagerModifierKey = 'altKey' | 'ctrlKey' | 'metaKey' | 'shiftKey';\n\n/**\n * This class manages keyboard events for selectable lists. If you pass it a query list\n * of items, it will set the active item correctly when arrow events occur.\n */\nexport class ListKeyManager<T extends ListKeyManagerOption> {\n  private _activeItemIndex = -1;\n  private _activeItem: T | null = null;\n  private _wrap = false;\n  private readonly _letterKeyStream = new Subject<string>();\n  private _typeaheadSubscription = Subscription.EMPTY;\n  private _itemChangesSubscription?: Subscription;\n  private _vertical = true;\n  private _horizontal: 'ltr' | 'rtl' | null;\n  private _allowedModifierKeys: ListKeyManagerModifierKey[] = [];\n  private _homeAndEnd = false;\n  private _pageUpAndDown = {enabled: false, delta: 10};\n\n  /**\n   * Predicate function that can be used to check whether an item should be skipped\n   * by the key manager. By default, disabled items are skipped.\n   */\n  private _skipPredicateFn = (item: T) => item.disabled;\n\n  // Buffer for the letters that the user has pressed when the typeahead option is turned on.\n  private _pressedLetters: string[] = [];\n\n  constructor(private _items: QueryList<T> | T[]) {\n    // We allow for the items to be an array because, in some cases, the consumer may\n    // not have access to a QueryList of the items they want to manage (e.g. when the\n    // items aren't being collected via `ViewChildren` or `ContentChildren`).\n    if (_items instanceof QueryList) {\n      this._itemChangesSubscription = _items.changes.subscribe((newItems: QueryList<T>) => {\n        if (this._activeItem) {\n          const itemArray = newItems.toArray();\n          const newIndex = itemArray.indexOf(this._activeItem);\n\n          if (newIndex > -1 && newIndex !== this._activeItemIndex) {\n            this._activeItemIndex = newIndex;\n          }\n        }\n      });\n    }\n  }\n\n  /**\n   * Stream that emits any time the TAB key is pressed, so components can react\n   * when focus is shifted off of the list.\n   */\n  readonly tabOut = new Subject<void>();\n\n  /** Stream that emits whenever the active item of the list manager changes. */\n  readonly change = new Subject<number>();\n\n  /**\n   * Sets the predicate function that determines which items should be skipped by the\n   * list key manager.\n   * @param predicate Function that determines whether the given item should be skipped.\n   */\n  skipPredicate(predicate: (item: T) => boolean): this {\n    this._skipPredicateFn = predicate;\n    return this;\n  }\n\n  /**\n   * Configures wrapping mode, which determines whether the active item will wrap to\n   * the other end of list when there are no more items in the given direction.\n   * @param shouldWrap Whether the list should wrap when reaching the end.\n   */\n  withWrap(shouldWrap = true): this {\n    this._wrap = shouldWrap;\n    return this;\n  }\n\n  /**\n   * Configures whether the key manager should be able to move the selection vertically.\n   * @param enabled Whether vertical selection should be enabled.\n   */\n  withVerticalOrientation(enabled: boolean = true): this {\n    this._vertical = enabled;\n    return this;\n  }\n\n  /**\n   * Configures the key manager to move the selection horizontally.\n   * Passing in `null` will disable horizontal movement.\n   * @param direction Direction in which the selection can be moved.\n   */\n  withHorizontalOrientation(direction: 'ltr' | 'rtl' | null): this {\n    this._horizontal = direction;\n    return this;\n  }\n\n  /**\n   * Modifier keys which are allowed to be held down and whose default actions will be prevented\n   * as the user is pressing the arrow keys. Defaults to not allowing any modifier keys.\n   */\n  withAllowedModifierKeys(keys: ListKeyManagerModifierKey[]): this {\n    this._allowedModifierKeys = keys;\n    return this;\n  }\n\n  /**\n   * Turns on typeahead mode which allows users to set the active item by typing.\n   * @param debounceInterval Time to wait after the last keystroke before setting the active item.\n   */\n  withTypeAhead(debounceInterval: number = 200): this {\n    if (\n      (typeof ngDevMode === 'undefined' || ngDevMode) &&\n      this._items.length &&\n      this._items.some(item => typeof item.getLabel !== 'function')\n    ) {\n      throw Error('ListKeyManager items in typeahead mode must implement the `getLabel` method.');\n    }\n\n    this._typeaheadSubscription.unsubscribe();\n\n    // Debounce the presses of non-navigational keys, collect the ones that correspond to letters\n    // and convert those letters back into a string. Afterwards find the first item that starts\n    // with that string and select it.\n    this._typeaheadSubscription = this._letterKeyStream\n      .pipe(\n        tap(letter => this._pressedLetters.push(letter)),\n        debounceTime(debounceInterval),\n        filter(() => this._pressedLetters.length > 0),\n        map(() => this._pressedLetters.join('')),\n      )\n      .subscribe(inputString => {\n        const items = this._getItemsArray();\n\n        // Start at 1 because we want to start searching at the item immediately\n        // following the current active item.\n        for (let i = 1; i < items.length + 1; i++) {\n          const index = (this._activeItemIndex + i) % items.length;\n          const item = items[index];\n\n          if (\n            !this._skipPredicateFn(item) &&\n            item.getLabel!().toUpperCase().trim().indexOf(inputString) === 0\n          ) {\n            this.setActiveItem(index);\n            break;\n          }\n        }\n\n        this._pressedLetters = [];\n      });\n\n    return this;\n  }\n\n  /** Cancels the current typeahead sequence. */\n  cancelTypeahead(): this {\n    this._pressedLetters = [];\n    return this;\n  }\n\n  /**\n   * Configures the key manager to activate the first and last items\n   * respectively when the Home or End key is pressed.\n   * @param enabled Whether pressing the Home or End key activates the first/last item.\n   */\n  withHomeAndEnd(enabled: boolean = true): this {\n    this._homeAndEnd = enabled;\n    return this;\n  }\n\n  /**\n   * Configures the key manager to activate every 10th, configured or first/last element in up/down direction\n   * respectively when the Page-Up or Page-Down key is pressed.\n   * @param enabled Whether pressing the Page-Up or Page-Down key activates the first/last item.\n   * @param delta Whether pressing the Home or End key activates the first/last item.\n   */\n  withPageUpDown(enabled: boolean = true, delta: number = 10): this {\n    this._pageUpAndDown = {enabled, delta};\n    return this;\n  }\n\n  /**\n   * Sets the active item to the item at the index specified.\n   * @param index The index of the item to be set as active.\n   */\n  setActiveItem(index: number): void;\n\n  /**\n   * Sets the active item to the specified item.\n   * @param item The item to be set as active.\n   */\n  setActiveItem(item: T): void;\n\n  setActiveItem(item: any): void {\n    const previousActiveItem = this._activeItem;\n\n    this.updateActiveItem(item);\n\n    if (this._activeItem !== previousActiveItem) {\n      this.change.next(this._activeItemIndex);\n    }\n  }\n\n  /**\n   * Sets the active item depending on the key event passed in.\n   * @param event Keyboard event to be used for determining which element should be active.\n   */\n  onKeydown(event: KeyboardEvent): void {\n    const keyCode = event.keyCode;\n    const modifiers: ListKeyManagerModifierKey[] = ['altKey', 'ctrlKey', 'metaKey', 'shiftKey'];\n    const isModifierAllowed = modifiers.every(modifier => {\n      return !event[modifier] || this._allowedModifierKeys.indexOf(modifier) > -1;\n    });\n\n    switch (keyCode) {\n      case TAB:\n        this.tabOut.next();\n        return;\n\n      case DOWN_ARROW:\n        if (this._vertical && isModifierAllowed) {\n          this.setNextItemActive();\n          break;\n        } else {\n          return;\n        }\n\n      case UP_ARROW:\n        if (this._vertical && isModifierAllowed) {\n          this.setPreviousItemActive();\n          break;\n        } else {\n          return;\n        }\n\n      case RIGHT_ARROW:\n        if (this._horizontal && isModifierAllowed) {\n          this._horizontal === 'rtl' ? this.setPreviousItemActive() : this.setNextItemActive();\n          break;\n        } else {\n          return;\n        }\n\n      case LEFT_ARROW:\n        if (this._horizontal && isModifierAllowed) {\n          this._horizontal === 'rtl' ? this.setNextItemActive() : this.setPreviousItemActive();\n          break;\n        } else {\n          return;\n        }\n\n      case HOME:\n        if (this._homeAndEnd && isModifierAllowed) {\n          this.setFirstItemActive();\n          break;\n        } else {\n          return;\n        }\n\n      case END:\n        if (this._homeAndEnd && isModifierAllowed) {\n          this.setLastItemActive();\n          break;\n        } else {\n          return;\n        }\n\n      case PAGE_UP:\n        if (this._pageUpAndDown.enabled && isModifierAllowed) {\n          const targetIndex = this._activeItemIndex - this._pageUpAndDown.delta;\n          this._setActiveItemByIndex(targetIndex > 0 ? targetIndex : 0, 1);\n          break;\n        } else {\n          return;\n        }\n\n      case PAGE_DOWN:\n        if (this._pageUpAndDown.enabled && isModifierAllowed) {\n          const targetIndex = this._activeItemIndex + this._pageUpAndDown.delta;\n          const itemsLength = this._getItemsArray().length;\n          this._setActiveItemByIndex(targetIndex < itemsLength ? targetIndex : itemsLength - 1, -1);\n          break;\n        } else {\n          return;\n        }\n\n      default:\n        if (isModifierAllowed || hasModifierKey(event, 'shiftKey')) {\n          // Attempt to use the `event.key` which also maps it to the user's keyboard language,\n          // otherwise fall back to resolving alphanumeric characters via the keyCode.\n          if (event.key && event.key.length === 1) {\n            this._letterKeyStream.next(event.key.toLocaleUpperCase());\n          } else if ((keyCode >= A && keyCode <= Z) || (keyCode >= ZERO && keyCode <= NINE)) {\n            this._letterKeyStream.next(String.fromCharCode(keyCode));\n          }\n        }\n\n        // Note that we return here, in order to avoid preventing\n        // the default action of non-navigational keys.\n        return;\n    }\n\n    this._pressedLetters = [];\n    event.preventDefault();\n  }\n\n  /** Index of the currently active item. */\n  get activeItemIndex(): number | null {\n    return this._activeItemIndex;\n  }\n\n  /** The active item. */\n  get activeItem(): T | null {\n    return this._activeItem;\n  }\n\n  /** Gets whether the user is currently typing into the manager using the typeahead feature. */\n  isTyping(): boolean {\n    return this._pressedLetters.length > 0;\n  }\n\n  /** Sets the active item to the first enabled item in the list. */\n  setFirstItemActive(): void {\n    this._setActiveItemByIndex(0, 1);\n  }\n\n  /** Sets the active item to the last enabled item in the list. */\n  setLastItemActive(): void {\n    this._setActiveItemByIndex(this._items.length - 1, -1);\n  }\n\n  /** Sets the active item to the next enabled item in the list. */\n  setNextItemActive(): void {\n    this._activeItemIndex < 0 ? this.setFirstItemActive() : this._setActiveItemByDelta(1);\n  }\n\n  /** Sets the active item to a previous enabled item in the list. */\n  setPreviousItemActive(): void {\n    this._activeItemIndex < 0 && this._wrap\n      ? this.setLastItemActive()\n      : this._setActiveItemByDelta(-1);\n  }\n\n  /**\n   * Allows setting the active without any other effects.\n   * @param index Index of the item to be set as active.\n   */\n  updateActiveItem(index: number): void;\n\n  /**\n   * Allows setting the active item without any other effects.\n   * @param item Item to be set as active.\n   */\n  updateActiveItem(item: T): void;\n\n  updateActiveItem(item: any): void {\n    const itemArray = this._getItemsArray();\n    const index = typeof item === 'number' ? item : itemArray.indexOf(item);\n    const activeItem = itemArray[index];\n\n    // Explicitly check for `null` and `undefined` because other falsy values are valid.\n    this._activeItem = activeItem == null ? null : activeItem;\n    this._activeItemIndex = index;\n  }\n\n  /** Cleans up the key manager. */\n  destroy() {\n    this._typeaheadSubscription.unsubscribe();\n    this._itemChangesSubscription?.unsubscribe();\n    this._letterKeyStream.complete();\n    this.tabOut.complete();\n    this.change.complete();\n    this._pressedLetters = [];\n  }\n\n  /**\n   * This method sets the active item, given a list of items and the delta between the\n   * currently active item and the new active item. It will calculate differently\n   * depending on whether wrap mode is turned on.\n   */\n  private _setActiveItemByDelta(delta: -1 | 1): void {\n    this._wrap ? this._setActiveInWrapMode(delta) : this._setActiveInDefaultMode(delta);\n  }\n\n  /**\n   * Sets the active item properly given \"wrap\" mode. In other words, it will continue to move\n   * down the list until it finds an item that is not disabled, and it will wrap if it\n   * encounters either end of the list.\n   */\n  private _setActiveInWrapMode(delta: -1 | 1): void {\n    const items = this._getItemsArray();\n\n    for (let i = 1; i <= items.length; i++) {\n      const index = (this._activeItemIndex + delta * i + items.length) % items.length;\n      const item = items[index];\n\n      if (!this._skipPredicateFn(item)) {\n        this.setActiveItem(index);\n        return;\n      }\n    }\n  }\n\n  /**\n   * Sets the active item properly given the default mode. In other words, it will\n   * continue to move down the list until it finds an item that is not disabled. If\n   * it encounters either end of the list, it will stop and not wrap.\n   */\n  private _setActiveInDefaultMode(delta: -1 | 1): void {\n    this._setActiveItemByIndex(this._activeItemIndex + delta, delta);\n  }\n\n  /**\n   * Sets the active item to the first enabled item starting at the index specified. If the\n   * item is disabled, it will move in the fallbackDelta direction until it either\n   * finds an enabled item or encounters the end of the list.\n   */\n  private _setActiveItemByIndex(index: number, fallbackDelta: -1 | 1): void {\n    const items = this._getItemsArray();\n\n    if (!items[index]) {\n      return;\n    }\n\n    while (this._skipPredicateFn(items[index])) {\n      index += fallbackDelta;\n\n      if (!items[index]) {\n        return;\n      }\n    }\n\n    this.setActiveItem(index);\n  }\n\n  /** Returns the items as an array. */\n  private _getItemsArray(): T[] {\n    return this._items instanceof QueryList ? this._items.toArray() : this._items;\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {keyValueArraySet} from '../../util/array_utils';\nimport {getLView} from '../state';\nimport {interpolation1, interpolation2, interpolation3, interpolation4, interpolation5, interpolation6, interpolation7, interpolation8, interpolationV} from './interpolation';\nimport {checkStylingMap, classStringParser} from './styling';\n\n\n\n/**\n *\n * Update an interpolated class on an element with single bound value surrounded by text.\n *\n * Used when the value passed to a property has 1 interpolated value in it:\n *\n * ```html\n * <div class=\"prefix{{v0}}suffix\"></div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * ɵɵclassMapInterpolate1('prefix', v0, 'suffix');\n * ```\n *\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @codeGenApi\n */\nexport function ɵɵclassMapInterpolate1(prefix: string, v0: any, suffix: string): void {\n  const lView = getLView();\n  const interpolatedValue = interpolation1(lView, prefix, v0, suffix);\n  checkStylingMap(keyValueArraySet, classStringParser, interpolatedValue, true);\n}\n\n/**\n *\n * Update an interpolated class on an element with 2 bound values surrounded by text.\n *\n * Used when the value passed to a property has 2 interpolated values in it:\n *\n * ```html\n * <div class=\"prefix{{v0}}-{{v1}}suffix\"></div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * ɵɵclassMapInterpolate2('prefix', v0, '-', v1, 'suffix');\n * ```\n *\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @codeGenApi\n */\nexport function ɵɵclassMapInterpolate2(\n    prefix: string, v0: any, i0: string, v1: any, suffix: string): void {\n  const lView = getLView();\n  const interpolatedValue = interpolation2(lView, prefix, v0, i0, v1, suffix);\n  checkStylingMap(keyValueArraySet, classStringParser, interpolatedValue, true);\n}\n\n/**\n *\n * Update an interpolated class on an element with 3 bound values surrounded by text.\n *\n * Used when the value passed to a property has 3 interpolated values in it:\n *\n * ```html\n * <div class=\"prefix{{v0}}-{{v1}}-{{v2}}suffix\"></div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * ɵɵclassMapInterpolate3(\n * 'prefix', v0, '-', v1, '-', v2, 'suffix');\n * ```\n *\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param i1 Static value used for concatenation only.\n * @param v2 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @codeGenApi\n */\nexport function ɵɵclassMapInterpolate3(\n    prefix: string, v0: any, i0: string, v1: any, i1: string, v2: any, suffix: string): void {\n  const lView = getLView();\n  const interpolatedValue = interpolation3(lView, prefix, v0, i0, v1, i1, v2, suffix);\n  checkStylingMap(keyValueArraySet, classStringParser, interpolatedValue, true);\n}\n\n/**\n *\n * Update an interpolated class on an element with 4 bound values surrounded by text.\n *\n * Used when the value passed to a property has 4 interpolated values in it:\n *\n * ```html\n * <div class=\"prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}suffix\"></div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * ɵɵclassMapInterpolate4(\n * 'prefix', v0, '-', v1, '-', v2, '-', v3, 'suffix');\n * ```\n *\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param i1 Static value used for concatenation only.\n * @param v2 Value checked for change.\n * @param i2 Static value used for concatenation only.\n * @param v3 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @codeGenApi\n */\nexport function ɵɵclassMapInterpolate4(\n    prefix: string, v0: any, i0: string, v1: any, i1: string, v2: any, i2: string, v3: any,\n    suffix: string): void {\n  const lView = getLView();\n  const interpolatedValue = interpolation4(lView, prefix, v0, i0, v1, i1, v2, i2, v3, suffix);\n  checkStylingMap(keyValueArraySet, classStringParser, interpolatedValue, true);\n}\n\n/**\n *\n * Update an interpolated class on an element with 5 bound values surrounded by text.\n *\n * Used when the value passed to a property has 5 interpolated values in it:\n *\n * ```html\n * <div class=\"prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}-{{v4}}suffix\"></div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * ɵɵclassMapInterpolate5(\n * 'prefix', v0, '-', v1, '-', v2, '-', v3, '-', v4, 'suffix');\n * ```\n *\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param i1 Static value used for concatenation only.\n * @param v2 Value checked for change.\n * @param i2 Static value used for concatenation only.\n * @param v3 Value checked for change.\n * @param i3 Static value used for concatenation only.\n * @param v4 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @codeGenApi\n */\nexport function ɵɵclassMapInterpolate5(\n    prefix: string, v0: any, i0: string, v1: any, i1: string, v2: any, i2: string, v3: any,\n    i3: string, v4: any, suffix: string): void {\n  const lView = getLView();\n  const interpolatedValue =\n      interpolation5(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, suffix);\n  checkStylingMap(keyValueArraySet, classStringParser, interpolatedValue, true);\n}\n\n/**\n *\n * Update an interpolated class on an element with 6 bound values surrounded by text.\n *\n * Used when the value passed to a property has 6 interpolated values in it:\n *\n * ```html\n * <div class=\"prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}-{{v4}}-{{v5}}suffix\"></div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * ɵɵclassMapInterpolate6(\n *    'prefix', v0, '-', v1, '-', v2, '-', v3, '-', v4, '-', v5, 'suffix');\n * ```\n *\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param i1 Static value used for concatenation only.\n * @param v2 Value checked for change.\n * @param i2 Static value used for concatenation only.\n * @param v3 Value checked for change.\n * @param i3 Static value used for concatenation only.\n * @param v4 Value checked for change.\n * @param i4 Static value used for concatenation only.\n * @param v5 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @codeGenApi\n */\nexport function ɵɵclassMapInterpolate6(\n    prefix: string, v0: any, i0: string, v1: any, i1: string, v2: any, i2: string, v3: any,\n    i3: string, v4: any, i4: string, v5: any, suffix: string): void {\n  const lView = getLView();\n  const interpolatedValue =\n      interpolation6(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, suffix);\n  checkStylingMap(keyValueArraySet, classStringParser, interpolatedValue, true);\n}\n\n/**\n *\n * Update an interpolated class on an element with 7 bound values surrounded by text.\n *\n * Used when the value passed to a property has 7 interpolated values in it:\n *\n * ```html\n * <div class=\"prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}-{{v4}}-{{v5}}-{{v6}}suffix\"></div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * ɵɵclassMapInterpolate7(\n *    'prefix', v0, '-', v1, '-', v2, '-', v3, '-', v4, '-', v5, '-', v6, 'suffix');\n * ```\n *\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param i1 Static value used for concatenation only.\n * @param v2 Value checked for change.\n * @param i2 Static value used for concatenation only.\n * @param v3 Value checked for change.\n * @param i3 Static value used for concatenation only.\n * @param v4 Value checked for change.\n * @param i4 Static value used for concatenation only.\n * @param v5 Value checked for change.\n * @param i5 Static value used for concatenation only.\n * @param v6 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @codeGenApi\n */\nexport function ɵɵclassMapInterpolate7(\n    prefix: string, v0: any, i0: string, v1: any, i1: string, v2: any, i2: string, v3: any,\n    i3: string, v4: any, i4: string, v5: any, i5: string, v6: any, suffix: string): void {\n  const lView = getLView();\n  const interpolatedValue =\n      interpolation7(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, suffix);\n  checkStylingMap(keyValueArraySet, classStringParser, interpolatedValue, true);\n}\n\n/**\n *\n * Update an interpolated class on an element with 8 bound values surrounded by text.\n *\n * Used when the value passed to a property has 8 interpolated values in it:\n *\n * ```html\n * <div class=\"prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}-{{v4}}-{{v5}}-{{v6}}-{{v7}}suffix\"></div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * ɵɵclassMapInterpolate8(\n *  'prefix', v0, '-', v1, '-', v2, '-', v3, '-', v4, '-', v5, '-', v6, '-', v7, 'suffix');\n * ```\n *\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param i1 Static value used for concatenation only.\n * @param v2 Value checked for change.\n * @param i2 Static value used for concatenation only.\n * @param v3 Value checked for change.\n * @param i3 Static value used for concatenation only.\n * @param v4 Value checked for change.\n * @param i4 Static value used for concatenation only.\n * @param v5 Value checked for change.\n * @param i5 Static value used for concatenation only.\n * @param v6 Value checked for change.\n * @param i6 Static value used for concatenation only.\n * @param v7 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @codeGenApi\n */\nexport function ɵɵclassMapInterpolate8(\n    prefix: string, v0: any, i0: string, v1: any, i1: string, v2: any, i2: string, v3: any,\n    i3: string, v4: any, i4: string, v5: any, i5: string, v6: any, i6: string, v7: any,\n    suffix: string): void {\n  const lView = getLView();\n  const interpolatedValue = interpolation8(\n      lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, i6, v7, suffix);\n  checkStylingMap(keyValueArraySet, classStringParser, interpolatedValue, true);\n}\n\n/**\n * Update an interpolated class on an element with 9 or more bound values surrounded by text.\n *\n * Used when the number of interpolated values exceeds 8.\n *\n * ```html\n * <div\n *  class=\"prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}-{{v4}}-{{v5}}-{{v6}}-{{v7}}-{{v8}}-{{v9}}suffix\"></div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * ɵɵclassMapInterpolateV(\n *  ['prefix', v0, '-', v1, '-', v2, '-', v3, '-', v4, '-', v5, '-', v6, '-', v7, '-', v9,\n *  'suffix']);\n * ```\n *.\n * @param values The collection of values and the strings in-between those values, beginning with\n * a string prefix and ending with a string suffix.\n * (e.g. `['prefix', value0, '-', value1, '-', value2, ..., value99, 'suffix']`)\n * @codeGenApi\n */\nexport function ɵɵclassMapInterpolateV(values: any[]): void {\n  const lView = getLView();\n  const interpolatedValue = interpolationV(lView, values);\n  checkStylingMap(keyValueArraySet, classStringParser, interpolatedValue, true);\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {coerceBooleanProperty} from '@angular/cdk/coercion';\nimport {AbstractConstructor, Constructor} from './constructor';\n\n/** @docs-private */\nexport interface CanDisableRipple {\n  /** Whether ripples are disabled. */\n  disableRipple: boolean;\n}\n\ntype CanDisableRippleCtor = Constructor<CanDisableRipple> & AbstractConstructor<CanDisableRipple>;\n\n/** Mixin to augment a directive with a `disableRipple` property. */\nexport function mixinDisableRipple<T extends AbstractConstructor<{}>>(\n  base: T,\n): CanDisableRippleCtor & T;\nexport function mixinDisableRipple<T extends Constructor<{}>>(base: T): CanDisableRippleCtor & T {\n  return class extends base {\n    private _disableRipple: boolean = false;\n\n    /** Whether the ripple effect is disabled or not. */\n    get disableRipple(): boolean {\n      return this._disableRipple;\n    }\n    set disableRipple(value: any) {\n      this._disableRipple = coerceBooleanProperty(value);\n    }\n\n    constructor(...args: any[]) {\n      super(...args);\n    }\n  };\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {coerceBooleanProperty} from '@angular/cdk/coercion';\nimport {AbstractConstructor, Constructor} from './constructor';\n\n/** @docs-private */\nexport interface CanDisable {\n  /** Whether the component is disabled. */\n  disabled: boolean;\n}\n\ntype CanDisableCtor = Constructor<CanDisable> & AbstractConstructor<CanDisable>;\n\n/** Mixin to augment a directive with a `disabled` property. */\nexport function mixinDisabled<T extends AbstractConstructor<{}>>(base: T): CanDisableCtor & T;\nexport function mixinDisabled<T extends Constructor<{}>>(base: T): CanDisableCtor & T {\n  return class extends base {\n    private _disabled: boolean = false;\n\n    get disabled(): boolean {\n      return this._disabled;\n    }\n    set disabled(value: any) {\n      this._disabled = coerceBooleanProperty(value);\n    }\n\n    constructor(...args: any[]) {\n      super(...args);\n    }\n  };\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {coerceNumberProperty} from '@angular/cdk/coercion';\nimport {Constructor, AbstractConstructor} from './constructor';\nimport {CanDisable} from './disabled';\n\n/** @docs-private */\nexport interface HasTabIndex {\n  /** Tabindex of the component. */\n  tabIndex: number;\n\n  /** Tabindex to which to fall back to if no value is set. */\n  defaultTabIndex: number;\n}\n\ntype HasTabIndexCtor = Constructor<HasTabIndex> & AbstractConstructor<HasTabIndex>;\n\n/** Mixin to augment a directive with a `tabIndex` property. */\nexport function mixinTabIndex<T extends AbstractConstructor<CanDisable>>(\n  base: T,\n  defaultTabIndex?: number,\n): HasTabIndexCtor & T;\nexport function mixinTabIndex<T extends Constructor<CanDisable>>(\n  base: T,\n  defaultTabIndex = 0,\n): HasTabIndexCtor & T {\n  return class extends base implements HasTabIndex {\n    private _tabIndex: number = defaultTabIndex;\n    defaultTabIndex = defaultTabIndex;\n\n    get tabIndex(): number {\n      return this.disabled ? -1 : this._tabIndex;\n    }\n    set tabIndex(value: number) {\n      // If the specified tabIndex value is null or undefined, fall back to the default value.\n      this._tabIndex = value != null ? coerceNumberProperty(value) : this.defaultTabIndex;\n    }\n\n    constructor(...args: any[]) {\n      super(...args);\n    }\n  };\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {\n  Component,\n  ViewEncapsulation,\n  ChangeDetectionStrategy,\n  Input,\n  Inject,\n  Optional,\n  InjectionToken,\n  booleanAttribute,\n} from '@angular/core';\nimport {MatOptionParentComponent, MAT_OPTION_PARENT_COMPONENT} from './option-parent';\n\n// Notes on the accessibility pattern used for `mat-optgroup`.\n// The option group has two different \"modes\": regular and inert. The regular mode uses the\n// recommended a11y pattern which has `role=\"group\"` on the group element with `aria-labelledby`\n// pointing to the label. This works for `mat-select`, but it seems to hit a bug for autocomplete\n// under VoiceOver where the group doesn't get read out at all. The bug appears to be that if\n// there's __any__ a11y-related attribute on the group (e.g. `role` or `aria-labelledby`),\n// VoiceOver on Safari won't read it out.\n// We've introduced the `inert` mode as a workaround. Under this mode, all a11y attributes are\n// removed from the group, and we get the screen reader to read out the group label by mirroring it\n// inside an invisible element in the option. This is sub-optimal, because the screen reader will\n// repeat the group label on each navigation, whereas the default pattern only reads the group when\n// the user enters a new group. The following alternate approaches were considered:\n// 1. Reading out the group label using the `LiveAnnouncer` solves the problem, but we can't control\n//    when the text will be read out so sometimes it comes in too late or never if the user\n//    navigates quickly.\n// 2. `<mat-option aria-describedby=\"groupLabel\"` - This works on Safari, but VoiceOver in Chrome\n//    won't read out the description at all.\n// 3. `<mat-option aria-labelledby=\"optionLabel groupLabel\"` - This works on Chrome, but Safari\n//     doesn't read out the text at all. Furthermore, on\n\n// Counter for unique group ids.\nlet _uniqueOptgroupIdCounter = 0;\n\n/**\n * Injection token that can be used to reference instances of `MatOptgroup`. It serves as\n * alternative token to the actual `MatOptgroup` class which could cause unnecessary\n * retention of the class and its component metadata.\n */\nexport const MAT_OPTGROUP = new InjectionToken<MatOptgroup>('MatOptgroup');\n\n/**\n * Component that is used to group instances of `mat-option`.\n */\n@Component({\n  selector: 'mat-optgroup',\n  exportAs: 'matOptgroup',\n  templateUrl: 'optgroup.html',\n  encapsulation: ViewEncapsulation.None,\n  changeDetection: ChangeDetectionStrategy.OnPush,\n  styleUrls: ['optgroup.css'],\n  host: {\n    'class': 'mat-mdc-optgroup',\n    '[attr.role]': '_inert ? null : \"group\"',\n    '[attr.aria-disabled]': '_inert ? null : disabled.toString()',\n    '[attr.aria-labelledby]': '_inert ? null : _labelId',\n  },\n  providers: [{provide: MAT_OPTGROUP, useExisting: MatOptgroup}],\n})\nexport class MatOptgroup {\n  /** Label for the option group. */\n  @Input() label: string;\n\n  /** whether the option group is disabled. */\n  @Input({transform: booleanAttribute}) disabled: boolean = false;\n\n  /** Unique id for the underlying label. */\n  _labelId: string = `mat-optgroup-label-${_uniqueOptgroupIdCounter++}`;\n\n  /** Whether the group is in inert a11y mode. */\n  _inert: boolean;\n\n  constructor(@Inject(MAT_OPTION_PARENT_COMPONENT) @Optional() parent?: MatOptionParentComponent) {\n    this._inert = parent?.inertGroups ?? false;\n  }\n}\n","<span\n  class=\"mat-mdc-optgroup-label\"\n  role=\"presentation\"\n  [class.mdc-list-item--disabled]=\"disabled\"\n  [id]=\"_labelId\">\n  <span class=\"mdc-list-item__primary-text\">{{ label }} <ng-content></ng-content></span>\n</span>\n\n<ng-content select=\"mat-option, ng-container\"></ng-content>\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {InjectionToken} from '@angular/core';\n\n/**\n * Describes a parent component that manages a list of options.\n * Contains properties that the options can inherit.\n * @docs-private\n */\nexport interface MatOptionParentComponent {\n  disableRipple?: boolean;\n  multiple?: boolean;\n  inertGroups?: boolean;\n  hideSingleSelectionIndicator?: boolean;\n}\n\n/**\n * Injection token used to provide the parent component to options.\n */\nexport const MAT_OPTION_PARENT_COMPONENT = new InjectionToken<MatOptionParentComponent>(\n  'MAT_OPTION_PARENT_COMPONENT',\n);\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {\n  Component,\n  ViewEncapsulation,\n  Input,\n  ChangeDetectionStrategy,\n  Inject,\n  Optional,\n} from '@angular/core';\nimport {ANIMATION_MODULE_TYPE} from '@angular/platform-browser/animations';\n\n/**\n * Possible states for a pseudo checkbox.\n * @docs-private\n */\nexport type MatPseudoCheckboxState = 'unchecked' | 'checked' | 'indeterminate';\n\n/**\n * Component that shows a simplified checkbox without including any kind of \"real\" checkbox.\n * Meant to be used when the checkbox is purely decorative and a large number of them will be\n * included, such as for the options in a multi-select. Uses no SVGs or complex animations.\n * Note that theming is meant to be handled by the parent element, e.g.\n * `mat-primary .mat-pseudo-checkbox`.\n *\n * Note that this component will be completely invisible to screen-reader users. This is *not*\n * interchangeable with `<mat-checkbox>` and should *not* be used if the user would directly\n * interact with the checkbox. The pseudo-checkbox should only be used as an implementation detail\n * of more complex components that appropriately handle selected / checked state.\n * @docs-private\n */\n@Component({\n  encapsulation: ViewEncapsulation.None,\n  changeDetection: ChangeDetectionStrategy.OnPush,\n  selector: 'mat-pseudo-checkbox',\n  styleUrls: ['pseudo-checkbox.css'],\n  template: '',\n  host: {\n    'class': 'mat-pseudo-checkbox',\n    '[class.mat-pseudo-checkbox-indeterminate]': 'state === \"indeterminate\"',\n    '[class.mat-pseudo-checkbox-checked]': 'state === \"checked\"',\n    '[class.mat-pseudo-checkbox-disabled]': 'disabled',\n    '[class.mat-pseudo-checkbox-minimal]': 'appearance === \"minimal\"',\n    '[class.mat-pseudo-checkbox-full]': 'appearance === \"full\"',\n    '[class._mat-animation-noopable]': '_animationMode === \"NoopAnimations\"',\n  },\n})\nexport class MatPseudoCheckbox {\n  /** Display state of the checkbox. */\n  @Input() state: MatPseudoCheckboxState = 'unchecked';\n\n  /** Whether the checkbox is disabled. */\n  @Input() disabled: boolean = false;\n\n  /**\n   * Appearance of the pseudo checkbox. Default appearance of 'full' renders a checkmark/mixedmark\n   * indicator inside a square box. 'minimal' appearance only renders the checkmark/mixedmark.\n   */\n  @Input() appearance: 'minimal' | 'full' = 'full';\n\n  constructor(@Optional() @Inject(ANIMATION_MODULE_TYPE) public _animationMode?: string) {}\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {FocusableOption, FocusOrigin} from '@angular/cdk/a11y';\nimport {ENTER, hasModifierKey, SPACE} from '@angular/cdk/keycodes';\nimport {\n  Component,\n  ViewEncapsulation,\n  ChangeDetectionStrategy,\n  ElementRef,\n  ChangeDetectorRef,\n  Optional,\n  Inject,\n  AfterViewChecked,\n  OnDestroy,\n  Input,\n  Output,\n  EventEmitter,\n  QueryList,\n  ViewChild,\n  booleanAttribute,\n} from '@angular/core';\nimport {Subject} from 'rxjs';\nimport {MAT_OPTGROUP, MatOptgroup} from './optgroup';\nimport {MatOptionParentComponent, MAT_OPTION_PARENT_COMPONENT} from './option-parent';\n\n/**\n * Option IDs need to be unique across components, so this counter exists outside of\n * the component definition.\n */\nlet _uniqueIdCounter = 0;\n\n/** Event object emitted by MatOption when selected or deselected. */\nexport class MatOptionSelectionChange<T = any> {\n  constructor(\n    /** Reference to the option that emitted the event. */\n    public source: MatOption<T>,\n    /** Whether the change in the option's value was a result of a user action. */\n    public isUserInput = false,\n  ) {}\n}\n\n/**\n * Single option inside of a `<mat-select>` element.\n */\n@Component({\n  selector: 'mat-option',\n  exportAs: 'matOption',\n  host: {\n    'role': 'option',\n    '[class.mdc-list-item--selected]': 'selected',\n    '[class.mat-mdc-option-multiple]': 'multiple',\n    '[class.mat-mdc-option-active]': 'active',\n    '[class.mdc-list-item--disabled]': 'disabled',\n    '[id]': 'id',\n    // Set aria-selected to false for non-selected items and true for selected items. Conform to\n    // [WAI ARIA Listbox authoring practices guide](\n    //  https://www.w3.org/WAI/ARIA/apg/patterns/listbox/), \"If any options are selected, each\n    // selected option has either aria-selected or aria-checked  set to true. All options that are\n    // selectable but not selected have either aria-selected or aria-checked set to false.\" Align\n    // aria-selected implementation of Chips and List components.\n    //\n    // Set `aria-selected=\"false\"` on not-selected listbox options to fix VoiceOver announcing\n    // every option as \"selected\" (#21491).\n    '[attr.aria-selected]': 'selected',\n    '[attr.aria-disabled]': 'disabled.toString()',\n    '(click)': '_selectViaInteraction()',\n    '(keydown)': '_handleKeydown($event)',\n    'class': 'mat-mdc-option mdc-list-item',\n  },\n  styleUrls: ['option.css'],\n  templateUrl: 'option.html',\n  encapsulation: ViewEncapsulation.None,\n  changeDetection: ChangeDetectionStrategy.OnPush,\n})\nexport class MatOption<T = any> implements FocusableOption, AfterViewChecked, OnDestroy {\n  private _selected = false;\n  private _active = false;\n  private _disabled = false;\n  private _mostRecentViewValue = '';\n\n  /** Whether the wrapping component is in multiple selection mode. */\n  get multiple() {\n    return this._parent && this._parent.multiple;\n  }\n\n  /** Whether or not the option is currently selected. */\n  get selected(): boolean {\n    return this._selected;\n  }\n\n  /** The form value of the option. */\n  @Input() value: T;\n\n  /** The unique ID of the option. */\n  @Input() id: string = `mat-option-${_uniqueIdCounter++}`;\n\n  /** Whether the option is disabled. */\n  @Input({transform: booleanAttribute})\n  get disabled(): boolean {\n    return (this.group && this.group.disabled) || this._disabled;\n  }\n  set disabled(value: boolean) {\n    this._disabled = value;\n  }\n\n  /** Whether ripples for the option are disabled. */\n  get disableRipple(): boolean {\n    return !!(this._parent && this._parent.disableRipple);\n  }\n\n  /** Whether to display checkmark for single-selection. */\n  get hideSingleSelectionIndicator(): boolean {\n    return !!(this._parent && this._parent.hideSingleSelectionIndicator);\n  }\n\n  /** Event emitted when the option is selected or deselected. */\n  // tslint:disable-next-line:no-output-on-prefix\n  @Output() readonly onSelectionChange = new EventEmitter<MatOptionSelectionChange<T>>();\n\n  /** Element containing the option's text. */\n  @ViewChild('text', {static: true}) _text: ElementRef<HTMLElement> | undefined;\n\n  /** Emits when the state of the option changes and any parents have to be notified. */\n  readonly _stateChanges = new Subject<void>();\n\n  constructor(\n    private _element: ElementRef<HTMLElement>,\n    public _changeDetectorRef: ChangeDetectorRef,\n    @Optional() @Inject(MAT_OPTION_PARENT_COMPONENT) private _parent: MatOptionParentComponent,\n    @Optional() @Inject(MAT_OPTGROUP) public group: MatOptgroup,\n  ) {}\n\n  /**\n   * Whether or not the option is currently active and ready to be selected.\n   * An active option displays styles as if it is focused, but the\n   * focus is actually retained somewhere else. This comes in handy\n   * for components like autocomplete where focus must remain on the input.\n   */\n  get active(): boolean {\n    return this._active;\n  }\n\n  /**\n   * The displayed value of the option. It is necessary to show the selected option in the\n   * select's trigger.\n   */\n  get viewValue(): string {\n    // TODO(kara): Add input property alternative for node envs.\n    return (this._text?.nativeElement.textContent || '').trim();\n  }\n\n  /** Selects the option. */\n  select(emitEvent = true): void {\n    if (!this._selected) {\n      this._selected = true;\n      this._changeDetectorRef.markForCheck();\n\n      if (emitEvent) {\n        this._emitSelectionChangeEvent();\n      }\n    }\n  }\n\n  /** Deselects the option. */\n  deselect(emitEvent = true): void {\n    if (this._selected) {\n      this._selected = false;\n      this._changeDetectorRef.markForCheck();\n\n      if (emitEvent) {\n        this._emitSelectionChangeEvent();\n      }\n    }\n  }\n\n  /** Sets focus onto this option. */\n  focus(_origin?: FocusOrigin, options?: FocusOptions): void {\n    // Note that we aren't using `_origin`, but we need to keep it because some internal consumers\n    // use `MatOption` in a `FocusKeyManager` and we need it to match `FocusableOption`.\n    const element = this._getHostElement();\n\n    if (typeof element.focus === 'function') {\n      element.focus(options);\n    }\n  }\n\n  /**\n   * This method sets display styles on the option to make it appear\n   * active. This is used by the ActiveDescendantKeyManager so key\n   * events will display the proper options as active on arrow key events.\n   */\n  setActiveStyles(): void {\n    if (!this._active) {\n      this._active = true;\n      this._changeDetectorRef.markForCheck();\n    }\n  }\n\n  /**\n   * This method removes display styles on the option that made it appear\n   * active. This is used by the ActiveDescendantKeyManager so key\n   * events will display the proper options as active on arrow key events.\n   */\n  setInactiveStyles(): void {\n    if (this._active) {\n      this._active = false;\n      this._changeDetectorRef.markForCheck();\n    }\n  }\n\n  /** Gets the label to be used when determining whether the option should be focused. */\n  getLabel(): string {\n    return this.viewValue;\n  }\n\n  /** Ensures the option is selected when activated from the keyboard. */\n  _handleKeydown(event: KeyboardEvent): void {\n    if ((event.keyCode === ENTER || event.keyCode === SPACE) && !hasModifierKey(event)) {\n      this._selectViaInteraction();\n\n      // Prevent the page from scrolling down and form submits.\n      event.preventDefault();\n    }\n  }\n\n  /**\n   * `Selects the option while indicating the selection came from the user. Used to\n   * determine if the select's view -> model callback should be invoked.`\n   */\n  _selectViaInteraction(): void {\n    if (!this.disabled) {\n      this._selected = this.multiple ? !this._selected : true;\n      this._changeDetectorRef.markForCheck();\n      this._emitSelectionChangeEvent(true);\n    }\n  }\n\n  /** Returns the correct tabindex for the option depending on disabled state. */\n  // This method is only used by `MatLegacyOption`. Keeping it here to avoid breaking the types.\n  // That's because `MatLegacyOption` use `MatOption` type in a few places such as\n  // `MatOptionSelectionChange`. It is safe to delete this when `MatLegacyOption` is deleted.\n  _getTabIndex(): string {\n    return this.disabled ? '-1' : '0';\n  }\n\n  /** Gets the host DOM element. */\n  _getHostElement(): HTMLElement {\n    return this._element.nativeElement;\n  }\n\n  ngAfterViewChecked() {\n    // Since parent components could be using the option's label to display the selected values\n    // (e.g. `mat-select`) and they don't have a way of knowing if the option's label has changed\n    // we have to check for changes in the DOM ourselves and dispatch an event. These checks are\n    // relatively cheap, however we still limit them only to selected options in order to avoid\n    // hitting the DOM too often.\n    if (this._selected) {\n      const viewValue = this.viewValue;\n\n      if (viewValue !== this._mostRecentViewValue) {\n        if (this._mostRecentViewValue) {\n          this._stateChanges.next();\n        }\n\n        this._mostRecentViewValue = viewValue;\n      }\n    }\n  }\n\n  ngOnDestroy() {\n    this._stateChanges.complete();\n  }\n\n  /** Emits the selection change event. */\n  private _emitSelectionChangeEvent(isUserInput = false): void {\n    this.onSelectionChange.emit(new MatOptionSelectionChange<T>(this, isUserInput));\n  }\n}\n\n/**\n * Counts the amount of option group labels that precede the specified option.\n * @param optionIndex Index of the option at which to start counting.\n * @param options Flat list of all of the options.\n * @param optionGroups Flat list of all of the option groups.\n * @docs-private\n */\nexport function _countGroupLabelsBeforeOption(\n  optionIndex: number,\n  options: QueryList<MatOption>,\n  optionGroups: QueryList<MatOptgroup>,\n): number {\n  if (optionGroups.length) {\n    let optionsArray = options.toArray();\n    let groups = optionGroups.toArray();\n    let groupCounter = 0;\n\n    for (let i = 0; i < optionIndex + 1; i++) {\n      if (optionsArray[i].group && optionsArray[i].group === groups[groupCounter]) {\n        groupCounter++;\n      }\n    }\n\n    return groupCounter;\n  }\n\n  return 0;\n}\n\n/**\n * Determines the position to which to scroll a panel in order for an option to be into view.\n * @param optionOffset Offset of the option from the top of the panel.\n * @param optionHeight Height of the options.\n * @param currentScrollPosition Current scroll position of the panel.\n * @param panelHeight Height of the panel.\n * @docs-private\n */\nexport function _getOptionScrollPosition(\n  optionOffset: number,\n  optionHeight: number,\n  currentScrollPosition: number,\n  panelHeight: number,\n): number {\n  if (optionOffset < currentScrollPosition) {\n    return optionOffset;\n  }\n\n  if (optionOffset + optionHeight > currentScrollPosition + panelHeight) {\n    return Math.max(0, optionOffset - panelHeight + optionHeight);\n  }\n\n  return currentScrollPosition;\n}\n","<!-- Set aria-hidden=\"true\" to this DOM node and other decorative nodes in this file. This might\n be contributing to issue where sometimes VoiceOver focuses on a TextNode in the a11y tree instead\n of the Option node (#23202). Most assistive technology will generally ignore non-role,\n non-text-content elements. Adding aria-hidden seems to make VoiceOver behave more consistently. -->\n@if (multiple) {\n    <mat-pseudo-checkbox\n        class=\"mat-mdc-option-pseudo-checkbox\"\n        [disabled]=\"disabled\"\n        [state]=\"selected ? 'checked' : 'unchecked'\"\n        aria-hidden=\"true\"></mat-pseudo-checkbox>\n}\n\n<ng-content select=\"mat-icon\"></ng-content>\n\n<span class=\"mdc-list-item__primary-text\" #text><ng-content></ng-content></span>\n\n<!-- Render checkmark at the end for single-selection. -->\n@if (!multiple && selected && !hideSingleSelectionIndicator) {\n    <mat-pseudo-checkbox\n        class=\"mat-mdc-option-pseudo-checkbox\"\n        [disabled]=\"disabled\"\n        state=\"checked\"\n        aria-hidden=\"true\"\n        appearance=\"minimal\"></mat-pseudo-checkbox>\n}\n\n<!-- See a11y notes inside optgroup.ts for context behind this element. -->\n@if (group && group._inert) {\n    <span class=\"cdk-visually-hidden\">({{ group.label }})</span>\n}\n\n<div class=\"mat-mdc-option-ripple mat-mdc-focus-indicator\" aria-hidden=\"true\" mat-ripple\n     [matRippleTrigger]=\"_getHostElement()\" [matRippleDisabled]=\"disabled || disableRipple\">\n</div>\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {NgModule} from '@angular/core';\nimport {MatPseudoCheckbox} from './pseudo-checkbox';\nimport {MatCommonModule} from '../../common-behaviors/common-module';\n\n@NgModule({\n  imports: [MatCommonModule],\n  exports: [MatPseudoCheckbox],\n  declarations: [MatPseudoCheckbox],\n})\nexport class MatPseudoCheckboxModule {}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {NgModule} from '@angular/core';\nimport {MatRippleModule} from '../ripple/index';\nimport {MatPseudoCheckboxModule} from '../selection/index';\nimport {MatCommonModule} from '../common-behaviors/common-module';\nimport {MatOption} from './option';\nimport {MatOptgroup} from './optgroup';\n\n@NgModule({\n  imports: [MatRippleModule, MatCommonModule, MatPseudoCheckboxModule],\n  exports: [MatOption, MatOptgroup],\n  declarations: [MatOption, MatOptgroup],\n})\nexport class MatOptionModule {}\n\nexport * from './option';\nexport * from './optgroup';\nexport * from './option-parent';\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {OverlayModule} from '@angular/cdk/overlay';\nimport {CommonModule} from '@angular/common';\nimport {NgModule} from '@angular/core';\nimport {MatCommonModule, MatOptionModule} from '@angular/material/core';\nimport {MatFormFieldModule} from '@angular/material/form-field';\nimport {CdkScrollableModule} from '@angular/cdk/scrolling';\nimport {MatSelect, MatSelectTrigger, MAT_SELECT_SCROLL_STRATEGY_PROVIDER} from './select';\n\n@NgModule({\n  imports: [CommonModule, OverlayModule, MatOptionModule, MatCommonModule],\n  exports: [\n    CdkScrollableModule,\n    MatFormFieldModule,\n    MatSelect,\n    MatSelectTrigger,\n    MatOptionModule,\n    MatCommonModule,\n  ],\n  declarations: [MatSelect, MatSelectTrigger],\n  providers: [MAT_SELECT_SCROLL_STRATEGY_PROVIDER],\n})\nexport class MatSelectModule {}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/** IDs are delimited by an empty space, as per the spec. */\nconst ID_DELIMITER = ' ';\n\n/**\n * Adds the given ID to the specified ARIA attribute on an element.\n * Used for attributes such as aria-labelledby, aria-owns, etc.\n */\nexport function addAriaReferencedId(el: Element, attr: `aria-${string}`, id: string) {\n  const ids = getAriaReferenceIds(el, attr);\n  if (ids.some(existingId => existingId.trim() == id.trim())) {\n    return;\n  }\n  ids.push(id.trim());\n\n  el.setAttribute(attr, ids.join(ID_DELIMITER));\n}\n\n/**\n * Removes the given ID from the specified ARIA attribute on an element.\n * Used for attributes such as aria-labelledby, aria-owns, etc.\n */\nexport function removeAriaReferencedId(el: Element, attr: `aria-${string}`, id: string) {\n  const ids = getAriaReferenceIds(el, attr);\n  const filteredIds = ids.filter(val => val != id.trim());\n\n  if (filteredIds.length) {\n    el.setAttribute(attr, filteredIds.join(ID_DELIMITER));\n  } else {\n    el.removeAttribute(attr);\n  }\n}\n\n/**\n * Gets the list of IDs referenced by the given ARIA attribute on an element.\n * Used for attributes such as aria-labelledby, aria-owns, etc.\n */\nexport function getAriaReferenceIds(el: Element, attr: string): string[] {\n  // Get string array of all individual ids (whitespace delimited) in the attribute value\n  return (el.getAttribute(attr) || '').match(/\\S+/g) || [];\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {ListKeyManager, ListKeyManagerOption} from './list-key-manager';\n\n/**\n * This is the interface for highlightable items (used by the ActiveDescendantKeyManager).\n * Each item must know how to style itself as active or inactive and whether or not it is\n * currently disabled.\n */\nexport interface Highlightable extends ListKeyManagerOption {\n  /** Applies the styles for an active item to this item. */\n  setActiveStyles(): void;\n\n  /** Applies the styles for an inactive item to this item. */\n  setInactiveStyles(): void;\n}\n\nexport class ActiveDescendantKeyManager<T> extends ListKeyManager<Highlightable & T> {\n  /**\n   * Sets the active item to the item at the specified index and adds the\n   * active styles to the newly active item. Also removes active styles\n   * from the previously active item.\n   * @param index Index of the item to be set as active.\n   */\n  override setActiveItem(index: number): void;\n\n  /**\n   * Sets the active item to the item to the specified one and adds the\n   * active styles to the it. Also removes active styles from the\n   * previously active item.\n   * @param item Item to be set as active.\n   */\n  override setActiveItem(item: T): void;\n\n  override setActiveItem(index: any): void {\n    if (this.activeItem) {\n      this.activeItem.setInactiveStyles();\n    }\n    super.setActiveItem(index);\n    if (this.activeItem) {\n      this.activeItem.setActiveStyles();\n    }\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {Subject} from 'rxjs';\n\n/**\n * Class to be used to power selecting one or more options from a list.\n */\nexport class SelectionModel<T> {\n  /** Currently-selected values. */\n  private _selection = new Set<T>();\n\n  /** Keeps track of the deselected options that haven't been emitted by the change event. */\n  private _deselectedToEmit: T[] = [];\n\n  /** Keeps track of the selected options that haven't been emitted by the change event. */\n  private _selectedToEmit: T[] = [];\n\n  /** Cache for the array value of the selected items. */\n  private _selected: T[] | null;\n\n  /** Selected values. */\n  get selected(): T[] {\n    if (!this._selected) {\n      this._selected = Array.from(this._selection.values());\n    }\n\n    return this._selected;\n  }\n\n  /** Event emitted when the value has changed. */\n  readonly changed = new Subject<SelectionChange<T>>();\n\n  constructor(\n    private _multiple = false,\n    initiallySelectedValues?: T[],\n    private _emitChanges = true,\n    public compareWith?: (o1: T, o2: T) => boolean,\n  ) {\n    if (initiallySelectedValues && initiallySelectedValues.length) {\n      if (_multiple) {\n        initiallySelectedValues.forEach(value => this._markSelected(value));\n      } else {\n        this._markSelected(initiallySelectedValues[0]);\n      }\n\n      // Clear the array in order to avoid firing the change event for preselected values.\n      this._selectedToEmit.length = 0;\n    }\n  }\n\n  /**\n   * Selects a value or an array of values.\n   * @param values The values to select\n   * @return Whether the selection changed as a result of this call\n   * @breaking-change 16.0.0 make return type boolean\n   */\n  select(...values: T[]): boolean | void {\n    this._verifyValueAssignment(values);\n    values.forEach(value => this._markSelected(value));\n    const changed = this._hasQueuedChanges();\n    this._emitChangeEvent();\n    return changed;\n  }\n\n  /**\n   * Deselects a value or an array of values.\n   * @param values The values to deselect\n   * @return Whether the selection changed as a result of this call\n   * @breaking-change 16.0.0 make return type boolean\n   */\n  deselect(...values: T[]): boolean | void {\n    this._verifyValueAssignment(values);\n    values.forEach(value => this._unmarkSelected(value));\n    const changed = this._hasQueuedChanges();\n    this._emitChangeEvent();\n    return changed;\n  }\n\n  /**\n   * Sets the selected values\n   * @param values The new selected values\n   * @return Whether the selection changed as a result of this call\n   * @breaking-change 16.0.0 make return type boolean\n   */\n  setSelection(...values: T[]): boolean | void {\n    this._verifyValueAssignment(values);\n    const oldValues = this.selected;\n    const newSelectedSet = new Set(values);\n    values.forEach(value => this._markSelected(value));\n    oldValues\n      .filter(value => !newSelectedSet.has(value))\n      .forEach(value => this._unmarkSelected(value));\n    const changed = this._hasQueuedChanges();\n    this._emitChangeEvent();\n    return changed;\n  }\n\n  /**\n   * Toggles a value between selected and deselected.\n   * @param value The value to toggle\n   * @return Whether the selection changed as a result of this call\n   * @breaking-change 16.0.0 make return type boolean\n   */\n  toggle(value: T): boolean | void {\n    return this.isSelected(value) ? this.deselect(value) : this.select(value);\n  }\n\n  /**\n   * Clears all of the selected values.\n   * @param flushEvent Whether to flush the changes in an event.\n   *   If false, the changes to the selection will be flushed along with the next event.\n   * @return Whether the selection changed as a result of this call\n   * @breaking-change 16.0.0 make return type boolean\n   */\n  clear(flushEvent = true): boolean | void {\n    this._unmarkAll();\n    const changed = this._hasQueuedChanges();\n    if (flushEvent) {\n      this._emitChangeEvent();\n    }\n    return changed;\n  }\n\n  /**\n   * Determines whether a value is selected.\n   */\n  isSelected(value: T): boolean {\n    return this._selection.has(this._getConcreteValue(value));\n  }\n\n  /**\n   * Determines whether the model does not have a value.\n   */\n  isEmpty(): boolean {\n    return this._selection.size === 0;\n  }\n\n  /**\n   * Determines whether the model has a value.\n   */\n  hasValue(): boolean {\n    return !this.isEmpty();\n  }\n\n  /**\n   * Sorts the selected values based on a predicate function.\n   */\n  sort(predicate?: (a: T, b: T) => number): void {\n    if (this._multiple && this.selected) {\n      this._selected!.sort(predicate);\n    }\n  }\n\n  /**\n   * Gets whether multiple values can be selected.\n   */\n  isMultipleSelection() {\n    return this._multiple;\n  }\n\n  /** Emits a change event and clears the records of selected and deselected values. */\n  private _emitChangeEvent() {\n    // Clear the selected values so they can be re-cached.\n    this._selected = null;\n\n    if (this._selectedToEmit.length || this._deselectedToEmit.length) {\n      this.changed.next({\n        source: this,\n        added: this._selectedToEmit,\n        removed: this._deselectedToEmit,\n      });\n\n      this._deselectedToEmit = [];\n      this._selectedToEmit = [];\n    }\n  }\n\n  /** Selects a value. */\n  private _markSelected(value: T) {\n    value = this._getConcreteValue(value);\n    if (!this.isSelected(value)) {\n      if (!this._multiple) {\n        this._unmarkAll();\n      }\n\n      if (!this.isSelected(value)) {\n        this._selection.add(value);\n      }\n\n      if (this._emitChanges) {\n        this._selectedToEmit.push(value);\n      }\n    }\n  }\n\n  /** Deselects a value. */\n  private _unmarkSelected(value: T) {\n    value = this._getConcreteValue(value);\n    if (this.isSelected(value)) {\n      this._selection.delete(value);\n\n      if (this._emitChanges) {\n        this._deselectedToEmit.push(value);\n      }\n    }\n  }\n\n  /** Clears out the selected values. */\n  private _unmarkAll() {\n    if (!this.isEmpty()) {\n      this._selection.forEach(value => this._unmarkSelected(value));\n    }\n  }\n\n  /**\n   * Verifies the value assignment and throws an error if the specified value array is\n   * including multiple values while the selection model is not supporting multiple values.\n   */\n  private _verifyValueAssignment(values: T[]) {\n    if (values.length > 1 && !this._multiple && (typeof ngDevMode === 'undefined' || ngDevMode)) {\n      throw getMultipleValuesInSingleSelectionError();\n    }\n  }\n\n  /** Whether there are queued up change to be emitted. */\n  private _hasQueuedChanges() {\n    return !!(this._deselectedToEmit.length || this._selectedToEmit.length);\n  }\n\n  /** Returns a value that is comparable to inputValue by applying compareWith function, returns the same inputValue otherwise. */\n  private _getConcreteValue(inputValue: T): T {\n    if (!this.compareWith) {\n      return inputValue;\n    } else {\n      for (let selectedValue of this._selection) {\n        if (this.compareWith!(inputValue, selectedValue)) {\n          return selectedValue;\n        }\n      }\n      return inputValue;\n    }\n  }\n}\n\n/**\n * Event emitted when the value of a MatSelectionModel has changed.\n * @docs-private\n */\nexport interface SelectionChange<T> {\n  /** Model that dispatched the event. */\n  source: SelectionModel<T>;\n  /** Options that were added to the model. */\n  added: T[];\n  /** Options that were removed from the model. */\n  removed: T[];\n}\n\n/**\n * Returns an error that reports that multiple values are passed into a selection model\n * with a single value.\n * @docs-private\n */\nexport function getMultipleValuesInSingleSelectionError() {\n  return Error('Cannot pass multiple values into SelectionModel with single-value mode.');\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {\n  animate,\n  animateChild,\n  AnimationTriggerMetadata,\n  query,\n  state,\n  style,\n  transition,\n  trigger,\n} from '@angular/animations';\n\n/**\n * The following are all the animations for the mat-select component, with each\n * const containing the metadata for one animation.\n *\n * The values below match the implementation of the AngularJS Material mat-select animation.\n * @docs-private\n */\nexport const matSelectAnimations: {\n  /**\n   * @deprecated No longer being used. To be removed.\n   * @breaking-change 12.0.0\n   */\n  readonly transformPanelWrap: AnimationTriggerMetadata;\n  readonly transformPanel: AnimationTriggerMetadata;\n} = {\n  /**\n   * This animation ensures the select's overlay panel animation (transformPanel) is called when\n   * closing the select.\n   * This is needed due to https://github.com/angular/angular/issues/23302\n   */\n  transformPanelWrap: trigger('transformPanelWrap', [\n    transition('* => void', query('@transformPanel', [animateChild()], {optional: true})),\n  ]),\n\n  /** This animation transforms the select's overlay panel on and off the page. */\n  transformPanel: trigger('transformPanel', [\n    state(\n      'void',\n      style({\n        opacity: 0,\n        transform: 'scale(1, 0.8)',\n      }),\n    ),\n    transition(\n      'void => showing',\n      animate(\n        '120ms cubic-bezier(0, 0, 0.2, 1)',\n        style({\n          opacity: 1,\n          transform: 'scale(1, 1)',\n        }),\n      ),\n    ),\n    transition('* => void', animate('100ms linear', style({opacity: 0}))),\n  ]),\n};\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {InjectionToken} from '@angular/core';\n\n// The tokens for the live announcer are defined in a separate file from LiveAnnouncer\n// as a workaround for https://github.com/angular/angular/issues/22559\n\n/** Possible politeness levels. */\nexport type AriaLivePoliteness = 'off' | 'polite' | 'assertive';\n\nexport const LIVE_ANNOUNCER_ELEMENT_TOKEN = new InjectionToken<HTMLElement | null>(\n  'liveAnnouncerElement',\n  {\n    providedIn: 'root',\n    factory: LIVE_ANNOUNCER_ELEMENT_TOKEN_FACTORY,\n  },\n);\n\n/** @docs-private */\nexport function LIVE_ANNOUNCER_ELEMENT_TOKEN_FACTORY(): null {\n  return null;\n}\n\n/** Object that can be used to configure the default options for the LiveAnnouncer. */\nexport interface LiveAnnouncerDefaultOptions {\n  /** Default politeness for the announcements. */\n  politeness?: AriaLivePoliteness;\n\n  /** Default duration for the announcement messages. */\n  duration?: number;\n}\n\n/** Injection token that can be used to configure the default options for the LiveAnnouncer. */\nexport const LIVE_ANNOUNCER_DEFAULT_OPTIONS = new InjectionToken<LiveAnnouncerDefaultOptions>(\n  'LIVE_ANNOUNCER_DEFAULT_OPTIONS',\n);\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {ContentObserver} from '@angular/cdk/observers';\nimport {DOCUMENT} from '@angular/common';\nimport {\n  Directive,\n  ElementRef,\n  Inject,\n  Injectable,\n  Input,\n  NgZone,\n  OnDestroy,\n  Optional,\n} from '@angular/core';\nimport {Subscription} from 'rxjs';\nimport {\n  AriaLivePoliteness,\n  LiveAnnouncerDefaultOptions,\n  LIVE_ANNOUNCER_ELEMENT_TOKEN,\n  LIVE_ANNOUNCER_DEFAULT_OPTIONS,\n} from './live-announcer-tokens';\n\nlet uniqueIds = 0;\n\n@Injectable({providedIn: 'root'})\nexport class LiveAnnouncer implements OnDestroy {\n  private _liveElement: HTMLElement;\n  private _document: Document;\n  private _previousTimeout: number;\n  private _currentPromise: Promise<void> | undefined;\n  private _currentResolve: (() => void) | undefined;\n\n  constructor(\n    @Optional() @Inject(LIVE_ANNOUNCER_ELEMENT_TOKEN) elementToken: any,\n    private _ngZone: NgZone,\n    @Inject(DOCUMENT) _document: any,\n    @Optional()\n    @Inject(LIVE_ANNOUNCER_DEFAULT_OPTIONS)\n    private _defaultOptions?: LiveAnnouncerDefaultOptions,\n  ) {\n    // We inject the live element and document as `any` because the constructor signature cannot\n    // reference browser globals (HTMLElement, Document) on non-browser environments, since having\n    // a class decorator causes TypeScript to preserve the constructor signature types.\n    this._document = _document;\n    this._liveElement = elementToken || this._createLiveElement();\n  }\n\n  /**\n   * Announces a message to screen readers.\n   * @param message Message to be announced to the screen reader.\n   * @returns Promise that will be resolved when the message is added to the DOM.\n   */\n  announce(message: string): Promise<void>;\n\n  /**\n   * Announces a message to screen readers.\n   * @param message Message to be announced to the screen reader.\n   * @param politeness The politeness of the announcer element.\n   * @returns Promise that will be resolved when the message is added to the DOM.\n   */\n  announce(message: string, politeness?: AriaLivePoliteness): Promise<void>;\n\n  /**\n   * Announces a message to screen readers.\n   * @param message Message to be announced to the screen reader.\n   * @param duration Time in milliseconds after which to clear out the announcer element. Note\n   *   that this takes effect after the message has been added to the DOM, which can be up to\n   *   100ms after `announce` has been called.\n   * @returns Promise that will be resolved when the message is added to the DOM.\n   */\n  announce(message: string, duration?: number): Promise<void>;\n\n  /**\n   * Announces a message to screen readers.\n   * @param message Message to be announced to the screen reader.\n   * @param politeness The politeness of the announcer element.\n   * @param duration Time in milliseconds after which to clear out the announcer element. Note\n   *   that this takes effect after the message has been added to the DOM, which can be up to\n   *   100ms after `announce` has been called.\n   * @returns Promise that will be resolved when the message is added to the DOM.\n   */\n  announce(message: string, politeness?: AriaLivePoliteness, duration?: number): Promise<void>;\n\n  announce(message: string, ...args: any[]): Promise<void> {\n    const defaultOptions = this._defaultOptions;\n    let politeness: AriaLivePoliteness | undefined;\n    let duration: number | undefined;\n\n    if (args.length === 1 && typeof args[0] === 'number') {\n      duration = args[0];\n    } else {\n      [politeness, duration] = args;\n    }\n\n    this.clear();\n    clearTimeout(this._previousTimeout);\n\n    if (!politeness) {\n      politeness =\n        defaultOptions && defaultOptions.politeness ? defaultOptions.politeness : 'polite';\n    }\n\n    if (duration == null && defaultOptions) {\n      duration = defaultOptions.duration;\n    }\n\n    // TODO: ensure changing the politeness works on all environments we support.\n    this._liveElement.setAttribute('aria-live', politeness);\n\n    if (this._liveElement.id) {\n      this._exposeAnnouncerToModals(this._liveElement.id);\n    }\n\n    // This 100ms timeout is necessary for some browser + screen-reader combinations:\n    // - Both JAWS and NVDA over IE11 will not announce anything without a non-zero timeout.\n    // - With Chrome and IE11 with NVDA or JAWS, a repeated (identical) message won't be read a\n    //   second time without clearing and then using a non-zero delay.\n    // (using JAWS 17 at time of this writing).\n    return this._ngZone.runOutsideAngular(() => {\n      if (!this._currentPromise) {\n        this._currentPromise = new Promise(resolve => (this._currentResolve = resolve));\n      }\n\n      clearTimeout(this._previousTimeout);\n      this._previousTimeout = setTimeout(() => {\n        this._liveElement.textContent = message;\n\n        if (typeof duration === 'number') {\n          this._previousTimeout = setTimeout(() => this.clear(), duration);\n        }\n\n        this._currentResolve!();\n        this._currentPromise = this._currentResolve = undefined;\n      }, 100);\n\n      return this._currentPromise;\n    });\n  }\n\n  /**\n   * Clears the current text from the announcer element. Can be used to prevent\n   * screen readers from reading the text out again while the user is going\n   * through the page landmarks.\n   */\n  clear() {\n    if (this._liveElement) {\n      this._liveElement.textContent = '';\n    }\n  }\n\n  ngOnDestroy() {\n    clearTimeout(this._previousTimeout);\n    this._liveElement?.remove();\n    this._liveElement = null!;\n    this._currentResolve?.();\n    this._currentPromise = this._currentResolve = undefined;\n  }\n\n  private _createLiveElement(): HTMLElement {\n    const elementClass = 'cdk-live-announcer-element';\n    const previousElements = this._document.getElementsByClassName(elementClass);\n    const liveEl = this._document.createElement('div');\n\n    // Remove any old containers. This can happen when coming in from a server-side-rendered page.\n    for (let i = 0; i < previousElements.length; i++) {\n      previousElements[i].remove();\n    }\n\n    liveEl.classList.add(elementClass);\n    liveEl.classList.add('cdk-visually-hidden');\n\n    liveEl.setAttribute('aria-atomic', 'true');\n    liveEl.setAttribute('aria-live', 'polite');\n    liveEl.id = `cdk-live-announcer-${uniqueIds++}`;\n\n    this._document.body.appendChild(liveEl);\n\n    return liveEl;\n  }\n\n  /**\n   * Some browsers won't expose the accessibility node of the live announcer element if there is an\n   * `aria-modal` and the live announcer is outside of it. This method works around the issue by\n   * pointing the `aria-owns` of all modals to the live announcer element.\n   */\n  private _exposeAnnouncerToModals(id: string) {\n    // TODO(http://github.com/angular/components/issues/26853): consider de-duplicating this with\n    // the `SnakBarContainer` and other usages.\n    //\n    // Note that the selector here is limited to CDK overlays at the moment in order to reduce the\n    // section of the DOM we need to look through. This should cover all the cases we support, but\n    // the selector can be expanded if it turns out to be too narrow.\n    const modals = this._document.querySelectorAll(\n      'body > .cdk-overlay-container [aria-modal=\"true\"]',\n    );\n\n    for (let i = 0; i < modals.length; i++) {\n      const modal = modals[i];\n      const ariaOwns = modal.getAttribute('aria-owns');\n\n      if (!ariaOwns) {\n        modal.setAttribute('aria-owns', id);\n      } else if (ariaOwns.indexOf(id) === -1) {\n        modal.setAttribute('aria-owns', ariaOwns + ' ' + id);\n      }\n    }\n  }\n}\n\n/**\n * A directive that works similarly to aria-live, but uses the LiveAnnouncer to ensure compatibility\n * with a wider range of browsers and screen readers.\n */\n@Directive({\n  selector: '[cdkAriaLive]',\n  exportAs: 'cdkAriaLive',\n})\nexport class CdkAriaLive implements OnDestroy {\n  /** The aria-live politeness level to use when announcing messages. */\n  @Input('cdkAriaLive')\n  get politeness(): AriaLivePoliteness {\n    return this._politeness;\n  }\n  set politeness(value: AriaLivePoliteness) {\n    this._politeness = value === 'off' || value === 'assertive' ? value : 'polite';\n    if (this._politeness === 'off') {\n      if (this._subscription) {\n        this._subscription.unsubscribe();\n        this._subscription = null;\n      }\n    } else if (!this._subscription) {\n      this._subscription = this._ngZone.runOutsideAngular(() => {\n        return this._contentObserver.observe(this._elementRef).subscribe(() => {\n          // Note that we use textContent here, rather than innerText, in order to avoid a reflow.\n          const elementText = this._elementRef.nativeElement.textContent;\n\n          // The `MutationObserver` fires also for attribute\n          // changes which we don't want to announce.\n          if (elementText !== this._previousAnnouncedText) {\n            this._liveAnnouncer.announce(elementText, this._politeness, this.duration);\n            this._previousAnnouncedText = elementText;\n          }\n        });\n      });\n    }\n  }\n  private _politeness: AriaLivePoliteness = 'polite';\n\n  /** Time in milliseconds after which to clear out the announcer element. */\n  @Input('cdkAriaLiveDuration') duration: number;\n\n  private _previousAnnouncedText?: string;\n  private _subscription: Subscription | null;\n\n  constructor(\n    private _elementRef: ElementRef,\n    private _liveAnnouncer: LiveAnnouncer,\n    private _contentObserver: ContentObserver,\n    private _ngZone: NgZone,\n  ) {}\n\n  ngOnDestroy() {\n    if (this._subscription) {\n      this._subscription.unsubscribe();\n    }\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {\n  ActiveDescendantKeyManager,\n  LiveAnnouncer,\n  addAriaReferencedId,\n  removeAriaReferencedId,\n} from '@angular/cdk/a11y';\nimport {Directionality} from '@angular/cdk/bidi';\nimport {\n  BooleanInput,\n  coerceBooleanProperty,\n  coerceNumberProperty,\n  NumberInput,\n} from '@angular/cdk/coercion';\nimport {SelectionModel} from '@angular/cdk/collections';\nimport {\n  A,\n  DOWN_ARROW,\n  ENTER,\n  hasModifierKey,\n  LEFT_ARROW,\n  RIGHT_ARROW,\n  SPACE,\n  UP_ARROW,\n} from '@angular/cdk/keycodes';\nimport {\n  CdkConnectedOverlay,\n  CdkOverlayOrigin,\n  ConnectedPosition,\n  Overlay,\n  ScrollStrategy,\n} from '@angular/cdk/overlay';\nimport {ViewportRuler} from '@angular/cdk/scrolling';\nimport {\n  AfterContentInit,\n  Attribute,\n  ChangeDetectionStrategy,\n  ChangeDetectorRef,\n  Component,\n  ContentChild,\n  ContentChildren,\n  Directive,\n  DoCheck,\n  ElementRef,\n  EventEmitter,\n  Inject,\n  InjectionToken,\n  Input,\n  NgZone,\n  OnChanges,\n  OnDestroy,\n  OnInit,\n  Optional,\n  Output,\n  QueryList,\n  Self,\n  SimpleChanges,\n  ViewChild,\n  ViewEncapsulation,\n} from '@angular/core';\nimport {\n  AbstractControl,\n  ControlValueAccessor,\n  FormGroupDirective,\n  NgControl,\n  NgForm,\n  Validators,\n} from '@angular/forms';\nimport {\n  CanDisable,\n  CanDisableRipple,\n  CanUpdateErrorState,\n  ErrorStateMatcher,\n  HasTabIndex,\n  MatOptgroup,\n  MatOption,\n  MatOptionSelectionChange,\n  MAT_OPTGROUP,\n  MAT_OPTION_PARENT_COMPONENT,\n  mixinDisabled,\n  mixinDisableRipple,\n  mixinErrorState,\n  mixinTabIndex,\n  _countGroupLabelsBeforeOption,\n  _getOptionScrollPosition,\n} from '@angular/material/core';\nimport {MatFormField, MatFormFieldControl, MAT_FORM_FIELD} from '@angular/material/form-field';\nimport {defer, merge, Observable, Subject} from 'rxjs';\nimport {\n  distinctUntilChanged,\n  filter,\n  map,\n  startWith,\n  switchMap,\n  take,\n  takeUntil,\n} from 'rxjs/operators';\nimport {matSelectAnimations} from './select-animations';\nimport {\n  getMatSelectDynamicMultipleError,\n  getMatSelectNonArrayValueError,\n  getMatSelectNonFunctionValueError,\n} from './select-errors';\n\nlet nextUniqueId = 0;\n\n/** Injection token that determines the scroll handling while a select is open. */\nexport const MAT_SELECT_SCROLL_STRATEGY = new InjectionToken<() => ScrollStrategy>(\n  'mat-select-scroll-strategy',\n);\n\n/** @docs-private */\nexport function MAT_SELECT_SCROLL_STRATEGY_PROVIDER_FACTORY(\n  overlay: Overlay,\n): () => ScrollStrategy {\n  return () => overlay.scrollStrategies.reposition();\n}\n\n/** Object that can be used to configure the default options for the select module. */\nexport interface MatSelectConfig {\n  /** Whether option centering should be disabled. */\n  disableOptionCentering?: boolean;\n\n  /** Time to wait in milliseconds after the last keystroke before moving focus to an item. */\n  typeaheadDebounceInterval?: number;\n\n  /** Class or list of classes to be applied to the menu's overlay panel. */\n  overlayPanelClass?: string | string[];\n\n  /** Wheter icon indicators should be hidden for single-selection. */\n  hideSingleSelectionIndicator?: boolean;\n\n  /**\n   * Width of the panel. If set to `auto`, the panel will match the trigger width.\n   * If set to null or an empty string, the panel will grow to match the longest option's text.\n   */\n  panelWidth?: string | number | null;\n}\n\n/** Injection token that can be used to provide the default options the select module. */\nexport const MAT_SELECT_CONFIG = new InjectionToken<MatSelectConfig>('MAT_SELECT_CONFIG');\n\n/** @docs-private */\nexport const MAT_SELECT_SCROLL_STRATEGY_PROVIDER = {\n  provide: MAT_SELECT_SCROLL_STRATEGY,\n  deps: [Overlay],\n  useFactory: MAT_SELECT_SCROLL_STRATEGY_PROVIDER_FACTORY,\n};\n\n/**\n * Injection token that can be used to reference instances of `MatSelectTrigger`. It serves as\n * alternative token to the actual `MatSelectTrigger` class which could cause unnecessary\n * retention of the class and its directive metadata.\n */\nexport const MAT_SELECT_TRIGGER = new InjectionToken<MatSelectTrigger>('MatSelectTrigger');\n\n/** Change event object that is emitted when the select value has changed. */\nexport class MatSelectChange {\n  constructor(\n    /** Reference to the select that emitted the change event. */\n    public source: MatSelect,\n    /** Current value of the select that emitted the event. */\n    public value: any,\n  ) {}\n}\n\n// Boilerplate for applying mixins to MatSelect.\n/** @docs-private */\nconst _MatSelectMixinBase = mixinDisableRipple(\n  mixinTabIndex(\n    mixinDisabled(\n      mixinErrorState(\n        class {\n          /**\n           * Emits whenever the component state changes and should cause the parent\n           * form-field to update. Implemented as part of `MatFormFieldControl`.\n           * @docs-private\n           */\n          readonly stateChanges = new Subject<void>();\n\n          constructor(\n            public _elementRef: ElementRef,\n            public _defaultErrorStateMatcher: ErrorStateMatcher,\n            public _parentForm: NgForm,\n            public _parentFormGroup: FormGroupDirective,\n            /**\n             * Form control bound to the component.\n             * Implemented as part of `MatFormFieldControl`.\n             * @docs-private\n             */\n            public ngControl: NgControl,\n          ) {}\n        },\n      ),\n    ),\n  ),\n);\n\n@Component({\n  selector: 'mat-select',\n  exportAs: 'matSelect',\n  templateUrl: 'select.html',\n  styleUrls: ['select.css'],\n  inputs: ['disabled', 'disableRipple', 'tabIndex'],\n  encapsulation: ViewEncapsulation.None,\n  changeDetection: ChangeDetectionStrategy.OnPush,\n  host: {\n    'role': 'combobox',\n    'aria-autocomplete': 'none',\n    'aria-haspopup': 'listbox',\n    'class': 'mat-mdc-select',\n    '[attr.id]': 'id',\n    '[attr.tabindex]': 'tabIndex',\n    '[attr.aria-controls]': 'panelOpen ? id + \"-panel\" : null',\n    '[attr.aria-expanded]': 'panelOpen',\n    '[attr.aria-label]': 'ariaLabel || null',\n    '[attr.aria-required]': 'required.toString()',\n    '[attr.aria-disabled]': 'disabled.toString()',\n    '[attr.aria-invalid]': 'errorState',\n    '[attr.aria-activedescendant]': '_getAriaActiveDescendant()',\n    'ngSkipHydration': '',\n    '[class.mat-mdc-select-disabled]': 'disabled',\n    '[class.mat-mdc-select-invalid]': 'errorState',\n    '[class.mat-mdc-select-required]': 'required',\n    '[class.mat-mdc-select-empty]': 'empty',\n    '[class.mat-mdc-select-multiple]': 'multiple',\n    '(keydown)': '_handleKeydown($event)',\n    '(focus)': '_onFocus()',\n    '(blur)': '_onBlur()',\n  },\n  animations: [matSelectAnimations.transformPanel],\n  providers: [\n    {provide: MatFormFieldControl, useExisting: MatSelect},\n    {provide: MAT_OPTION_PARENT_COMPONENT, useExisting: MatSelect},\n  ],\n})\nexport class MatSelect\n  extends _MatSelectMixinBase\n  implements\n    AfterContentInit,\n    OnChanges,\n    OnDestroy,\n    OnInit,\n    DoCheck,\n    ControlValueAccessor,\n    CanDisable,\n    HasTabIndex,\n    MatFormFieldControl<any>,\n    CanUpdateErrorState,\n    CanDisableRipple\n{\n  /** All of the defined select options. */\n  @ContentChildren(MatOption, {descendants: true}) options: QueryList<MatOption>;\n\n  // TODO(crisbeto): this is only necessary for the non-MDC select, but it's technically a\n  // public API so we have to keep it. It should be deprecated and removed eventually.\n  /** All of the defined groups of options. */\n  @ContentChildren(MAT_OPTGROUP, {descendants: true}) optionGroups: QueryList<MatOptgroup>;\n\n  /** User-supplied override of the trigger element. */\n  @ContentChild(MAT_SELECT_TRIGGER) customTrigger: MatSelectTrigger;\n\n  /**\n   * This position config ensures that the top \"start\" corner of the overlay\n   * is aligned with with the top \"start\" of the origin by default (overlapping\n   * the trigger completely). If the panel cannot fit below the trigger, it\n   * will fall back to a position above the trigger.\n   */\n  _positions: ConnectedPosition[] = [\n    {\n      originX: 'start',\n      originY: 'bottom',\n      overlayX: 'start',\n      overlayY: 'top',\n    },\n    {\n      originX: 'end',\n      originY: 'bottom',\n      overlayX: 'end',\n      overlayY: 'top',\n    },\n    {\n      originX: 'start',\n      originY: 'top',\n      overlayX: 'start',\n      overlayY: 'bottom',\n      panelClass: 'mat-mdc-select-panel-above',\n    },\n    {\n      originX: 'end',\n      originY: 'top',\n      overlayX: 'end',\n      overlayY: 'bottom',\n      panelClass: 'mat-mdc-select-panel-above',\n    },\n  ];\n\n  /** Scrolls a particular option into the view. */\n  _scrollOptionIntoView(index: number): void {\n    const option = this.options.toArray()[index];\n\n    if (option) {\n      const panel: HTMLElement = this.panel.nativeElement;\n      const labelCount = _countGroupLabelsBeforeOption(index, this.options, this.optionGroups);\n      const element = option._getHostElement();\n\n      if (index === 0 && labelCount === 1) {\n        // If we've got one group label before the option and we're at the top option,\n        // scroll the list to the top. This is better UX than scrolling the list to the\n        // top of the option, because it allows the user to read the top group's label.\n        panel.scrollTop = 0;\n      } else {\n        panel.scrollTop = _getOptionScrollPosition(\n          element.offsetTop,\n          element.offsetHeight,\n          panel.scrollTop,\n          panel.offsetHeight,\n        );\n      }\n    }\n  }\n\n  /** Called when the panel has been opened and the overlay has settled on its final position. */\n  private _positioningSettled() {\n    this._scrollOptionIntoView(this._keyManager.activeItemIndex || 0);\n  }\n\n  /** Creates a change event object that should be emitted by the select. */\n  private _getChangeEvent(value: any) {\n    return new MatSelectChange(this, value);\n  }\n\n  /** Factory function used to create a scroll strategy for this select. */\n  private _scrollStrategyFactory: () => ScrollStrategy;\n\n  /** Whether or not the overlay panel is open. */\n  private _panelOpen = false;\n\n  /** Comparison function to specify which option is displayed. Defaults to object equality. */\n  private _compareWith = (o1: any, o2: any) => o1 === o2;\n\n  /** Unique id for this input. */\n  private _uid = `mat-select-${nextUniqueId++}`;\n\n  /** Current `aria-labelledby` value for the select trigger. */\n  private _triggerAriaLabelledBy: string | null = null;\n\n  /**\n   * Keeps track of the previous form control assigned to the select.\n   * Used to detect if it has changed.\n   */\n  private _previousControl: AbstractControl | null | undefined;\n\n  /** Emits whenever the component is destroyed. */\n  protected readonly _destroy = new Subject<void>();\n\n  /**\n   * Implemented as part of MatFormFieldControl.\n   * @docs-private\n   */\n  @Input('aria-describedby') userAriaDescribedBy: string;\n\n  /** Deals with the selection logic. */\n  _selectionModel: SelectionModel<MatOption>;\n\n  /** Manages keyboard events for options in the panel. */\n  _keyManager: ActiveDescendantKeyManager<MatOption>;\n\n  /** Ideal origin for the overlay panel. */\n  _preferredOverlayOrigin: CdkOverlayOrigin | ElementRef | undefined;\n\n  /** Width of the overlay panel. */\n  _overlayWidth: string | number;\n\n  /** `View -> model callback called when value changes` */\n  _onChange: (value: any) => void = () => {};\n\n  /** `View -> model callback called when select has been touched` */\n  _onTouched = () => {};\n\n  /** ID for the DOM node containing the select's value. */\n  _valueId = `mat-select-value-${nextUniqueId++}`;\n\n  /** Emits when the panel element is finished transforming in. */\n  readonly _panelDoneAnimatingStream = new Subject<string>();\n\n  /** Strategy that will be used to handle scrolling while the select panel is open. */\n  _scrollStrategy: ScrollStrategy;\n\n  _overlayPanelClass: string | string[] = this._defaultOptions?.overlayPanelClass || '';\n\n  /** Whether the select is focused. */\n  get focused(): boolean {\n    return this._focused || this._panelOpen;\n  }\n  private _focused = false;\n\n  /** A name for this control that can be used by `mat-form-field`. */\n  controlType = 'mat-select';\n\n  /** Trigger that opens the select. */\n  @ViewChild('trigger') trigger: ElementRef;\n\n  /** Panel containing the select options. */\n  @ViewChild('panel') panel: ElementRef;\n\n  /** Overlay pane containing the options. */\n  @ViewChild(CdkConnectedOverlay)\n  protected _overlayDir: CdkConnectedOverlay;\n\n  /** Classes to be passed to the select panel. Supports the same syntax as `ngClass`. */\n  @Input() panelClass: string | string[] | Set<string> | {[key: string]: any};\n\n  /** Whether checkmark indicator for single-selection options is hidden. */\n  @Input()\n  get hideSingleSelectionIndicator(): boolean {\n    return this._hideSingleSelectionIndicator;\n  }\n  set hideSingleSelectionIndicator(value: BooleanInput) {\n    this._hideSingleSelectionIndicator = coerceBooleanProperty(value);\n    this._syncParentProperties();\n  }\n  private _hideSingleSelectionIndicator: boolean =\n    this._defaultOptions?.hideSingleSelectionIndicator ?? false;\n\n  /** Placeholder to be shown if no value has been selected. */\n  @Input()\n  get placeholder(): string {\n    return this._placeholder;\n  }\n  set placeholder(value: string) {\n    this._placeholder = value;\n    this.stateChanges.next();\n  }\n  private _placeholder: string;\n\n  /** Whether the component is required. */\n  @Input()\n  get required(): boolean {\n    return this._required ?? this.ngControl?.control?.hasValidator(Validators.required) ?? false;\n  }\n  set required(value: BooleanInput) {\n    this._required = coerceBooleanProperty(value);\n    this.stateChanges.next();\n  }\n  private _required: boolean | undefined;\n\n  /** Whether the user should be allowed to select multiple options. */\n  @Input()\n  get multiple(): boolean {\n    return this._multiple;\n  }\n  set multiple(value: BooleanInput) {\n    if (this._selectionModel && (typeof ngDevMode === 'undefined' || ngDevMode)) {\n      throw getMatSelectDynamicMultipleError();\n    }\n\n    this._multiple = coerceBooleanProperty(value);\n  }\n  private _multiple: boolean = false;\n\n  /** Whether to center the active option over the trigger. */\n  @Input()\n  get disableOptionCentering(): boolean {\n    return this._disableOptionCentering;\n  }\n  set disableOptionCentering(value: BooleanInput) {\n    this._disableOptionCentering = coerceBooleanProperty(value);\n  }\n  private _disableOptionCentering = this._defaultOptions?.disableOptionCentering ?? false;\n\n  /**\n   * Function to compare the option values with the selected values. The first argument\n   * is a value from an option. The second is a value from the selection. A boolean\n   * should be returned.\n   */\n  @Input()\n  get compareWith() {\n    return this._compareWith;\n  }\n  set compareWith(fn: (o1: any, o2: any) => boolean) {\n    if (typeof fn !== 'function' && (typeof ngDevMode === 'undefined' || ngDevMode)) {\n      throw getMatSelectNonFunctionValueError();\n    }\n    this._compareWith = fn;\n    if (this._selectionModel) {\n      // A different comparator means the selection could change.\n      this._initializeSelection();\n    }\n  }\n\n  /** Value of the select control. */\n  @Input()\n  get value(): any {\n    return this._value;\n  }\n  set value(newValue: any) {\n    const hasAssigned = this._assignValue(newValue);\n\n    if (hasAssigned) {\n      this._onChange(newValue);\n    }\n  }\n  private _value: any;\n\n  /** Aria label of the select. */\n  @Input('aria-label') ariaLabel: string = '';\n\n  /** Input that can be used to specify the `aria-labelledby` attribute. */\n  @Input('aria-labelledby') ariaLabelledby: string;\n\n  /** Object used to control when error messages are shown. */\n  @Input() override errorStateMatcher: ErrorStateMatcher;\n\n  /** Time to wait in milliseconds after the last keystroke before moving focus to an item. */\n  @Input()\n  get typeaheadDebounceInterval(): number {\n    return this._typeaheadDebounceInterval;\n  }\n  set typeaheadDebounceInterval(value: NumberInput) {\n    this._typeaheadDebounceInterval = coerceNumberProperty(value);\n  }\n  private _typeaheadDebounceInterval: number;\n\n  /**\n   * Function used to sort the values in a select in multiple mode.\n   * Follows the same logic as `Array.prototype.sort`.\n   */\n  @Input() sortComparator: (a: MatOption, b: MatOption, options: MatOption[]) => number;\n\n  /** Unique id of the element. */\n  @Input()\n  get id(): string {\n    return this._id;\n  }\n  set id(value: string) {\n    this._id = value || this._uid;\n    this.stateChanges.next();\n  }\n  private _id: string;\n\n  /**\n   * Width of the panel. If set to `auto`, the panel will match the trigger width.\n   * If set to null or an empty string, the panel will grow to match the longest option's text.\n   */\n  @Input() panelWidth: string | number | null =\n    this._defaultOptions && typeof this._defaultOptions.panelWidth !== 'undefined'\n      ? this._defaultOptions.panelWidth\n      : 'auto';\n\n  /** Combined stream of all of the child options' change events. */\n  readonly optionSelectionChanges: Observable<MatOptionSelectionChange> = defer(() => {\n    const options = this.options;\n\n    if (options) {\n      return options.changes.pipe(\n        startWith(options),\n        switchMap(() => merge(...options.map(option => option.onSelectionChange))),\n      );\n    }\n\n    return this._ngZone.onStable.pipe(\n      take(1),\n      switchMap(() => this.optionSelectionChanges),\n    );\n  }) as Observable<MatOptionSelectionChange>;\n\n  /** Event emitted when the select panel has been toggled. */\n  @Output() readonly openedChange: EventEmitter<boolean> = new EventEmitter<boolean>();\n\n  /** Event emitted when the select has been opened. */\n  @Output('opened') readonly _openedStream: Observable<void> = this.openedChange.pipe(\n    filter(o => o),\n    map(() => {}),\n  );\n\n  /** Event emitted when the select has been closed. */\n  @Output('closed') readonly _closedStream: Observable<void> = this.openedChange.pipe(\n    filter(o => !o),\n    map(() => {}),\n  );\n\n  /** Event emitted when the selected value has been changed by the user. */\n  @Output() readonly selectionChange = new EventEmitter<MatSelectChange>();\n\n  /**\n   * Event that emits whenever the raw value of the select changes. This is here primarily\n   * to facilitate the two-way binding for the `value` input.\n   * @docs-private\n   */\n  @Output() readonly valueChange: EventEmitter<any> = new EventEmitter<any>();\n\n  constructor(\n    protected _viewportRuler: ViewportRuler,\n    protected _changeDetectorRef: ChangeDetectorRef,\n    protected _ngZone: NgZone,\n    _defaultErrorStateMatcher: ErrorStateMatcher,\n    elementRef: ElementRef,\n    @Optional() private _dir: Directionality,\n    @Optional() _parentForm: NgForm,\n    @Optional() _parentFormGroup: FormGroupDirective,\n    @Optional() @Inject(MAT_FORM_FIELD) protected _parentFormField: MatFormField,\n    @Self() @Optional() ngControl: NgControl,\n    @Attribute('tabindex') tabIndex: string,\n    @Inject(MAT_SELECT_SCROLL_STRATEGY) scrollStrategyFactory: any,\n    private _liveAnnouncer: LiveAnnouncer,\n    @Optional() @Inject(MAT_SELECT_CONFIG) protected _defaultOptions?: MatSelectConfig,\n  ) {\n    super(elementRef, _defaultErrorStateMatcher, _parentForm, _parentFormGroup, ngControl);\n\n    if (this.ngControl) {\n      // Note: we provide the value accessor through here, instead of\n      // the `providers` to avoid running into a circular import.\n      this.ngControl.valueAccessor = this;\n    }\n\n    // Note that we only want to set this when the defaults pass it in, otherwise it should\n    // stay as `undefined` so that it falls back to the default in the key manager.\n    if (_defaultOptions?.typeaheadDebounceInterval != null) {\n      this._typeaheadDebounceInterval = _defaultOptions.typeaheadDebounceInterval;\n    }\n\n    this._scrollStrategyFactory = scrollStrategyFactory;\n    this._scrollStrategy = this._scrollStrategyFactory();\n    this.tabIndex = parseInt(tabIndex) || 0;\n\n    // Force setter to be called in case id was not specified.\n    this.id = this.id;\n  }\n\n  ngOnInit() {\n    this._selectionModel = new SelectionModel<MatOption>(this.multiple);\n    this.stateChanges.next();\n\n    // We need `distinctUntilChanged` here, because some browsers will\n    // fire the animation end event twice for the same animation. See:\n    // https://github.com/angular/angular/issues/24084\n    this._panelDoneAnimatingStream\n      .pipe(distinctUntilChanged(), takeUntil(this._destroy))\n      .subscribe(() => this._panelDoneAnimating(this.panelOpen));\n\n    this._viewportRuler\n      .change()\n      .pipe(takeUntil(this._destroy))\n      .subscribe(() => {\n        if (this.panelOpen) {\n          this._overlayWidth = this._getOverlayWidth(this._preferredOverlayOrigin);\n          this._changeDetectorRef.detectChanges();\n        }\n      });\n  }\n\n  ngAfterContentInit() {\n    this._initKeyManager();\n\n    this._selectionModel.changed.pipe(takeUntil(this._destroy)).subscribe(event => {\n      event.added.forEach(option => option.select());\n      event.removed.forEach(option => option.deselect());\n    });\n\n    this.options.changes.pipe(startWith(null), takeUntil(this._destroy)).subscribe(() => {\n      this._resetOptions();\n      this._initializeSelection();\n    });\n  }\n\n  ngDoCheck() {\n    const newAriaLabelledby = this._getTriggerAriaLabelledby();\n    const ngControl = this.ngControl;\n\n    // We have to manage setting the `aria-labelledby` ourselves, because part of its value\n    // is computed as a result of a content query which can cause this binding to trigger a\n    // \"changed after checked\" error.\n    if (newAriaLabelledby !== this._triggerAriaLabelledBy) {\n      const element: HTMLElement = this._elementRef.nativeElement;\n      this._triggerAriaLabelledBy = newAriaLabelledby;\n      if (newAriaLabelledby) {\n        element.setAttribute('aria-labelledby', newAriaLabelledby);\n      } else {\n        element.removeAttribute('aria-labelledby');\n      }\n    }\n\n    if (ngControl) {\n      // The disabled state might go out of sync if the form group is swapped out. See #17860.\n      if (this._previousControl !== ngControl.control) {\n        if (\n          this._previousControl !== undefined &&\n          ngControl.disabled !== null &&\n          ngControl.disabled !== this.disabled\n        ) {\n          this.disabled = ngControl.disabled;\n        }\n\n        this._previousControl = ngControl.control;\n      }\n\n      this.updateErrorState();\n    }\n  }\n\n  ngOnChanges(changes: SimpleChanges) {\n    // Updating the disabled state is handled by `mixinDisabled`, but we need to additionally let\n    // the parent form field know to run change detection when the disabled state changes.\n    if (changes['disabled'] || changes['userAriaDescribedBy']) {\n      this.stateChanges.next();\n    }\n\n    if (changes['typeaheadDebounceInterval'] && this._keyManager) {\n      this._keyManager.withTypeAhead(this._typeaheadDebounceInterval);\n    }\n  }\n\n  ngOnDestroy() {\n    this._keyManager?.destroy();\n    this._destroy.next();\n    this._destroy.complete();\n    this.stateChanges.complete();\n    this._clearFromModal();\n  }\n\n  /** Toggles the overlay panel open or closed. */\n  toggle(): void {\n    this.panelOpen ? this.close() : this.open();\n  }\n\n  /** Opens the overlay panel. */\n  open(): void {\n    // It's important that we read this as late as possible, because doing so earlier will\n    // return a different element since it's based on queries in the form field which may\n    // not have run yet. Also this needs to be assigned before we measure the overlay width.\n    if (this._parentFormField) {\n      this._preferredOverlayOrigin = this._parentFormField.getConnectedOverlayOrigin();\n    }\n\n    this._overlayWidth = this._getOverlayWidth(this._preferredOverlayOrigin);\n\n    if (this._canOpen()) {\n      this._applyModalPanelOwnership();\n\n      this._panelOpen = true;\n      this._keyManager.withHorizontalOrientation(null);\n      this._highlightCorrectOption();\n      this._changeDetectorRef.markForCheck();\n    }\n    // Required for the MDC form field to pick up when the overlay has been opened.\n    this.stateChanges.next();\n  }\n\n  /**\n   * Track which modal we have modified the `aria-owns` attribute of. When the combobox trigger is\n   * inside an aria-modal, we apply aria-owns to the parent modal with the `id` of the options\n   * panel. Track the modal we have changed so we can undo the changes on destroy.\n   */\n  private _trackedModal: Element | null = null;\n\n  /**\n   * If the autocomplete trigger is inside of an `aria-modal` element, connect\n   * that modal to the options panel with `aria-owns`.\n   *\n   * For some browser + screen reader combinations, when navigation is inside\n   * of an `aria-modal` element, the screen reader treats everything outside\n   * of that modal as hidden or invisible.\n   *\n   * This causes a problem when the combobox trigger is _inside_ of a modal, because the\n   * options panel is rendered _outside_ of that modal, preventing screen reader navigation\n   * from reaching the panel.\n   *\n   * We can work around this issue by applying `aria-owns` to the modal with the `id` of\n   * the options panel. This effectively communicates to assistive technology that the\n   * options panel is part of the same interaction as the modal.\n   *\n   * At time of this writing, this issue is present in VoiceOver.\n   * See https://github.com/angular/components/issues/20694\n   */\n  private _applyModalPanelOwnership() {\n    // TODO(http://github.com/angular/components/issues/26853): consider de-duplicating this with\n    // the `LiveAnnouncer` and any other usages.\n    //\n    // Note that the selector here is limited to CDK overlays at the moment in order to reduce the\n    // section of the DOM we need to look through. This should cover all the cases we support, but\n    // the selector can be expanded if it turns out to be too narrow.\n    const modal = this._elementRef.nativeElement.closest(\n      'body > .cdk-overlay-container [aria-modal=\"true\"]',\n    );\n\n    if (!modal) {\n      // Most commonly, the autocomplete trigger is not inside a modal.\n      return;\n    }\n\n    const panelId = `${this.id}-panel`;\n\n    if (this._trackedModal) {\n      removeAriaReferencedId(this._trackedModal, 'aria-owns', panelId);\n    }\n\n    addAriaReferencedId(modal, 'aria-owns', panelId);\n    this._trackedModal = modal;\n  }\n\n  /** Clears the reference to the listbox overlay element from the modal it was added to. */\n  private _clearFromModal() {\n    if (!this._trackedModal) {\n      // Most commonly, the autocomplete trigger is not used inside a modal.\n      return;\n    }\n\n    const panelId = `${this.id}-panel`;\n\n    removeAriaReferencedId(this._trackedModal, 'aria-owns', panelId);\n    this._trackedModal = null;\n  }\n\n  /** Closes the overlay panel and focuses the host element. */\n  close(): void {\n    if (this._panelOpen) {\n      this._panelOpen = false;\n      this._keyManager.withHorizontalOrientation(this._isRtl() ? 'rtl' : 'ltr');\n      this._changeDetectorRef.markForCheck();\n      this._onTouched();\n    }\n\n    // Required for the MDC form field to pick up when the overlay has been closed.\n    this.stateChanges.next();\n  }\n\n  /**\n   * Sets the select's value. Part of the ControlValueAccessor interface\n   * required to integrate with Angular's core forms API.\n   *\n   * @param value New value to be written to the model.\n   */\n  writeValue(value: any): void {\n    this._assignValue(value);\n  }\n\n  /**\n   * Saves a callback function to be invoked when the select's value\n   * changes from user input. Part of the ControlValueAccessor interface\n   * required to integrate with Angular's core forms API.\n   *\n   * @param fn Callback to be triggered when the value changes.\n   */\n  registerOnChange(fn: (value: any) => void): void {\n    this._onChange = fn;\n  }\n\n  /**\n   * Saves a callback function to be invoked when the select is blurred\n   * by the user. Part of the ControlValueAccessor interface required\n   * to integrate with Angular's core forms API.\n   *\n   * @param fn Callback to be triggered when the component has been touched.\n   */\n  registerOnTouched(fn: () => {}): void {\n    this._onTouched = fn;\n  }\n\n  /**\n   * Disables the select. Part of the ControlValueAccessor interface required\n   * to integrate with Angular's core forms API.\n   *\n   * @param isDisabled Sets whether the component is disabled.\n   */\n  setDisabledState(isDisabled: boolean): void {\n    this.disabled = isDisabled;\n    this._changeDetectorRef.markForCheck();\n    this.stateChanges.next();\n  }\n\n  /** Whether or not the overlay panel is open. */\n  get panelOpen(): boolean {\n    return this._panelOpen;\n  }\n\n  /** The currently selected option. */\n  get selected(): MatOption | MatOption[] {\n    return this.multiple ? this._selectionModel?.selected || [] : this._selectionModel?.selected[0];\n  }\n\n  /** The value displayed in the trigger. */\n  get triggerValue(): string {\n    if (this.empty) {\n      return '';\n    }\n\n    if (this._multiple) {\n      const selectedOptions = this._selectionModel.selected.map(option => option.viewValue);\n\n      if (this._isRtl()) {\n        selectedOptions.reverse();\n      }\n\n      // TODO(crisbeto): delimiter should be configurable for proper localization.\n      return selectedOptions.join(', ');\n    }\n\n    return this._selectionModel.selected[0].viewValue;\n  }\n\n  /** Whether the element is in RTL mode. */\n  _isRtl(): boolean {\n    return this._dir ? this._dir.value === 'rtl' : false;\n  }\n\n  /** Handles all keydown events on the select. */\n  _handleKeydown(event: KeyboardEvent): void {\n    if (!this.disabled) {\n      this.panelOpen ? this._handleOpenKeydown(event) : this._handleClosedKeydown(event);\n    }\n  }\n\n  /** Handles keyboard events while the select is closed. */\n  private _handleClosedKeydown(event: KeyboardEvent): void {\n    const keyCode = event.keyCode;\n    const isArrowKey =\n      keyCode === DOWN_ARROW ||\n      keyCode === UP_ARROW ||\n      keyCode === LEFT_ARROW ||\n      keyCode === RIGHT_ARROW;\n    const isOpenKey = keyCode === ENTER || keyCode === SPACE;\n    const manager = this._keyManager;\n\n    // Open the select on ALT + arrow key to match the native <select>\n    if (\n      (!manager.isTyping() && isOpenKey && !hasModifierKey(event)) ||\n      ((this.multiple || event.altKey) && isArrowKey)\n    ) {\n      event.preventDefault(); // prevents the page from scrolling down when pressing space\n      this.open();\n    } else if (!this.multiple) {\n      const previouslySelectedOption = this.selected;\n      manager.onKeydown(event);\n      const selectedOption = this.selected;\n\n      // Since the value has changed, we need to announce it ourselves.\n      if (selectedOption && previouslySelectedOption !== selectedOption) {\n        // We set a duration on the live announcement, because we want the live element to be\n        // cleared after a while so that users can't navigate to it using the arrow keys.\n        this._liveAnnouncer.announce((selectedOption as MatOption).viewValue, 10000);\n      }\n    }\n  }\n\n  /** Handles keyboard events when the selected is open. */\n  private _handleOpenKeydown(event: KeyboardEvent): void {\n    const manager = this._keyManager;\n    const keyCode = event.keyCode;\n    const isArrowKey = keyCode === DOWN_ARROW || keyCode === UP_ARROW;\n    const isTyping = manager.isTyping();\n\n    if (isArrowKey && event.altKey) {\n      // Close the select on ALT + arrow key to match the native <select>\n      event.preventDefault();\n      this.close();\n      // Don't do anything in this case if the user is typing,\n      // because the typing sequence can include the space key.\n    } else if (\n      !isTyping &&\n      (keyCode === ENTER || keyCode === SPACE) &&\n      manager.activeItem &&\n      !hasModifierKey(event)\n    ) {\n      event.preventDefault();\n      manager.activeItem._selectViaInteraction();\n    } else if (!isTyping && this._multiple && keyCode === A && event.ctrlKey) {\n      event.preventDefault();\n      const hasDeselectedOptions = this.options.some(opt => !opt.disabled && !opt.selected);\n\n      this.options.forEach(option => {\n        if (!option.disabled) {\n          hasDeselectedOptions ? option.select() : option.deselect();\n        }\n      });\n    } else {\n      const previouslyFocusedIndex = manager.activeItemIndex;\n\n      manager.onKeydown(event);\n\n      if (\n        this._multiple &&\n        isArrowKey &&\n        event.shiftKey &&\n        manager.activeItem &&\n        manager.activeItemIndex !== previouslyFocusedIndex\n      ) {\n        manager.activeItem._selectViaInteraction();\n      }\n    }\n  }\n\n  _onFocus() {\n    if (!this.disabled) {\n      this._focused = true;\n      this.stateChanges.next();\n    }\n  }\n\n  /**\n   * Calls the touched callback only if the panel is closed. Otherwise, the trigger will\n   * \"blur\" to the panel when it opens, causing a false positive.\n   */\n  _onBlur() {\n    this._focused = false;\n    this._keyManager?.cancelTypeahead();\n\n    if (!this.disabled && !this.panelOpen) {\n      this._onTouched();\n      this._changeDetectorRef.markForCheck();\n      this.stateChanges.next();\n    }\n  }\n\n  /**\n   * Callback that is invoked when the overlay panel has been attached.\n   */\n  _onAttached(): void {\n    this._overlayDir.positionChange.pipe(take(1)).subscribe(() => {\n      this._changeDetectorRef.detectChanges();\n      this._positioningSettled();\n    });\n  }\n\n  /** Returns the theme to be used on the panel. */\n  _getPanelTheme(): string {\n    return this._parentFormField ? `mat-${this._parentFormField.color}` : '';\n  }\n\n  /** Whether the select has a value. */\n  get empty(): boolean {\n    return !this._selectionModel || this._selectionModel.isEmpty();\n  }\n\n  private _initializeSelection(): void {\n    // Defer setting the value in order to avoid the \"Expression\n    // has changed after it was checked\" errors from Angular.\n    Promise.resolve().then(() => {\n      if (this.ngControl) {\n        this._value = this.ngControl.value;\n      }\n\n      this._setSelectionByValue(this._value);\n      this.stateChanges.next();\n    });\n  }\n\n  /**\n   * Sets the selected option based on a value. If no option can be\n   * found with the designated value, the select trigger is cleared.\n   */\n  private _setSelectionByValue(value: any | any[]): void {\n    this.options.forEach(option => option.setInactiveStyles());\n    this._selectionModel.clear();\n\n    if (this.multiple && value) {\n      if (!Array.isArray(value) && (typeof ngDevMode === 'undefined' || ngDevMode)) {\n        throw getMatSelectNonArrayValueError();\n      }\n\n      value.forEach((currentValue: any) => this._selectOptionByValue(currentValue));\n      this._sortValues();\n    } else {\n      const correspondingOption = this._selectOptionByValue(value);\n\n      // Shift focus to the active item. Note that we shouldn't do this in multiple\n      // mode, because we don't know what option the user interacted with last.\n      if (correspondingOption) {\n        this._keyManager.updateActiveItem(correspondingOption);\n      } else if (!this.panelOpen) {\n        // Otherwise reset the highlighted option. Note that we only want to do this while\n        // closed, because doing it while open can shift the user's focus unnecessarily.\n        this._keyManager.updateActiveItem(-1);\n      }\n    }\n\n    this._changeDetectorRef.markForCheck();\n  }\n\n  /**\n   * Finds and selects and option based on its value.\n   * @returns Option that has the corresponding value.\n   */\n  private _selectOptionByValue(value: any): MatOption | undefined {\n    const correspondingOption = this.options.find((option: MatOption) => {\n      // Skip options that are already in the model. This allows us to handle cases\n      // where the same primitive value is selected multiple times.\n      if (this._selectionModel.isSelected(option)) {\n        return false;\n      }\n\n      try {\n        // Treat null as a special reset value.\n        return option.value != null && this._compareWith(option.value, value);\n      } catch (error) {\n        if (typeof ngDevMode === 'undefined' || ngDevMode) {\n          // Notify developers of errors in their comparator.\n          console.warn(error);\n        }\n        return false;\n      }\n    });\n\n    if (correspondingOption) {\n      this._selectionModel.select(correspondingOption);\n    }\n\n    return correspondingOption;\n  }\n\n  /** Assigns a specific value to the select. Returns whether the value has changed. */\n  private _assignValue(newValue: any | any[]): boolean {\n    // Always re-assign an array, because it might have been mutated.\n    if (newValue !== this._value || (this._multiple && Array.isArray(newValue))) {\n      if (this.options) {\n        this._setSelectionByValue(newValue);\n      }\n\n      this._value = newValue;\n      return true;\n    }\n    return false;\n  }\n\n  // `skipPredicate` determines if key manager should avoid putting a given option in the tab\n  // order. Allow disabled list items to receive focus via keyboard to align with WAI ARIA\n  // recommendation.\n  //\n  // Normally WAI ARIA's instructions are to exclude disabled items from the tab order, but it\n  // makes a few exceptions for compound widgets.\n  //\n  // From [Developing a Keyboard Interface](\n  // https://www.w3.org/WAI/ARIA/apg/practices/keyboard-interface/):\n  //   \"For the following composite widget elements, keep them focusable when disabled: Options in a\n  //   Listbox...\"\n  //\n  // The user can focus disabled options using the keyboard, but the user cannot click disabled\n  // options.\n  private _skipPredicate = (option: MatOption) => {\n    if (this.panelOpen) {\n      // Support keyboard focusing disabled options in an ARIA listbox.\n      return false;\n    }\n\n    // When the panel is closed, skip over disabled options. Support options via the UP/DOWN arrow\n    // keys on a closed select. ARIA listbox interaction pattern is less relevant when the panel is\n    // closed.\n    return option.disabled;\n  };\n\n  /** Gets how wide the overlay panel should be. */\n  private _getOverlayWidth(\n    preferredOrigin: ElementRef<ElementRef> | CdkOverlayOrigin | undefined,\n  ): string | number {\n    if (this.panelWidth === 'auto') {\n      const refToMeasure =\n        preferredOrigin instanceof CdkOverlayOrigin\n          ? preferredOrigin.elementRef\n          : preferredOrigin || this._elementRef;\n      return refToMeasure.nativeElement.getBoundingClientRect().width;\n    }\n\n    return this.panelWidth === null ? '' : this.panelWidth;\n  }\n  /** Syncs the parent state with the individual options. */\n  _syncParentProperties(): void {\n    if (this.options) {\n      for (const option of this.options) {\n        option._changeDetectorRef.markForCheck();\n      }\n    }\n  }\n\n  /** Sets up a key manager to listen to keyboard events on the overlay panel. */\n  private _initKeyManager() {\n    this._keyManager = new ActiveDescendantKeyManager<MatOption>(this.options)\n      .withTypeAhead(this._typeaheadDebounceInterval)\n      .withVerticalOrientation()\n      .withHorizontalOrientation(this._isRtl() ? 'rtl' : 'ltr')\n      .withHomeAndEnd()\n      .withPageUpDown()\n      .withAllowedModifierKeys(['shiftKey'])\n      .skipPredicate(this._skipPredicate);\n\n    this._keyManager.tabOut.subscribe(() => {\n      if (this.panelOpen) {\n        // Select the active item when tabbing away. This is consistent with how the native\n        // select behaves. Note that we only want to do this in single selection mode.\n        if (!this.multiple && this._keyManager.activeItem) {\n          this._keyManager.activeItem._selectViaInteraction();\n        }\n\n        // Restore focus to the trigger before closing. Ensures that the focus\n        // position won't be lost if the user got focus into the overlay.\n        this.focus();\n        this.close();\n      }\n    });\n\n    this._keyManager.change.subscribe(() => {\n      if (this._panelOpen && this.panel) {\n        this._scrollOptionIntoView(this._keyManager.activeItemIndex || 0);\n      } else if (!this._panelOpen && !this.multiple && this._keyManager.activeItem) {\n        this._keyManager.activeItem._selectViaInteraction();\n      }\n    });\n  }\n\n  /** Drops current option subscriptions and IDs and resets from scratch. */\n  private _resetOptions(): void {\n    const changedOrDestroyed = merge(this.options.changes, this._destroy);\n\n    this.optionSelectionChanges.pipe(takeUntil(changedOrDestroyed)).subscribe(event => {\n      this._onSelect(event.source, event.isUserInput);\n\n      if (event.isUserInput && !this.multiple && this._panelOpen) {\n        this.close();\n        this.focus();\n      }\n    });\n\n    // Listen to changes in the internal state of the options and react accordingly.\n    // Handles cases like the labels of the selected options changing.\n    merge(...this.options.map(option => option._stateChanges))\n      .pipe(takeUntil(changedOrDestroyed))\n      .subscribe(() => {\n        // `_stateChanges` can fire as a result of a change in the label's DOM value which may\n        // be the result of an expression changing. We have to use `detectChanges` in order\n        // to avoid \"changed after checked\" errors (see #14793).\n        this._changeDetectorRef.detectChanges();\n        this.stateChanges.next();\n      });\n  }\n\n  /** Invoked when an option is clicked. */\n  private _onSelect(option: MatOption, isUserInput: boolean): void {\n    const wasSelected = this._selectionModel.isSelected(option);\n\n    if (option.value == null && !this._multiple) {\n      option.deselect();\n      this._selectionModel.clear();\n\n      if (this.value != null) {\n        this._propagateChanges(option.value);\n      }\n    } else {\n      if (wasSelected !== option.selected) {\n        option.selected\n          ? this._selectionModel.select(option)\n          : this._selectionModel.deselect(option);\n      }\n\n      if (isUserInput) {\n        this._keyManager.setActiveItem(option);\n      }\n\n      if (this.multiple) {\n        this._sortValues();\n\n        if (isUserInput) {\n          // In case the user selected the option with their mouse, we\n          // want to restore focus back to the trigger, in order to\n          // prevent the select keyboard controls from clashing with\n          // the ones from `mat-option`.\n          this.focus();\n        }\n      }\n    }\n\n    if (wasSelected !== this._selectionModel.isSelected(option)) {\n      this._propagateChanges();\n    }\n\n    this.stateChanges.next();\n  }\n\n  /** Sorts the selected values in the selected based on their order in the panel. */\n  private _sortValues() {\n    if (this.multiple) {\n      const options = this.options.toArray();\n\n      this._selectionModel.sort((a, b) => {\n        return this.sortComparator\n          ? this.sortComparator(a, b, options)\n          : options.indexOf(a) - options.indexOf(b);\n      });\n      this.stateChanges.next();\n    }\n  }\n\n  /** Emits change event to set the model value. */\n  private _propagateChanges(fallbackValue?: any): void {\n    let valueToEmit: any;\n\n    if (this.multiple) {\n      valueToEmit = (this.selected as MatOption[]).map(option => option.value);\n    } else {\n      valueToEmit = this.selected ? (this.selected as MatOption).value : fallbackValue;\n    }\n\n    this._value = valueToEmit;\n    this.valueChange.emit(valueToEmit);\n    this._onChange(valueToEmit);\n    this.selectionChange.emit(this._getChangeEvent(valueToEmit));\n    this._changeDetectorRef.markForCheck();\n  }\n\n  /**\n   * Highlights the selected item. If no option is selected, it will highlight\n   * the first *enabled* option.\n   */\n  private _highlightCorrectOption(): void {\n    if (this._keyManager) {\n      if (this.empty) {\n        // Find the index of the first *enabled* option. Avoid calling `_keyManager.setActiveItem`\n        // because it activates the first option that passes the skip predicate, rather than the\n        // first *enabled* option.\n        let firstEnabledOptionIndex = -1;\n        for (let index = 0; index < this.options.length; index++) {\n          const option = this.options.get(index)!;\n          if (!option.disabled) {\n            firstEnabledOptionIndex = index;\n            break;\n          }\n        }\n\n        this._keyManager.setActiveItem(firstEnabledOptionIndex);\n      } else {\n        this._keyManager.setActiveItem(this._selectionModel.selected[0]);\n      }\n    }\n  }\n\n  /** Whether the panel is allowed to open. */\n  protected _canOpen(): boolean {\n    return !this._panelOpen && !this.disabled && this.options?.length > 0;\n  }\n\n  /** Focuses the select element. */\n  focus(options?: FocusOptions): void {\n    this._elementRef.nativeElement.focus(options);\n  }\n\n  /** Gets the aria-labelledby for the select panel. */\n  _getPanelAriaLabelledby(): string | null {\n    if (this.ariaLabel) {\n      return null;\n    }\n\n    const labelId = this._parentFormField?.getLabelId();\n    const labelExpression = labelId ? labelId + ' ' : '';\n    return this.ariaLabelledby ? labelExpression + this.ariaLabelledby : labelId;\n  }\n\n  /** Determines the `aria-activedescendant` to be set on the host. */\n  _getAriaActiveDescendant(): string | null {\n    if (this.panelOpen && this._keyManager && this._keyManager.activeItem) {\n      return this._keyManager.activeItem.id;\n    }\n\n    return null;\n  }\n\n  /** Gets the aria-labelledby of the select component trigger. */\n  private _getTriggerAriaLabelledby(): string | null {\n    if (this.ariaLabel) {\n      return null;\n    }\n\n    const labelId = this._parentFormField?.getLabelId();\n    let value = (labelId ? labelId + ' ' : '') + this._valueId;\n\n    if (this.ariaLabelledby) {\n      value += ' ' + this.ariaLabelledby;\n    }\n\n    return value;\n  }\n\n  /** Called when the overlay panel is done animating. */\n  protected _panelDoneAnimating(isOpen: boolean) {\n    this.openedChange.emit(isOpen);\n  }\n\n  /**\n   * Implemented as part of MatFormFieldControl.\n   * @docs-private\n   */\n  setDescribedByIds(ids: string[]) {\n    if (ids.length) {\n      this._elementRef.nativeElement.setAttribute('aria-describedby', ids.join(' '));\n    } else {\n      this._elementRef.nativeElement.removeAttribute('aria-describedby');\n    }\n  }\n\n  /**\n   * Implemented as part of MatFormFieldControl.\n   * @docs-private\n   */\n  onContainerClick() {\n    this.focus();\n    this.open();\n  }\n\n  /**\n   * Implemented as part of MatFormFieldControl.\n   * @docs-private\n   */\n  get shouldLabelFloat(): boolean {\n    // Since the panel doesn't overlap the trigger, we\n    // want the label to only float when there's a value.\n    return this.panelOpen || !this.empty || (this.focused && !!this.placeholder);\n  }\n}\n\n/**\n * Allows the user to customize the trigger that is displayed when the select has a value.\n */\n@Directive({\n  selector: 'mat-select-trigger',\n  providers: [{provide: MAT_SELECT_TRIGGER, useExisting: MatSelectTrigger}],\n})\nexport class MatSelectTrigger {}\n","<div cdk-overlay-origin\n     class=\"mat-mdc-select-trigger\"\n     (click)=\"toggle()\"\n     #fallbackOverlayOrigin=\"cdkOverlayOrigin\"\n     #trigger>\n\n  <div class=\"mat-mdc-select-value\" [attr.id]=\"_valueId\">\n    @if (empty) {\n      <span class=\"mat-mdc-select-placeholder mat-mdc-select-min-line\">{{placeholder}}</span>\n    } @else {\n      <span class=\"mat-mdc-select-value-text\">\n        @if (customTrigger) {\n          <ng-content select=\"mat-select-trigger\"></ng-content>\n        } @else {\n          <span class=\"mat-mdc-select-min-line\">{{triggerValue}}</span>\n        }\n      </span>\n    }\n  </div>\n\n  <div class=\"mat-mdc-select-arrow-wrapper\">\n    <div class=\"mat-mdc-select-arrow\">\n      <!-- Use an inline SVG, because it works better than a CSS triangle in high contrast mode. -->\n      <svg viewBox=\"0 0 24 24\" width=\"24px\" height=\"24px\" focusable=\"false\" aria-hidden=\"true\">\n        <path d=\"M7 10l5 5 5-5z\"/>\n      </svg>\n    </div>\n  </div>\n</div>\n\n<ng-template\n  cdk-connected-overlay\n  cdkConnectedOverlayLockPosition\n  cdkConnectedOverlayHasBackdrop\n  cdkConnectedOverlayBackdropClass=\"cdk-overlay-transparent-backdrop\"\n  [cdkConnectedOverlayPanelClass]=\"_overlayPanelClass\"\n  [cdkConnectedOverlayScrollStrategy]=\"_scrollStrategy\"\n  [cdkConnectedOverlayOrigin]=\"_preferredOverlayOrigin || fallbackOverlayOrigin\"\n  [cdkConnectedOverlayOpen]=\"panelOpen\"\n  [cdkConnectedOverlayPositions]=\"_positions\"\n  [cdkConnectedOverlayWidth]=\"_overlayWidth\"\n  (backdropClick)=\"close()\"\n  (attach)=\"_onAttached()\"\n  (detach)=\"close()\">\n  <div\n    #panel\n    role=\"listbox\"\n    tabindex=\"-1\"\n    class=\"mat-mdc-select-panel mdc-menu-surface mdc-menu-surface--open {{ _getPanelTheme() }}\"\n    [attr.id]=\"id + '-panel'\"\n    [attr.aria-multiselectable]=\"multiple\"\n    [attr.aria-label]=\"ariaLabel || null\"\n    [attr.aria-labelledby]=\"_getPanelAriaLabelledby()\"\n    [ngClass]=\"panelClass\"\n    [@transformPanel]=\"'showing'\"\n    (@transformPanel.done)=\"_panelDoneAnimatingStream.next($event.toState)\"\n    (keydown)=\"_handleKeydown($event)\">\n    <ng-content></ng-content>\n  </div>\n</ng-template>\n"],"names":["ListKeyManager","constructor","_items","_activeItemIndex","_activeItem","_wrap","_letterKeyStream","Subject","_typeaheadSubscription","Subscription","EMPTY","_vertical","_allowedModifierKeys","_homeAndEnd","_pageUpAndDown","enabled","delta","_skipPredicateFn","item","disabled","_pressedLetters","tabOut","change","QueryList","this","_itemChangesSubscription","changes","subscribe","newItems","newIndex","toArray","indexOf","skipPredicate","predicate","withWrap","shouldWrap","withVerticalOrientation","withHorizontalOrientation","direction","_horizontal","withAllowedModifierKeys","keys","withTypeAhead","debounceInterval","unsubscribe","pipe","tap","letter","push","debounceTime","filter","length","map","join","inputString","items","_getItemsArray","i","index","getLabel","toUpperCase","trim","setActiveItem","cancelTypeahead","withHomeAndEnd","withPageUpDown","previousActiveItem","updateActiveItem","next","onKeydown","event","keyCode","isModifierAllowed","every","modifier","TAB","DOWN_ARROW","setNextItemActive","UP_ARROW","setPreviousItemActive","RIGHT_ARROW","LEFT_ARROW","HOME","setFirstItemActive","END","setLastItemActive","PAGE_UP","targetIndex","_setActiveItemByIndex","PAGE_DOWN","itemsLength","hasModifierKey","key","toLocaleUpperCase","A","Z","ZERO","NINE","String","fromCharCode","preventDefault","activeItemIndex","activeItem","isTyping","_setActiveItemByDelta","itemArray","destroy","complete","_setActiveInWrapMode","_setActiveInDefaultMode","fallbackDelta","ɵɵclassMapInterpolate1","prefix","v0","suffix","lView","getLView","interpolatedValue","interpolation1","checkStylingMap","keyValueArraySet","classStringParser","ɵɵclassMapInterpolate2","i0","v1","interpolation2","ɵɵclassMapInterpolate3","i1","v2","interpolation3","ɵɵclassMapInterpolate4","i2","v3","interpolation4","ɵɵclassMapInterpolate5","i3","v4","interpolation5","ɵɵclassMapInterpolate6","i4","v5","interpolation6","ɵɵclassMapInterpolate7","i5","v6","interpolation7","ɵɵclassMapInterpolate8","i6","v7","interpolation8","ɵɵclassMapInterpolateV","values","interpolationV","mixinDisableRipple","base","disableRipple","_disableRipple","value","coerceBooleanProperty","args","super","mixinDisabled","_disabled","mixinTabIndex","defaultTabIndex","tabIndex","_tabIndex","coerceNumberProperty","_c0","_c1","_uniqueOptgroupIdCounter","MAT_OPTGROUP","InjectionToken","MatOptgroup","parent","_labelId","_inert","inertGroups","MAT_OPTION_PARENT_COMPONENT","selectors","hostAttrs","hostVars","hostBindings","rf","ctx","booleanAttribute","exportAs","features","provide","useExisting","MatPseudoCheckbox","_animationMode","state","appearance","ANIMATION_MODULE_TYPE","MatOption_Conditional_0_Template","ctx_r0","ctx_r2","MatOption_Conditional_6_Template","ctx_r3","_c2","_uniqueIdCounter","MatOptionSelectionChange","source","isUserInput","MatOption","multiple","_parent","selected","_selected","group","hideSingleSelectionIndicator","_element","_changeDetectorRef","_active","_mostRecentViewValue","id","onSelectionChange","EventEmitter","_stateChanges","active","viewValue","_text","nativeElement","textContent","select","emitEvent","markForCheck","_emitSelectionChangeEvent","deselect","focus","_origin","options","element","_getHostElement","setActiveStyles","setInactiveStyles","_handleKeydown","ENTER","SPACE","_selectViaInteraction","_getTabIndex","ngAfterViewChecked","ngOnDestroy","emit","viewQuery","$event","outputs","dependencies","styles","encapsulation","changeDetection","_countGroupLabelsBeforeOption","optionIndex","optionGroups","optionsArray","groups","groupCounter","_getOptionScrollPosition","optionOffset","optionHeight","currentScrollPosition","panelHeight","Math","max","MatPseudoCheckboxModule","MatCommonModule","MatOptionModule","MatRippleModule","MatSelectModule","MAT_SELECT_SCROLL_STRATEGY_PROVIDER","imports","CommonModule","OverlayModule","CdkScrollableModule","MatFormFieldModule","removeAriaReferencedId","el","attr","filteredIds","getAriaReferenceIds","val","setAttribute","removeAttribute","getAttribute","match","ActiveDescendantKeyManager","SelectionModel","Array","from","_selection","_multiple","initiallySelectedValues","_emitChanges","compareWith","Set","_deselectedToEmit","_selectedToEmit","changed","forEach","_markSelected","_verifyValueAssignment","_hasQueuedChanges","_emitChangeEvent","_unmarkSelected","setSelection","oldValues","newSelectedSet","has","toggle","isSelected","clear","flushEvent","_unmarkAll","_getConcreteValue","isEmpty","size","hasValue","sort","isMultipleSelection","added","removed","add","delete","inputValue","selectedValue","matSelectAnimations","transformPanelWrap","trigger","transition","query","animateChild","optional","transformPanel","style","opacity","transform","animate","LIVE_ANNOUNCER_ELEMENT_TOKEN","providedIn","factory","LIVE_ANNOUNCER_DEFAULT_OPTIONS","uniqueIds","LiveAnnouncer","elementToken","_ngZone","_document","_defaultOptions","_liveElement","_createLiveElement","announce","message","defaultOptions","politeness","duration","clearTimeout","_previousTimeout","_exposeAnnouncerToModals","runOutsideAngular","_currentPromise","Promise","resolve","_currentResolve","setTimeout","undefined","remove","elementClass","previousElements","getElementsByClassName","liveEl","createElement","classList","body","appendChild","modals","querySelectorAll","modal","ariaOwns","DOCUMENT","ɵfac","CdkAriaLive","_politeness","_subscription","_contentObserver","observe","_elementRef","elementText","_previousAnnouncedText","_liveAnnouncer","inputs","MatSelect_Conditional_5_Conditional_1_Template","MatSelect_Conditional_5_Conditional_2_Template","ctx_r6","MatSelect_Conditional_5_Template","MatSelect_ng_template_10_Template","_r9","ctx_r8","_panelDoneAnimatingStream","toState","ctx_r10","ctx_r4","nextUniqueId","MAT_SELECT_SCROLL_STRATEGY","MAT_SELECT_CONFIG","deps","Overlay","useFactory","overlay","scrollStrategies","reposition","MAT_SELECT_TRIGGER","MatSelectChange","_MatSelectMixinBase","mixinErrorState","_defaultErrorStateMatcher","_parentForm","_parentFormGroup","ngControl","stateChanges","MatSelect","_scrollOptionIntoView","option","panel","labelCount","scrollTop","offsetTop","offsetHeight","_positioningSettled","_keyManager","_getChangeEvent","focused","_focused","_panelOpen","_hideSingleSelectionIndicator","_syncParentProperties","placeholder","_placeholder","required","_required","control","hasValidator","Validators","_selectionModel","disableOptionCentering","_disableOptionCentering","_compareWith","fn","_initializeSelection","_value","newValue","_assignValue","_onChange","typeaheadDebounceInterval","_typeaheadDebounceInterval","_id","_uid","_viewportRuler","elementRef","_dir","_parentFormField","scrollStrategyFactory","_positions","originX","originY","overlayX","overlayY","panelClass","o1","o2","_triggerAriaLabelledBy","_destroy","_onTouched","_valueId","_overlayPanelClass","overlayPanelClass","controlType","ariaLabel","panelWidth","optionSelectionChanges","defer","startWith","switchMap","merge","onStable","take","openedChange","_openedStream","o","_closedStream","selectionChange","valueChange","_trackedModal","_skipPredicate","panelOpen","valueAccessor","_scrollStrategyFactory","_scrollStrategy","parseInt","ngOnInit","distinctUntilChanged","takeUntil","_panelDoneAnimating","_overlayWidth","_getOverlayWidth","_preferredOverlayOrigin","detectChanges","ngAfterContentInit","_initKeyManager","_resetOptions","ngDoCheck","newAriaLabelledby","_getTriggerAriaLabelledby","_previousControl","updateErrorState","ngOnChanges","_clearFromModal","close","open","getConnectedOverlayOrigin","_canOpen","_applyModalPanelOwnership","_highlightCorrectOption","closest","panelId","ids","some","existingId","addAriaReferencedId","_isRtl","writeValue","registerOnChange","registerOnTouched","setDisabledState","isDisabled","triggerValue","empty","selectedOptions","reverse","_handleOpenKeydown","_handleClosedKeydown","isArrowKey","isOpenKey","manager","altKey","previouslySelectedOption","selectedOption","ctrlKey","hasDeselectedOptions","opt","previouslyFocusedIndex","shiftKey","_onFocus","_onBlur","_onAttached","_overlayDir","positionChange","_getPanelTheme","color","then","_setSelectionByValue","isArray","currentValue","_selectOptionByValue","_sortValues","correspondingOption","find","error","preferredOrigin","CdkOverlayOrigin","getBoundingClientRect","width","changedOrDestroyed","_onSelect","wasSelected","_propagateChanges","a","b","sortComparator","fallbackValue","valueToEmit","firstEnabledOptionIndex","get","_getPanelAriaLabelledby","labelId","getLabelId","labelExpression","ariaLabelledby","_getAriaActiveDescendant","isOpen","setDescribedByIds","onContainerClick","shouldLabelFloat","MAT_FORM_FIELD","contentQueries","dirIndex","_t","CdkConnectedOverlay","MatFormFieldControl","_r0","M","i7","data","animation","MatSelectTrigger"],"sourceRoot":""}