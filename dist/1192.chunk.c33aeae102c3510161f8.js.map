{"version":3,"file":"1192.chunk.c33aeae102c3510161f8.js","mappings":"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","sources":["webpack://ng-universal-demo/../../../../forms/src/modules/formPipes/pipes/asFormControl/asFormControl.pipe.ts","webpack://ng-universal-demo/../../../../src/cdk/collections/unique-selection-dispatcher.ts","webpack://ng-universal-demo/../../../../src/material/radio/radio-module.ts","webpack://ng-universal-demo/../../../../src/material/radio/radio.ts","webpack://ng-universal-demo/../../src/material/radio/radio.html","webpack://ng-universal-demo/../../../../src/material/radio/radio.html"],"sourcesContent":["import {Inject, Optional, Pipe} from '@angular/core';\nimport {AbstractControl, FormControl} from '@angular/forms';\nimport {Logger, LOGGER} from '@anglr/common';\nimport {isBlank} from '@jscrpt/common';\n\n/**\n * Tries to convert `AbstractControl` to `FormControl`\n */\n@Pipe({name: 'asFormControl'})\nexport class AsFormControlPipe\n{\n    //######################### constructors #########################\n    constructor(@Optional() @Inject(LOGGER) private _logger?: Logger)\n    {\n    }\n\n    //######################### public methods - implementation of PipeTransform #########################\n\n    /**\n     * Allows casting of `AbstractControl` to `FormControl`\n     * @param value - `AbstractControl` to be cast to `FormControl`\n     * @param _valueHash - Parameter that can be used to change value, indicates that pipe input value has changed\n     */\n    public transform<TModel>(value: AbstractControl<TModel>|null|undefined, _valueHash?: any): FormControl<TModel>|null\n    {\n        if(isBlank(value))\n        {\n            return null;\n        }\n\n        if(value instanceof FormControl)\n        {\n            return value as FormControl<TModel>;\n        }\n\n        this._logger?.warn('Failed to cast AbstractControl to FormControl');\n\n        return null;\n    }\n}","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {Injectable, OnDestroy} from '@angular/core';\n\n// Users of the Dispatcher never need to see this type, but TypeScript requires it to be exported.\nexport type UniqueSelectionDispatcherListener = (id: string, name: string) => void;\n\n/**\n * Class to coordinate unique selection based on name.\n * Intended to be consumed as an Angular service.\n * This service is needed because native radio change events are only fired on the item currently\n * being selected, and we still need to uncheck the previous selection.\n *\n * This service does not *store* any IDs and names because they may change at any time, so it is\n * less error-prone if they are simply passed through when the events occur.\n */\n@Injectable({providedIn: 'root'})\nexport class UniqueSelectionDispatcher implements OnDestroy {\n  private _listeners: UniqueSelectionDispatcherListener[] = [];\n\n  /**\n   * Notify other items that selection for the given name has been set.\n   * @param id ID of the item.\n   * @param name Name of the item.\n   */\n  notify(id: string, name: string) {\n    for (let listener of this._listeners) {\n      listener(id, name);\n    }\n  }\n\n  /**\n   * Listen for future changes to item selection.\n   * @return Function used to deregister listener\n   */\n  listen(listener: UniqueSelectionDispatcherListener): () => void {\n    this._listeners.push(listener);\n    return () => {\n      this._listeners = this._listeners.filter((registered: UniqueSelectionDispatcherListener) => {\n        return listener !== registered;\n      });\n    };\n  }\n\n  ngOnDestroy() {\n    this._listeners = [];\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {NgModule} from '@angular/core';\nimport {MatCommonModule, MatRippleModule} from '@angular/material/core';\nimport {MatRadioButton, MatRadioGroup} from './radio';\n\n@NgModule({\n  imports: [MatRippleModule, MatCommonModule],\n  exports: [MatRadioGroup, MatRadioButton, MatCommonModule],\n  declarations: [MatRadioGroup, MatRadioButton],\n})\nexport class MatRadioModule {}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {FocusMonitor, FocusOrigin} from '@angular/cdk/a11y';\nimport {BooleanInput, coerceBooleanProperty, coerceNumberProperty} from '@angular/cdk/coercion';\nimport {UniqueSelectionDispatcher} from '@angular/cdk/collections';\nimport {\n  AfterContentInit,\n  AfterViewInit,\n  Attribute,\n  ChangeDetectionStrategy,\n  ChangeDetectorRef,\n  Component,\n  ContentChildren,\n  Directive,\n  DoCheck,\n  ElementRef,\n  EventEmitter,\n  forwardRef,\n  Inject,\n  InjectionToken,\n  Input,\n  OnDestroy,\n  OnInit,\n  Optional,\n  Output,\n  QueryList,\n  ViewChild,\n  ViewEncapsulation,\n} from '@angular/core';\nimport {ControlValueAccessor, NG_VALUE_ACCESSOR} from '@angular/forms';\nimport {\n  CanDisableRipple,\n  HasTabIndex,\n  mixinDisableRipple,\n  mixinTabIndex,\n  ThemePalette,\n} from '@angular/material/core';\nimport {ANIMATION_MODULE_TYPE} from '@angular/platform-browser/animations';\n\nexport interface MatRadioDefaultOptions {\n  color: ThemePalette;\n}\n\nexport const MAT_RADIO_DEFAULT_OPTIONS = new InjectionToken<MatRadioDefaultOptions>(\n  'mat-radio-default-options',\n  {\n    providedIn: 'root',\n    factory: MAT_RADIO_DEFAULT_OPTIONS_FACTORY,\n  },\n);\n\nexport function MAT_RADIO_DEFAULT_OPTIONS_FACTORY(): MatRadioDefaultOptions {\n  return {\n    color: 'accent',\n  };\n}\n\n// Increasing integer for generating unique ids for radio components.\nlet nextUniqueId = 0;\n\n/**\n * Provider Expression that allows mat-radio-group to register as a ControlValueAccessor. This\n * allows it to support [(ngModel)] and ngControl.\n * @docs-private\n */\nexport const MAT_RADIO_GROUP_CONTROL_VALUE_ACCESSOR: any = {\n  provide: NG_VALUE_ACCESSOR,\n  useExisting: forwardRef(() => MatRadioGroup),\n  multi: true,\n};\n\n/** Change event object emitted by MatRadio and MatRadioGroup. */\nexport class MatRadioChange {\n  constructor(\n    /** The MatRadioButton that emits the change event. */\n    public source: _MatRadioButtonBase,\n    /** The value of the MatRadioButton. */\n    public value: any,\n  ) {}\n}\n\n/**\n * Injection token that can be used to inject instances of `MatRadioGroup`. It serves as\n * alternative token to the actual `MatRadioGroup` class which could cause unnecessary\n * retention of the class and its component metadata.\n */\nexport const MAT_RADIO_GROUP = new InjectionToken<_MatRadioGroupBase<_MatRadioButtonBase>>(\n  'MatRadioGroup',\n);\n\n/**\n * Base class with all of the `MatRadioGroup` functionality.\n * @docs-private\n */\n@Directive()\nexport abstract class _MatRadioGroupBase<T extends _MatRadioButtonBase>\n  implements AfterContentInit, ControlValueAccessor\n{\n  /** Selected value for the radio group. */\n  private _value: any = null;\n\n  /** The HTML name attribute applied to radio buttons in this group. */\n  private _name: string = `mat-radio-group-${nextUniqueId++}`;\n\n  /** The currently selected radio button. Should match value. */\n  private _selected: T | null = null;\n\n  /** Whether the `value` has been set to its initial value. */\n  private _isInitialized: boolean = false;\n\n  /** Whether the labels should appear after or before the radio-buttons. Defaults to 'after' */\n  private _labelPosition: 'before' | 'after' = 'after';\n\n  /** Whether the radio group is disabled. */\n  private _disabled: boolean = false;\n\n  /** Whether the radio group is required. */\n  private _required: boolean = false;\n\n  /** The method to be called in order to update ngModel */\n  _controlValueAccessorChangeFn: (value: any) => void = () => {};\n\n  /**\n   * onTouch function registered via registerOnTouch (ControlValueAccessor).\n   * @docs-private\n   */\n  onTouched: () => any = () => {};\n\n  /**\n   * Event emitted when the group value changes.\n   * Change events are only emitted when the value changes due to user interaction with\n   * a radio button (the same behavior as `<input type-\"radio\">`).\n   */\n  @Output() readonly change: EventEmitter<MatRadioChange> = new EventEmitter<MatRadioChange>();\n\n  /** Child radio buttons. */\n  abstract _radios: QueryList<T>;\n\n  /** Theme color for all of the radio buttons in the group. */\n  @Input() color: ThemePalette;\n\n  /** Name of the radio button group. All radio buttons inside this group will use this name. */\n  @Input()\n  get name(): string {\n    return this._name;\n  }\n  set name(value: string) {\n    this._name = value;\n    this._updateRadioButtonNames();\n  }\n\n  /** Whether the labels should appear after or before the radio-buttons. Defaults to 'after' */\n  @Input()\n  get labelPosition(): 'before' | 'after' {\n    return this._labelPosition;\n  }\n  set labelPosition(v) {\n    this._labelPosition = v === 'before' ? 'before' : 'after';\n    this._markRadiosForCheck();\n  }\n\n  /**\n   * Value for the radio-group. Should equal the value of the selected radio button if there is\n   * a corresponding radio button with a matching value. If there is not such a corresponding\n   * radio button, this value persists to be applied in case a new radio button is added with a\n   * matching value.\n   */\n  @Input()\n  get value(): any {\n    return this._value;\n  }\n  set value(newValue: any) {\n    if (this._value !== newValue) {\n      // Set this before proceeding to ensure no circular loop occurs with selection.\n      this._value = newValue;\n\n      this._updateSelectedRadioFromValue();\n      this._checkSelectedRadioButton();\n    }\n  }\n\n  _checkSelectedRadioButton() {\n    if (this._selected && !this._selected.checked) {\n      this._selected.checked = true;\n    }\n  }\n\n  /**\n   * The currently selected radio button. If set to a new radio button, the radio group value\n   * will be updated to match the new selected button.\n   */\n  @Input()\n  get selected() {\n    return this._selected;\n  }\n  set selected(selected: T | null) {\n    this._selected = selected;\n    this.value = selected ? selected.value : null;\n    this._checkSelectedRadioButton();\n  }\n\n  /** Whether the radio group is disabled */\n  @Input()\n  get disabled(): boolean {\n    return this._disabled;\n  }\n  set disabled(value: BooleanInput) {\n    this._disabled = coerceBooleanProperty(value);\n    this._markRadiosForCheck();\n  }\n\n  /** Whether the radio group is required */\n  @Input()\n  get required(): boolean {\n    return this._required;\n  }\n  set required(value: BooleanInput) {\n    this._required = coerceBooleanProperty(value);\n    this._markRadiosForCheck();\n  }\n\n  constructor(private _changeDetector: ChangeDetectorRef) {}\n\n  /**\n   * Initialize properties once content children are available.\n   * This allows us to propagate relevant attributes to associated buttons.\n   */\n  ngAfterContentInit() {\n    // Mark this component as initialized in AfterContentInit because the initial value can\n    // possibly be set by NgModel on MatRadioGroup, and it is possible that the OnInit of the\n    // NgModel occurs *after* the OnInit of the MatRadioGroup.\n    this._isInitialized = true;\n  }\n\n  /**\n   * Mark this group as being \"touched\" (for ngModel). Meant to be called by the contained\n   * radio buttons upon their blur.\n   */\n  _touch() {\n    if (this.onTouched) {\n      this.onTouched();\n    }\n  }\n\n  private _updateRadioButtonNames(): void {\n    if (this._radios) {\n      this._radios.forEach(radio => {\n        radio.name = this.name;\n        radio._markForCheck();\n      });\n    }\n  }\n\n  /** Updates the `selected` radio button from the internal _value state. */\n  private _updateSelectedRadioFromValue(): void {\n    // If the value already matches the selected radio, do nothing.\n    const isAlreadySelected = this._selected !== null && this._selected.value === this._value;\n\n    if (this._radios && !isAlreadySelected) {\n      this._selected = null;\n      this._radios.forEach(radio => {\n        radio.checked = this.value === radio.value;\n        if (radio.checked) {\n          this._selected = radio;\n        }\n      });\n    }\n  }\n\n  /** Dispatch change event with current selection and group value. */\n  _emitChangeEvent(): void {\n    if (this._isInitialized) {\n      this.change.emit(new MatRadioChange(this._selected!, this._value));\n    }\n  }\n\n  _markRadiosForCheck() {\n    if (this._radios) {\n      this._radios.forEach(radio => radio._markForCheck());\n    }\n  }\n\n  /**\n   * Sets the model value. Implemented as part of ControlValueAccessor.\n   * @param value\n   */\n  writeValue(value: any) {\n    this.value = value;\n    this._changeDetector.markForCheck();\n  }\n\n  /**\n   * Registers a callback to be triggered when the model value changes.\n   * Implemented as part of ControlValueAccessor.\n   * @param fn Callback to be registered.\n   */\n  registerOnChange(fn: (value: any) => void) {\n    this._controlValueAccessorChangeFn = fn;\n  }\n\n  /**\n   * Registers a callback to be triggered when the control is touched.\n   * Implemented as part of ControlValueAccessor.\n   * @param fn Callback to be registered.\n   */\n  registerOnTouched(fn: any) {\n    this.onTouched = fn;\n  }\n\n  /**\n   * Sets the disabled state of the control. Implemented as a part of ControlValueAccessor.\n   * @param isDisabled Whether the control should be disabled.\n   */\n  setDisabledState(isDisabled: boolean) {\n    this.disabled = isDisabled;\n    this._changeDetector.markForCheck();\n  }\n}\n\n/**\n * A group of radio buttons. May contain one or more `<mat-radio-button>` elements.\n */\n@Directive({\n  selector: 'mat-radio-group',\n  exportAs: 'matRadioGroup',\n  providers: [\n    MAT_RADIO_GROUP_CONTROL_VALUE_ACCESSOR,\n    {provide: MAT_RADIO_GROUP, useExisting: MatRadioGroup},\n  ],\n  host: {\n    'role': 'radiogroup',\n    'class': 'mat-radio-group',\n  },\n})\nexport class MatRadioGroup extends _MatRadioGroupBase<MatRadioButton> {\n  @ContentChildren(forwardRef(() => MatRadioButton), {descendants: true})\n  _radios: QueryList<MatRadioButton>;\n}\n\n// Boilerplate for applying mixins to MatRadioButton.\n/** @docs-private */\nabstract class MatRadioButtonBase {\n  // Since the disabled property is manually defined for the MatRadioButton and isn't set up in\n  // the mixin base class. To be able to use the tabindex mixin, a disabled property must be\n  // defined to properly work.\n  abstract disabled: boolean;\n  constructor(public _elementRef: ElementRef) {}\n}\n\nconst _MatRadioButtonMixinBase = mixinDisableRipple(mixinTabIndex(MatRadioButtonBase));\n\n/**\n * Base class with all of the `MatRadioButton` functionality.\n * @docs-private\n */\n@Directive()\nexport abstract class _MatRadioButtonBase\n  extends _MatRadioButtonMixinBase\n  implements OnInit, AfterViewInit, DoCheck, OnDestroy, CanDisableRipple, HasTabIndex\n{\n  private _uniqueId: string = `mat-radio-${++nextUniqueId}`;\n\n  /** The unique ID for the radio button. */\n  @Input() id: string = this._uniqueId;\n\n  /** Analog to HTML 'name' attribute used to group radios for unique selection. */\n  @Input() name: string;\n\n  /** Used to set the 'aria-label' attribute on the underlying input element. */\n  @Input('aria-label') ariaLabel: string;\n\n  /** The 'aria-labelledby' attribute takes precedence as the element's text alternative. */\n  @Input('aria-labelledby') ariaLabelledby: string;\n\n  /** The 'aria-describedby' attribute is read after the element's label and field type. */\n  @Input('aria-describedby') ariaDescribedby: string;\n\n  /** Whether this radio button is checked. */\n  @Input()\n  get checked(): boolean {\n    return this._checked;\n  }\n  set checked(value: BooleanInput) {\n    const newCheckedState = coerceBooleanProperty(value);\n    if (this._checked !== newCheckedState) {\n      this._checked = newCheckedState;\n      if (newCheckedState && this.radioGroup && this.radioGroup.value !== this.value) {\n        this.radioGroup.selected = this;\n      } else if (!newCheckedState && this.radioGroup && this.radioGroup.value === this.value) {\n        // When unchecking the selected radio button, update the selected radio\n        // property on the group.\n        this.radioGroup.selected = null;\n      }\n\n      if (newCheckedState) {\n        // Notify all radio buttons with the same name to un-check.\n        this._radioDispatcher.notify(this.id, this.name);\n      }\n      this._changeDetector.markForCheck();\n    }\n  }\n\n  /** The value of this radio button. */\n  @Input()\n  get value(): any {\n    return this._value;\n  }\n  set value(value: any) {\n    if (this._value !== value) {\n      this._value = value;\n      if (this.radioGroup !== null) {\n        if (!this.checked) {\n          // Update checked when the value changed to match the radio group's value\n          this.checked = this.radioGroup.value === value;\n        }\n        if (this.checked) {\n          this.radioGroup.selected = this;\n        }\n      }\n    }\n  }\n\n  /** Whether the label should appear after or before the radio button. Defaults to 'after' */\n  @Input()\n  get labelPosition(): 'before' | 'after' {\n    return this._labelPosition || (this.radioGroup && this.radioGroup.labelPosition) || 'after';\n  }\n  set labelPosition(value) {\n    this._labelPosition = value;\n  }\n  private _labelPosition: 'before' | 'after';\n\n  /** Whether the radio button is disabled. */\n  @Input()\n  get disabled(): boolean {\n    return this._disabled || (this.radioGroup !== null && this.radioGroup.disabled);\n  }\n  set disabled(value: BooleanInput) {\n    this._setDisabled(coerceBooleanProperty(value));\n  }\n\n  /** Whether the radio button is required. */\n  @Input()\n  get required(): boolean {\n    return this._required || (this.radioGroup && this.radioGroup.required);\n  }\n  set required(value: BooleanInput) {\n    this._required = coerceBooleanProperty(value);\n  }\n\n  /** Theme color of the radio button. */\n  @Input()\n  get color(): ThemePalette {\n    // As per Material design specifications the selection control radio should use the accent color\n    // palette by default. https://material.io/guidelines/components/selection-controls.html\n    return (\n      this._color ||\n      (this.radioGroup && this.radioGroup.color) ||\n      (this._providerOverride && this._providerOverride.color) ||\n      'accent'\n    );\n  }\n  set color(newValue: ThemePalette) {\n    this._color = newValue;\n  }\n  private _color: ThemePalette;\n\n  /**\n   * Event emitted when the checked state of this radio button changes.\n   * Change events are only emitted when the value changes due to user interaction with\n   * the radio button (the same behavior as `<input type-\"radio\">`).\n   */\n  @Output() readonly change: EventEmitter<MatRadioChange> = new EventEmitter<MatRadioChange>();\n\n  /** The parent radio group. May or may not be present. */\n  radioGroup: _MatRadioGroupBase<_MatRadioButtonBase>;\n\n  /** ID of the native input element inside `<mat-radio-button>` */\n  get inputId(): string {\n    return `${this.id || this._uniqueId}-input`;\n  }\n\n  /** Whether this radio is checked. */\n  private _checked: boolean = false;\n\n  /** Whether this radio is disabled. */\n  private _disabled: boolean;\n\n  /** Whether this radio is required. */\n  private _required: boolean;\n\n  /** Value assigned to this radio. */\n  private _value: any = null;\n\n  /** Unregister function for _radioDispatcher */\n  private _removeUniqueSelectionListener: () => void = () => {};\n\n  /** Previous value of the input's tabindex. */\n  private _previousTabIndex: number | undefined;\n\n  /** The native `<input type=radio>` element */\n  @ViewChild('input') _inputElement: ElementRef<HTMLInputElement>;\n\n  /** Whether animations are disabled. */\n  _noopAnimations: boolean;\n\n  constructor(\n    radioGroup: _MatRadioGroupBase<_MatRadioButtonBase>,\n    elementRef: ElementRef,\n    protected _changeDetector: ChangeDetectorRef,\n    private _focusMonitor: FocusMonitor,\n    private _radioDispatcher: UniqueSelectionDispatcher,\n    animationMode?: string,\n    private _providerOverride?: MatRadioDefaultOptions,\n    tabIndex?: string,\n  ) {\n    super(elementRef);\n\n    // Assertions. Ideally these should be stripped out by the compiler.\n    // TODO(jelbourn): Assert that there's no name binding AND a parent radio group.\n    this.radioGroup = radioGroup;\n    this._noopAnimations = animationMode === 'NoopAnimations';\n\n    if (tabIndex) {\n      this.tabIndex = coerceNumberProperty(tabIndex, 0);\n    }\n\n    this._removeUniqueSelectionListener = _radioDispatcher.listen((id: string, name: string) => {\n      if (id !== this.id && name === this.name) {\n        this.checked = false;\n      }\n    });\n  }\n\n  /** Focuses the radio button. */\n  focus(options?: FocusOptions, origin?: FocusOrigin): void {\n    if (origin) {\n      this._focusMonitor.focusVia(this._inputElement, origin, options);\n    } else {\n      this._inputElement.nativeElement.focus(options);\n    }\n  }\n\n  /**\n   * Marks the radio button as needing checking for change detection.\n   * This method is exposed because the parent radio group will directly\n   * update bound properties of the radio button.\n   */\n  _markForCheck() {\n    // When group value changes, the button will not be notified. Use `markForCheck` to explicit\n    // update radio button's status\n    this._changeDetector.markForCheck();\n  }\n\n  ngOnInit() {\n    if (this.radioGroup) {\n      // If the radio is inside a radio group, determine if it should be checked\n      this.checked = this.radioGroup.value === this._value;\n\n      if (this.checked) {\n        this.radioGroup.selected = this;\n      }\n\n      // Copy name from parent radio group\n      this.name = this.radioGroup.name;\n    }\n  }\n\n  ngDoCheck(): void {\n    this._updateTabIndex();\n  }\n\n  ngAfterViewInit() {\n    this._updateTabIndex();\n    this._focusMonitor.monitor(this._elementRef, true).subscribe(focusOrigin => {\n      if (!focusOrigin && this.radioGroup) {\n        this.radioGroup._touch();\n      }\n    });\n  }\n\n  ngOnDestroy() {\n    this._focusMonitor.stopMonitoring(this._elementRef);\n    this._removeUniqueSelectionListener();\n  }\n\n  /** Dispatch change event with current value. */\n  private _emitChangeEvent(): void {\n    this.change.emit(new MatRadioChange(this, this._value));\n  }\n\n  _isRippleDisabled() {\n    return this.disableRipple || this.disabled;\n  }\n\n  _onInputClick(event: Event) {\n    // We have to stop propagation for click events on the visual hidden input element.\n    // By default, when a user clicks on a label element, a generated click event will be\n    // dispatched on the associated input element. Since we are using a label element as our\n    // root container, the click event on the `radio-button` will be executed twice.\n    // The real click event will bubble up, and the generated click event also tries to bubble up.\n    // This will lead to multiple click events.\n    // Preventing bubbling for the second event will solve that issue.\n    event.stopPropagation();\n  }\n\n  /** Triggered when the radio button receives an interaction from the user. */\n  _onInputInteraction(event: Event) {\n    // We always have to stop propagation on the change event.\n    // Otherwise the change event, from the input element, will bubble up and\n    // emit its event object to the `change` output.\n    event.stopPropagation();\n\n    if (!this.checked && !this.disabled) {\n      const groupValueChanged = this.radioGroup && this.value !== this.radioGroup.value;\n      this.checked = true;\n      this._emitChangeEvent();\n\n      if (this.radioGroup) {\n        this.radioGroup._controlValueAccessorChangeFn(this.value);\n        if (groupValueChanged) {\n          this.radioGroup._emitChangeEvent();\n        }\n      }\n    }\n  }\n\n  /** Sets the disabled state and marks for check if a change occurred. */\n  protected _setDisabled(value: boolean) {\n    if (this._disabled !== value) {\n      this._disabled = value;\n      this._changeDetector.markForCheck();\n    }\n  }\n\n  /** Gets the tabindex for the underlying input element. */\n  private _updateTabIndex() {\n    const group = this.radioGroup;\n    let value: number;\n\n    // Implement a roving tabindex if the button is inside a group. For most cases this isn't\n    // necessary, because the browser handles the tab order for inputs inside a group automatically,\n    // but we need an explicitly higher tabindex for the selected button in order for things like\n    // the focus trap to pick it up correctly.\n    if (!group || !group.selected || this.disabled) {\n      value = this.tabIndex;\n    } else {\n      value = group.selected === this ? this.tabIndex : -1;\n    }\n\n    if (value !== this._previousTabIndex) {\n      // We have to set the tabindex directly on the DOM node, because it depends on\n      // the selected state which is prone to \"changed after checked errors\".\n      const input: HTMLInputElement | undefined = this._inputElement?.nativeElement;\n\n      if (input) {\n        input.setAttribute('tabindex', value + '');\n        this._previousTabIndex = value;\n      }\n    }\n  }\n}\n\n/**\n * A Material design radio-button. Typically placed inside of `<mat-radio-group>` elements.\n */\n@Component({\n  selector: 'mat-radio-button',\n  templateUrl: 'radio.html',\n  styleUrls: ['radio.css'],\n  inputs: ['disableRipple', 'tabIndex'],\n  encapsulation: ViewEncapsulation.None,\n  exportAs: 'matRadioButton',\n  host: {\n    'class': 'mat-radio-button',\n    '[class.mat-radio-checked]': 'checked',\n    '[class.mat-radio-disabled]': 'disabled',\n    '[class._mat-animation-noopable]': '_noopAnimations',\n    '[class.mat-primary]': 'color === \"primary\"',\n    '[class.mat-accent]': 'color === \"accent\"',\n    '[class.mat-warn]': 'color === \"warn\"',\n    // Needs to be removed since it causes some a11y issues (see #21266).\n    '[attr.tabindex]': 'null',\n    '[attr.id]': 'id',\n    '[attr.aria-label]': 'null',\n    '[attr.aria-labelledby]': 'null',\n    '[attr.aria-describedby]': 'null',\n    // Note: under normal conditions focus shouldn't land on this element, however it may be\n    // programmatically set, for example inside of a focus trap, in this case we want to forward\n    // the focus to the native element.\n    '(focus)': '_inputElement.nativeElement.focus()',\n  },\n  changeDetection: ChangeDetectionStrategy.OnPush,\n})\nexport class MatRadioButton extends _MatRadioButtonBase {\n  constructor(\n    @Optional() @Inject(MAT_RADIO_GROUP) radioGroup: MatRadioGroup,\n    elementRef: ElementRef,\n    changeDetector: ChangeDetectorRef,\n    focusMonitor: FocusMonitor,\n    radioDispatcher: UniqueSelectionDispatcher,\n    @Optional() @Inject(ANIMATION_MODULE_TYPE) animationMode?: string,\n    @Optional()\n    @Inject(MAT_RADIO_DEFAULT_OPTIONS)\n    providerOverride?: MatRadioDefaultOptions,\n    @Attribute('tabindex') tabIndex?: string,\n  ) {\n    super(\n      radioGroup,\n      elementRef,\n      changeDetector,\n      focusMonitor,\n      radioDispatcher,\n      animationMode,\n      providerOverride,\n      tabIndex,\n    );\n  }\n}\n",null,"<!-- TODO(jelbourn): render the radio on either side of the content -->\n<!-- TODO(mtlin): Evaluate trade-offs of using native radio vs. cost of additional bindings. -->\n<label [attr.for]=\"inputId\" class=\"mat-radio-label\" #label>\n  <!-- The actual 'radio' part of the control. -->\n  <span class=\"mat-radio-container\">\n    <span class=\"mat-radio-outer-circle\"></span>\n    <span class=\"mat-radio-inner-circle\"></span>\n    <input #input class=\"mat-radio-input\" type=\"radio\"\n        [id]=\"inputId\"\n        [checked]=\"checked\"\n        [disabled]=\"disabled\"\n        [attr.name]=\"name\"\n        [attr.value]=\"value\"\n        [required]=\"required\"\n        [attr.aria-label]=\"ariaLabel\"\n        [attr.aria-labelledby]=\"ariaLabelledby\"\n        [attr.aria-describedby]=\"ariaDescribedby\"\n        (change)=\"_onInputInteraction($event)\"\n        (click)=\"_onInputClick($event)\">\n\n    <!-- The ripple comes after the input so that we can target it with a CSS\n         sibling selector when the input is focused. -->\n    <span mat-ripple class=\"mat-radio-ripple mat-focus-indicator\"\n         [matRippleTrigger]=\"label\"\n         [matRippleDisabled]=\"_isRippleDisabled()\"\n         [matRippleCentered]=\"true\"\n         [matRippleRadius]=\"20\"\n         [matRippleAnimation]=\"{enterDuration: _noopAnimations ? 0 : 150}\">\n\n      <span class=\"mat-ripple-element mat-radio-persistent-ripple\"></span>\n    </span>\n  </span>\n\n  <!-- The label content for radio control. -->\n  <span class=\"mat-radio-label-content\" [class.mat-radio-label-before]=\"labelPosition == 'before'\">\n    <!-- Add an invisible span so JAWS can read the label -->\n    <span style=\"display:none\">&nbsp;</span>\n    <ng-content></ng-content>\n  </span>\n</label>\n"],"names":["AsFormControlPipe","constructor","_logger","transform","value","_valueHash","isBlank","FormControl","this","warn","LOGGER","UniqueSelectionDispatcher","_listeners","notify","id","name","listener","listen","push","filter","registered","ngOnDestroy","MatRadioModule","MatRippleModule","MatCommonModule","MAT_RADIO_DEFAULT_OPTIONS","InjectionToken","providedIn","factory","color","nextUniqueId","MAT_RADIO_GROUP_CONTROL_VALUE_ACCESSOR","provide","NG_VALUE_ACCESSOR","useExisting","forwardRef","MatRadioGroup","multi","MatRadioChange","source","MAT_RADIO_GROUP","_MatRadioGroupBase","_changeDetector","_value","_name","_selected","_isInitialized","_labelPosition","_disabled","_required","_controlValueAccessorChangeFn","onTouched","change","EventEmitter","_updateRadioButtonNames","labelPosition","v","_markRadiosForCheck","newValue","_updateSelectedRadioFromValue","_checkSelectedRadioButton","checked","selected","disabled","coerceBooleanProperty","required","ngAfterContentInit","_touch","_radios","forEach","radio","_markForCheck","isAlreadySelected","_emitChangeEvent","emit","writeValue","markForCheck","registerOnChange","fn","registerOnTouched","setDisabledState","isDisabled","i0","MatRadioButton","_MatRadioButtonMixinBase","mixinDisableRipple","mixinTabIndex","_elementRef","_MatRadioButtonBase","radioGroup","elementRef","_focusMonitor","_radioDispatcher","animationMode","_providerOverride","tabIndex","super","_uniqueId","_checked","_removeUniqueSelectionListener","_noopAnimations","coerceNumberProperty","newCheckedState","_setDisabled","_color","inputId","focus","options","origin","focusVia","_inputElement","nativeElement","ngOnInit","ngDoCheck","_updateTabIndex","ngAfterViewInit","monitor","subscribe","focusOrigin","stopMonitoring","_isRippleDisabled","disableRipple","_onInputClick","event","stopPropagation","_onInputInteraction","groupValueChanged","group","_previousTabIndex","input","setAttribute","changeDetector","focusMonitor","radioDispatcher","providerOverride","ANIMATION_MODULE_TYPE","i3"],"sourceRoot":""}