{"version":3,"file":"3366.chunk.f736e2f4c32fab5a164f.js","mappings":"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","sources":["webpack://ng-universal-demo/../../../src/internal/lastValueFrom.ts","webpack://ng-universal-demo/../../../../src/internal/observable/never.ts","webpack://ng-universal-demo/../../../../forms/src/misc/formModel/misc/defaults.ts","webpack://ng-universal-demo/../../../../forms/src/misc/formModel/misc/validatorFactories.ts","webpack://ng-universal-demo/../../../../forms/src/misc/formModel/misc/utils.ts","webpack://ng-universal-demo/../../../../forms/src/services/formModelBuilder/formModelBuilder.service.ts","webpack://ng-universal-demo/../../../../packages/common/src/directives/ng_switch.ts","webpack://ng-universal-demo/../../../../src/material/dialog/dialog-content-directives.ts"],"sourcesContent":[null,null,"import {FormControl} from '@angular/forms';\n\nimport {ModelPropertyDecoratorMetadata} from '../interfaces/modelPropertyDecoratorMetadata';\n\n/**\n * Default value for property metadata\n */\nexport const ɵDefaultPropertyMetadata: ModelPropertyDecoratorMetadata =\n{\n    asyncValidators: [],\n    validators: [],\n    disabled: false,\n    type: FormControl,\n    childType: FormControl,\n    args: {}\n};","import {AsyncValidatorFn, ValidatorFn} from '@angular/forms';\nimport {Dictionary} from '@jscrpt/common';\n\nimport {AsyncValidatorFnFactoryFn, ValidatorFnFactoryFn} from '../interfaces/validator.interface';\n\n/**\n * Class that represents ValidatorFn factory\n */\nexport class ValidatorFnFactory<TArg extends Dictionary<any> = any>\n{\n    //######################### constructor #########################\n    /**\n     * Creates instance of ValidatorFnFactory\n     * @param _factoryFn - Function used for creating ValidatorFn\n     * @param _args - Static arguments/parameters that can be passed to validator\n     */\n    constructor(private _factoryFn?: ValidatorFnFactoryFn<TArg>,\n                private _args?: TArg,)\n    {\n    }\n\n    //######################### public methods #########################\n\n    /**\n     * Gets validator function factory function\n     */\n    public valueOf(): ValidatorFnFactoryFn<TArg>\n    {\n        if(this._args)\n        {\n            return (args: TArg): ValidatorFn =>\n            {\n                args = \n                {\n                    ...this._args,\n                    args\n                };\n\n                return this._factoryFn(args);\n            };\n        }\n\n        return this._factoryFn;\n    }\n}\n\n/**\n * Class that represents AsyncValidatorFn factory\n */\nexport class AsyncValidatorFnFactory<TArg extends Dictionary<any> = any>\n{\n    //######################### constructor #########################\n    /**\n     * Creates instance of AsyncValidatorFnFactory\n     * @param _factoryFn - Function used for creating AsyncValidatorFn\n     * @param _args - Static arguments/parameters that can be passed to validator\n     */\n    constructor(private _factoryFn?: AsyncValidatorFnFactoryFn<TArg>,\n                private _args?: TArg,)\n    {\n    }\n\n    //######################### public methods #########################\n\n    /**\n     * Gets async validator function factory function\n     */\n    public valueOf(): AsyncValidatorFnFactoryFn<TArg>\n    {\n        if(this._args)\n        {\n            return (args: TArg): AsyncValidatorFn =>\n            {\n                args = \n                {\n                    ...this._args,\n                    args\n                };\n\n                return this._factoryFn(args);\n            };\n        }\n\n        return this._factoryFn;\n    }\n}","import {AbstractControl, FormArray, FormControl, FormGroup} from '@angular/forms';\nimport {Dictionary} from '@jscrpt/common';\n\nimport {FormModelGroup} from '../../types';\nimport {FormModelBuilderDefaultArgs} from '../interfaces/formModelBuilder.interface';\nimport {ModelDecoratorMetadata} from '../interfaces/modelDecoratorMetadata';\nimport {ModelPropertyDecoratorMetadata} from '../interfaces/modelPropertyDecoratorMetadata';\nimport {ɵDefaultPropertyMetadata} from './defaults';\nimport {AsyncValidatorFnFactory, ValidatorFnFactory} from './validatorFactories';\n\n/**\n * Builds form group from decorated model\n * @param model - Model that can be decorated for enhancing created form group with validation and so on\n * @param args - Object storing arguments from owning component for customization\n * @returns\n */\nfunction buildFormGroup<TModel, TArgs extends Dictionary<any> = any>(model: ModelDecoratorMetadata<TModel> & Dictionary<any>, args?: TArgs&FormModelBuilderDefaultArgs): FormGroup<FormModelGroup<TModel>>\n{\n    if(!model)\n    {\n        return new FormGroup<FormModelGroup<TModel>>({} as any);\n    }\n\n    const modelMetadata: Dictionary<any> = model.ɵControlsMetadata ?? {};\n    const groupValidators = model.ɵValidators ?? [];\n    const groupAsyncValidators = model.ɵAsyncValidators ?? [];\n    const groupArgs: Dictionary<any> = model.ɵArgs ?? {};\n    const properties = Object.keys(model);\n    const formGroup: FormGroup = new FormGroup({},\n                                               {\n                                                   validators: groupValidators?.map(validator => validator instanceof ValidatorFnFactory ? validator.valueOf()({...groupArgs, ...args}) : validator).filter(itm => !!itm),\n                                                   asyncValidators: groupAsyncValidators?.map(validator => validator instanceof AsyncValidatorFnFactory ? validator.valueOf()({...groupArgs, ...args}) : validator).filter(itm => !!itm)\n                                               });\n\n    for(const propertyName of properties)\n    {\n        const metadata: ModelPropertyDecoratorMetadata = modelMetadata[propertyName] ?? ɵDefaultPropertyMetadata;\n        const defaultValue = model[propertyName];\n\n        //Skip control creation if value is undefined\n        if(defaultValue === undefined)\n        {\n            continue;\n        }\n\n        const validators = metadata.validators.map(validator => validator instanceof ValidatorFnFactory ? validator.valueOf()({...metadata.args, ...args}) : validator).filter(itm => !!itm);\n        const asyncValidators = metadata.asyncValidators.map(validator => validator instanceof AsyncValidatorFnFactory ? validator.valueOf()({...metadata.args, ...args}) : validator).filter(itm => !!itm);\n\n        let control: AbstractControl;\n\n        switch(metadata.type)\n        {\n            case FormGroup:\n            {\n                control = buildFormGroup(defaultValue, args);\n\n                //TODO: think of setting metadata from property to model\n\n                break;\n            }\n            case FormArray:\n            {\n                //TODO - enhance FormArray child definition and finish it\n                control = new FormArray([],\n                                        {\n                                            validators: validators,\n                                            asyncValidators: asyncValidators,\n                                            ...metadata.controlOptions\n                                        });\n\n                if(defaultValue && Array.isArray(defaultValue))\n                {\n                    const formArray = control as FormArray;\n\n                    for(const val of defaultValue)\n                    {\n                        switch(metadata.childType)\n                        {\n                            case FormGroup:\n                            {\n                                formArray.push(buildFormGroup(val, args));\n\n                                break;\n                            }\n                            case FormArray:\n                            {\n                                break;\n                            }\n                            default:\n                            //case FormControl:\n                            {\n                                formArray.push(new FormControl(val,\n                                                               {\n                                                                   validators: validators,\n                                                                   asyncValidators: asyncValidators,\n                                                                   ...metadata.controlOptions\n                                                               }));\n\n                                break;\n                            }\n                        }\n                    }\n                }\n\n                break;\n            }\n            default:\n            //case FormControl:\n            {\n                control = new FormControl(defaultValue,\n                                          {\n                                              validators: validators,\n                                              asyncValidators: asyncValidators,\n                                              ...metadata.controlOptions\n                                          });\n\n                break;\n            }\n        }\n\n        if(metadata.disabled)\n        {\n            control.disable();\n        }\n\n        formGroup.addControl(propertyName, control);\n    }\n\n    return formGroup;\n}\n\n/**\n * Builds form from decorated model, only for properties with non `undefined` value\n * @param model - Model that can be decorated for enhancing created form group with validation and so on\n * @param args - Object storing arguments from owning component for customization\n * @returns\n */\nexport function buildFormModel<TModel, TArgs extends Dictionary<any> = any>(model: TModel, args?: TArgs&FormModelBuilderDefaultArgs): FormGroup<FormModelGroup<TModel>>\n{\n    return buildFormGroup(model as any, args);\n}\n","import {Injectable, Injector} from '@angular/core';\nimport {FormGroup} from '@angular/forms';\nimport {Dictionary} from '@jscrpt/common';\n\nimport {buildFormModel} from '../../misc/formModel';\nimport {FormModelGroup} from '../../misc/types';\n\n/**\n * Instance of form model builder, that creates `FormGroup` from form model, automatically providing `Injector`\n */\n@Injectable()\nexport class FormModelBuilder\n{\n    //######################### constructor #########################\n    constructor(protected _injector: Injector)\n    {\n    }\n\n    //######################### public methods #########################\n\n    /**\n     * Builds form from decorated model, only for properties with non `undefined` value\n     * @param model - Model that can be decorated for enhancing created form group with validation and so on\n     * @param args - Object storing arguments from owning component for customization\n     */\n    public build<TModel, TArgs extends Dictionary<any> = any>(model: TModel, args?: TArgs): FormGroup<FormModelGroup<TModel>>\n    {\n        return buildFormModel<TModel, TArgs>(model,\n                                             {\n                                                 ...args,\n                                                 injector: this._injector,\n                                             });\n    }\n}","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {Directive, DoCheck, Host, Input, Optional, TemplateRef, ViewContainerRef, ɵRuntimeError as RuntimeError} from '@angular/core';\n\nimport {RuntimeErrorCode} from '../errors';\n\nexport class SwitchView {\n  private _created = false;\n\n  constructor(\n      private _viewContainerRef: ViewContainerRef, private _templateRef: TemplateRef<Object>) {}\n\n  create(): void {\n    this._created = true;\n    this._viewContainerRef.createEmbeddedView(this._templateRef);\n  }\n\n  destroy(): void {\n    this._created = false;\n    this._viewContainerRef.clear();\n  }\n\n  enforceState(created: boolean) {\n    if (created && !this._created) {\n      this.create();\n    } else if (!created && this._created) {\n      this.destroy();\n    }\n  }\n}\n\n/**\n * @ngModule CommonModule\n *\n * @description\n * The `[ngSwitch]` directive on a container specifies an expression to match against.\n * The expressions to match are provided by `ngSwitchCase` directives on views within the container.\n * - Every view that matches is rendered.\n * - If there are no matches, a view with the `ngSwitchDefault` directive is rendered.\n * - Elements within the `[NgSwitch]` statement but outside of any `NgSwitchCase`\n * or `ngSwitchDefault` directive are preserved at the location.\n *\n * @usageNotes\n * Define a container element for the directive, and specify the switch expression\n * to match against as an attribute:\n *\n * ```\n * <container-element [ngSwitch]=\"switch_expression\">\n * ```\n *\n * Within the container, `*ngSwitchCase` statements specify the match expressions\n * as attributes. Include `*ngSwitchDefault` as the final case.\n *\n * ```\n * <container-element [ngSwitch]=\"switch_expression\">\n *    <some-element *ngSwitchCase=\"match_expression_1\">...</some-element>\n * ...\n *    <some-element *ngSwitchDefault>...</some-element>\n * </container-element>\n * ```\n *\n * ### Usage Examples\n *\n * The following example shows how to use more than one case to display the same view:\n *\n * ```\n * <container-element [ngSwitch]=\"switch_expression\">\n *   <!-- the same view can be shown in more than one case -->\n *   <some-element *ngSwitchCase=\"match_expression_1\">...</some-element>\n *   <some-element *ngSwitchCase=\"match_expression_2\">...</some-element>\n *   <some-other-element *ngSwitchCase=\"match_expression_3\">...</some-other-element>\n *   <!--default case when there are no matches -->\n *   <some-element *ngSwitchDefault>...</some-element>\n * </container-element>\n * ```\n *\n * The following example shows how cases can be nested:\n * ```\n * <container-element [ngSwitch]=\"switch_expression\">\n *       <some-element *ngSwitchCase=\"match_expression_1\">...</some-element>\n *       <some-element *ngSwitchCase=\"match_expression_2\">...</some-element>\n *       <some-other-element *ngSwitchCase=\"match_expression_3\">...</some-other-element>\n *       <ng-container *ngSwitchCase=\"match_expression_3\">\n *         <!-- use a ng-container to group multiple root nodes -->\n *         <inner-element></inner-element>\n *         <inner-other-element></inner-other-element>\n *       </ng-container>\n *       <some-element *ngSwitchDefault>...</some-element>\n *     </container-element>\n * ```\n *\n * @publicApi\n * @see `NgSwitchCase`\n * @see `NgSwitchDefault`\n * @see [Structural Directives](guide/structural-directives)\n *\n */\n@Directive({\n  selector: '[ngSwitch]',\n  standalone: true,\n})\nexport class NgSwitch {\n  // TODO(issue/24571): remove '!'.\n  private _defaultViews!: SwitchView[];\n  private _defaultUsed = false;\n  private _caseCount = 0;\n  private _lastCaseCheckIndex = 0;\n  private _lastCasesMatched = false;\n  private _ngSwitch: any;\n\n  @Input()\n  set ngSwitch(newValue: any) {\n    this._ngSwitch = newValue;\n    if (this._caseCount === 0) {\n      this._updateDefaultCases(true);\n    }\n  }\n\n  /** @internal */\n  _addCase(): number {\n    return this._caseCount++;\n  }\n\n  /** @internal */\n  _addDefault(view: SwitchView) {\n    if (!this._defaultViews) {\n      this._defaultViews = [];\n    }\n    this._defaultViews.push(view);\n  }\n\n  /** @internal */\n  _matchCase(value: any): boolean {\n    const matched = value == this._ngSwitch;\n    this._lastCasesMatched = this._lastCasesMatched || matched;\n    this._lastCaseCheckIndex++;\n    if (this._lastCaseCheckIndex === this._caseCount) {\n      this._updateDefaultCases(!this._lastCasesMatched);\n      this._lastCaseCheckIndex = 0;\n      this._lastCasesMatched = false;\n    }\n    return matched;\n  }\n\n  private _updateDefaultCases(useDefault: boolean) {\n    if (this._defaultViews && useDefault !== this._defaultUsed) {\n      this._defaultUsed = useDefault;\n      for (let i = 0; i < this._defaultViews.length; i++) {\n        const defaultView = this._defaultViews[i];\n        defaultView.enforceState(useDefault);\n      }\n    }\n  }\n}\n\n/**\n * @ngModule CommonModule\n *\n * @description\n * Provides a switch case expression to match against an enclosing `ngSwitch` expression.\n * When the expressions match, the given `NgSwitchCase` template is rendered.\n * If multiple match expressions match the switch expression value, all of them are displayed.\n *\n * @usageNotes\n *\n * Within a switch container, `*ngSwitchCase` statements specify the match expressions\n * as attributes. Include `*ngSwitchDefault` as the final case.\n *\n * ```\n * <container-element [ngSwitch]=\"switch_expression\">\n *   <some-element *ngSwitchCase=\"match_expression_1\">...</some-element>\n *   ...\n *   <some-element *ngSwitchDefault>...</some-element>\n * </container-element>\n * ```\n *\n * Each switch-case statement contains an in-line HTML template or template reference\n * that defines the subtree to be selected if the value of the match expression\n * matches the value of the switch expression.\n *\n * Unlike JavaScript, which uses strict equality, Angular uses loose equality.\n * This means that the empty string, `\"\"` matches 0.\n *\n * @publicApi\n * @see `NgSwitch`\n * @see `NgSwitchDefault`\n *\n */\n@Directive({\n  selector: '[ngSwitchCase]',\n  standalone: true,\n})\nexport class NgSwitchCase implements DoCheck {\n  private _view: SwitchView;\n  /**\n   * Stores the HTML template to be selected on match.\n   */\n  @Input() ngSwitchCase: any;\n\n  constructor(\n      viewContainer: ViewContainerRef, templateRef: TemplateRef<Object>,\n      @Optional() @Host() private ngSwitch: NgSwitch) {\n    if ((typeof ngDevMode === 'undefined' || ngDevMode) && !ngSwitch) {\n      throwNgSwitchProviderNotFoundError('ngSwitchCase', 'NgSwitchCase');\n    }\n\n    ngSwitch._addCase();\n    this._view = new SwitchView(viewContainer, templateRef);\n  }\n\n  /**\n   * Performs case matching. For internal use only.\n   * @nodoc\n   */\n  ngDoCheck() {\n    this._view.enforceState(this.ngSwitch._matchCase(this.ngSwitchCase));\n  }\n}\n\n/**\n * @ngModule CommonModule\n *\n * @description\n *\n * Creates a view that is rendered when no `NgSwitchCase` expressions\n * match the `NgSwitch` expression.\n * This statement should be the final case in an `NgSwitch`.\n *\n * @publicApi\n * @see `NgSwitch`\n * @see `NgSwitchCase`\n *\n */\n@Directive({\n  selector: '[ngSwitchDefault]',\n  standalone: true,\n})\nexport class NgSwitchDefault {\n  constructor(\n      viewContainer: ViewContainerRef, templateRef: TemplateRef<Object>,\n      @Optional() @Host() ngSwitch: NgSwitch) {\n    if ((typeof ngDevMode === 'undefined' || ngDevMode) && !ngSwitch) {\n      throwNgSwitchProviderNotFoundError('ngSwitchDefault', 'NgSwitchDefault');\n    }\n\n    ngSwitch._addDefault(new SwitchView(viewContainer, templateRef));\n  }\n}\n\nfunction throwNgSwitchProviderNotFoundError(attrName: string, directiveName: string): never {\n  throw new RuntimeError(\n      RuntimeErrorCode.PARENT_NG_SWITCH_NOT_FOUND,\n      `An element with the \"${attrName}\" attribute ` +\n          `(matching the \"${\n              directiveName}\" directive) must be located inside an element with the \"ngSwitch\" attribute ` +\n          `(matching \"NgSwitch\" directive)`);\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {\n  Directive,\n  Input,\n  OnChanges,\n  OnInit,\n  Optional,\n  SimpleChanges,\n  ElementRef,\n} from '@angular/core';\nimport {MatDialog} from './dialog';\nimport {MatDialogRef, _closeDialogVia} from './dialog-ref';\n\n/** Counter used to generate unique IDs for dialog elements. */\nlet dialogElementUid = 0;\n\n/**\n * Button that will close the current dialog.\n */\n@Directive({\n  selector: '[mat-dialog-close], [matDialogClose]',\n  exportAs: 'matDialogClose',\n  host: {\n    '(click)': '_onButtonClick($event)',\n    '[attr.aria-label]': 'ariaLabel || null',\n    '[attr.type]': 'type',\n  },\n})\nexport class MatDialogClose implements OnInit, OnChanges {\n  /** Screen reader label for the button. */\n  @Input('aria-label') ariaLabel: string;\n\n  /** Default to \"button\" to prevents accidental form submits. */\n  @Input() type: 'submit' | 'button' | 'reset' = 'button';\n\n  /** Dialog close input. */\n  @Input('mat-dialog-close') dialogResult: any;\n\n  @Input('matDialogClose') _matDialogClose: any;\n\n  constructor(\n    /**\n     * Reference to the containing dialog.\n     * @deprecated `dialogRef` property to become private.\n     * @breaking-change 13.0.0\n     */\n    // The dialog title directive is always used in combination with a `MatDialogRef`.\n    // tslint:disable-next-line: lightweight-tokens\n    @Optional() public dialogRef: MatDialogRef<any>,\n    private _elementRef: ElementRef<HTMLElement>,\n    private _dialog: MatDialog,\n  ) {}\n\n  ngOnInit() {\n    if (!this.dialogRef) {\n      // When this directive is included in a dialog via TemplateRef (rather than being\n      // in a Component), the DialogRef isn't available via injection because embedded\n      // views cannot be given a custom injector. Instead, we look up the DialogRef by\n      // ID. This must occur in `onInit`, as the ID binding for the dialog container won't\n      // be resolved at constructor time.\n      this.dialogRef = getClosestDialog(this._elementRef, this._dialog.openDialogs)!;\n    }\n  }\n\n  ngOnChanges(changes: SimpleChanges) {\n    const proxiedChange = changes['_matDialogClose'] || changes['_matDialogCloseResult'];\n\n    if (proxiedChange) {\n      this.dialogResult = proxiedChange.currentValue;\n    }\n  }\n\n  _onButtonClick(event: MouseEvent) {\n    // Determinate the focus origin using the click event, because using the FocusMonitor will\n    // result in incorrect origins. Most of the time, close buttons will be auto focused in the\n    // dialog, and therefore clicking the button won't result in a focus change. This means that\n    // the FocusMonitor won't detect any origin change, and will always output `program`.\n    _closeDialogVia(\n      this.dialogRef,\n      event.screenX === 0 && event.screenY === 0 ? 'keyboard' : 'mouse',\n      this.dialogResult,\n    );\n  }\n}\n\n/**\n * Title of a dialog element. Stays fixed to the top of the dialog when scrolling.\n */\n@Directive({\n  selector: '[mat-dialog-title], [matDialogTitle]',\n  exportAs: 'matDialogTitle',\n  host: {\n    'class': 'mat-dialog-title',\n    '[id]': 'id',\n  },\n})\nexport class MatDialogTitle implements OnInit {\n  /** Unique id for the dialog title. If none is supplied, it will be auto-generated. */\n  @Input() id: string = `mat-dialog-title-${dialogElementUid++}`;\n\n  constructor(\n    // The dialog title directive is always used in combination with a `MatDialogRef`.\n    // tslint:disable-next-line: lightweight-tokens\n    @Optional() private _dialogRef: MatDialogRef<any>,\n    private _elementRef: ElementRef<HTMLElement>,\n    private _dialog: MatDialog,\n  ) {}\n\n  ngOnInit() {\n    if (!this._dialogRef) {\n      this._dialogRef = getClosestDialog(this._elementRef, this._dialog.openDialogs)!;\n    }\n\n    if (this._dialogRef) {\n      Promise.resolve().then(() => {\n        const container = this._dialogRef._containerInstance;\n\n        if (container && !container._ariaLabelledBy) {\n          container._ariaLabelledBy = this.id;\n        }\n      });\n    }\n  }\n}\n\n/**\n * Scrollable content container of a dialog.\n */\n@Directive({\n  selector: `[mat-dialog-content], mat-dialog-content, [matDialogContent]`,\n  host: {'class': 'mat-dialog-content'},\n})\nexport class MatDialogContent {}\n\n/**\n * Container for the bottom action buttons in a dialog.\n * Stays fixed to the bottom when scrolling.\n */\n@Directive({\n  selector: `[mat-dialog-actions], mat-dialog-actions, [matDialogActions]`,\n  host: {\n    'class': 'mat-dialog-actions',\n    '[class.mat-dialog-actions-align-center]': 'align === \"center\"',\n    '[class.mat-dialog-actions-align-end]': 'align === \"end\"',\n  },\n})\nexport class MatDialogActions {\n  /**\n   * Horizontal alignment of action buttons.\n   */\n  @Input() align?: 'start' | 'center' | 'end' = 'start';\n}\n\n// TODO(crisbeto): this utility shouldn't be necessary anymore, because the dialog ref is provided\n// both to component and template dialogs through DI. We need to keep it around, because there are\n// some internal wrappers around `MatDialog` that happened to work by accident, because we had this\n// fallback logic in place.\n/**\n * Finds the closest MatDialogRef to an element by looking at the DOM.\n * @param element Element relative to which to look for a dialog.\n * @param openDialogs References to the currently-open dialogs.\n */\nfunction getClosestDialog(element: ElementRef<HTMLElement>, openDialogs: MatDialogRef<any>[]) {\n  let parent: HTMLElement | null = element.nativeElement.parentElement;\n\n  while (parent && !parent.classList.contains('mat-dialog-container')) {\n    parent = parent.parentElement;\n  }\n\n  return parent ? openDialogs.find(dialog => dialog.id === parent!.id) : null;\n}\n"],"names":["lastValueFrom","source","config","hasConfig","Promise","resolve","reject","_value","_hasValue","subscribe","next","value","error","complete","defaultValue","EmptyError","NEVER","Observable","noop","ɵDefaultPropertyMetadata","asyncValidators","validators","disabled","type","FormControl","childType","args","ValidatorFnFactory","constructor","_factoryFn","_args","valueOf","this","AsyncValidatorFnFactory","buildFormGroup","model","FormGroup","modelMetadata","ɵControlsMetadata","groupValidators","ɵValidators","groupAsyncValidators","ɵAsyncValidators","groupArgs","ɵArgs","properties","Object","keys","formGroup","map","validator","filter","itm","propertyName","metadata","undefined","control","FormArray","controlOptions","Array","isArray","formArray","val","push","disable","addControl","buildFormModel","FormModelBuilder","_injector","build","injector","i0","SwitchView","_viewContainerRef","_templateRef","_created","create","createEmbeddedView","destroy","clear","enforceState","created","NgSwitch","_defaultUsed","_caseCount","_lastCaseCheckIndex","_lastCasesMatched","ngSwitch","newValue","_ngSwitch","_updateDefaultCases","_addCase","_addDefault","view","_defaultViews","_matchCase","matched","useDefault","i","length","NgSwitchCase","viewContainer","templateRef","_view","ngDoCheck","ngSwitchCase","NgSwitchDefault","dialogElementUid","MatDialogClose","dialogRef","_elementRef","_dialog","ngOnInit","getClosestDialog","openDialogs","ngOnChanges","changes","proxiedChange","dialogResult","currentValue","_onButtonClick","event","_closeDialogVia","screenX","screenY","i1","MatDialogTitle","_dialogRef","id","then","container","_containerInstance","_ariaLabelledBy","MatDialogContent","MatDialogActions","align","element","parent","nativeElement","parentElement","classList","contains","find","dialog"],"sourceRoot":""}