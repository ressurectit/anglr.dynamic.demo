{"version":3,"file":"2351.chunk.9626cd39dfe641191174.js","mappings":"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","sources":["webpack://ng-universal-demo/../../../../forms/src/modules/formPipes/pipes/asFormControl/asFormControl.pipe.ts","webpack://ng-universal-demo/../../../../src/modules/castPipes/modules/castPipes.module.ts","webpack://ng-universal-demo/../../../../src/cdk/coercion/boolean-property.ts","webpack://ng-universal-demo/../../../../src/cdk/collections/unique-selection-dispatcher.ts","webpack://ng-universal-demo/../../../../src/material/core/common-behaviors/disable-ripple.ts","webpack://ng-universal-demo/../../../../src/material/core/common-behaviors/tabindex.ts","webpack://ng-universal-demo/../../../../src/material/radio/module.ts","webpack://ng-universal-demo/../../../../src/material/radio/radio.ts","webpack://ng-universal-demo/../../../../src/material/radio/radio.html"],"sourcesContent":["import {Inject, Optional, Pipe} from '@angular/core';\nimport {AbstractControl, FormControl} from '@angular/forms';\nimport {Logger, LOGGER} from '@anglr/common';\nimport {isBlank} from '@jscrpt/common';\n\n/**\n * Tries to convert `AbstractControl` to `FormControl`\n */\n@Pipe({name: 'asFormControl'})\nexport class AsFormControlPipe\n{\n    //######################### constructors #########################\n    constructor(@Optional() @Inject(LOGGER) private _logger?: Logger)\n    {\n    }\n\n    //######################### public methods - implementation of PipeTransform #########################\n\n    /**\n     * Allows casting of `AbstractControl` to `FormControl`\n     * @param value - `AbstractControl` to be cast to `FormControl`\n     * @param _valueHash - Parameter that can be used to change value, indicates that pipe input value has changed\n     */\n    public transform<TModel>(value: AbstractControl<TModel>|null|undefined, _valueHash?: any): FormControl<TModel>|null\n    {\n        if(isBlank(value))\n        {\n            return null;\n        }\n\n        if(value instanceof FormControl)\n        {\n            return value as FormControl<TModel>;\n        }\n\n        this._logger?.warn('Failed to cast AbstractControl to FormControl');\n\n        return null;\n    }\n}","import {NgModule} from '@angular/core';\n\nimport {AsHtmlElementPipe, AsNgClassRequiredPipe, AsRequiredTypePipe, CastTypePipe} from '../pipes';\n\n/**\n * Module that holds cast pipes\n */\n@NgModule(\n{\n    declarations:\n    [\n        AsHtmlElementPipe,\n        AsNgClassRequiredPipe,\n        AsRequiredTypePipe,\n        CastTypePipe,\n    ],\n    exports:\n    [\n        AsHtmlElementPipe,\n        AsNgClassRequiredPipe,\n        AsRequiredTypePipe,\n        CastTypePipe,\n    ]\n})\nexport class CastPipesModule\n{\n}","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * Type describing the allowed values for a boolean input.\n * @docs-private\n */\nexport type BooleanInput = string | boolean | null | undefined;\n\n/** Coerces a data-bound value (typically a string) to a boolean. */\nexport function coerceBooleanProperty(value: any): boolean {\n  return value != null && `${value}` !== 'false';\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {Injectable, OnDestroy} from '@angular/core';\n\n// Users of the Dispatcher never need to see this type, but TypeScript requires it to be exported.\nexport type UniqueSelectionDispatcherListener = (id: string, name: string) => void;\n\n/**\n * Class to coordinate unique selection based on name.\n * Intended to be consumed as an Angular service.\n * This service is needed because native radio change events are only fired on the item currently\n * being selected, and we still need to uncheck the previous selection.\n *\n * This service does not *store* any IDs and names because they may change at any time, so it is\n * less error-prone if they are simply passed through when the events occur.\n */\n@Injectable({providedIn: 'root'})\nexport class UniqueSelectionDispatcher implements OnDestroy {\n  private _listeners: UniqueSelectionDispatcherListener[] = [];\n\n  /**\n   * Notify other items that selection for the given name has been set.\n   * @param id ID of the item.\n   * @param name Name of the item.\n   */\n  notify(id: string, name: string) {\n    for (let listener of this._listeners) {\n      listener(id, name);\n    }\n  }\n\n  /**\n   * Listen for future changes to item selection.\n   * @return Function used to deregister listener\n   */\n  listen(listener: UniqueSelectionDispatcherListener): () => void {\n    this._listeners.push(listener);\n    return () => {\n      this._listeners = this._listeners.filter((registered: UniqueSelectionDispatcherListener) => {\n        return listener !== registered;\n      });\n    };\n  }\n\n  ngOnDestroy() {\n    this._listeners = [];\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {coerceBooleanProperty} from '@angular/cdk/coercion';\nimport {AbstractConstructor, Constructor} from './constructor';\n\n/** @docs-private */\nexport interface CanDisableRipple {\n  /** Whether ripples are disabled. */\n  disableRipple: boolean;\n}\n\ntype CanDisableRippleCtor = Constructor<CanDisableRipple> & AbstractConstructor<CanDisableRipple>;\n\n/** Mixin to augment a directive with a `disableRipple` property. */\nexport function mixinDisableRipple<T extends AbstractConstructor<{}>>(\n  base: T,\n): CanDisableRippleCtor & T;\nexport function mixinDisableRipple<T extends Constructor<{}>>(base: T): CanDisableRippleCtor & T {\n  return class extends base {\n    private _disableRipple: boolean = false;\n\n    /** Whether the ripple effect is disabled or not. */\n    get disableRipple(): boolean {\n      return this._disableRipple;\n    }\n    set disableRipple(value: any) {\n      this._disableRipple = coerceBooleanProperty(value);\n    }\n\n    constructor(...args: any[]) {\n      super(...args);\n    }\n  };\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {coerceNumberProperty} from '@angular/cdk/coercion';\nimport {Constructor, AbstractConstructor} from './constructor';\nimport {CanDisable} from './disabled';\n\n/** @docs-private */\nexport interface HasTabIndex {\n  /** Tabindex of the component. */\n  tabIndex: number;\n\n  /** Tabindex to which to fall back to if no value is set. */\n  defaultTabIndex: number;\n}\n\ntype HasTabIndexCtor = Constructor<HasTabIndex> & AbstractConstructor<HasTabIndex>;\n\n/** Mixin to augment a directive with a `tabIndex` property. */\nexport function mixinTabIndex<T extends AbstractConstructor<CanDisable>>(\n  base: T,\n  defaultTabIndex?: number,\n): HasTabIndexCtor & T;\nexport function mixinTabIndex<T extends Constructor<CanDisable>>(\n  base: T,\n  defaultTabIndex = 0,\n): HasTabIndexCtor & T {\n  return class extends base implements HasTabIndex {\n    private _tabIndex: number = defaultTabIndex;\n    defaultTabIndex = defaultTabIndex;\n\n    get tabIndex(): number {\n      return this.disabled ? -1 : this._tabIndex;\n    }\n    set tabIndex(value: number) {\n      // If the specified tabIndex value is null or undefined, fall back to the default value.\n      this._tabIndex = value != null ? coerceNumberProperty(value) : this.defaultTabIndex;\n    }\n\n    constructor(...args: any[]) {\n      super(...args);\n    }\n  };\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {CommonModule} from '@angular/common';\nimport {NgModule} from '@angular/core';\nimport {MatCommonModule, MatRippleModule} from '@angular/material/core';\nimport {MatRadioButton, MatRadioGroup} from './radio';\n\n@NgModule({\n  imports: [MatCommonModule, CommonModule, MatRippleModule],\n  exports: [MatCommonModule, MatRadioGroup, MatRadioButton],\n  declarations: [MatRadioGroup, MatRadioButton],\n})\nexport class MatRadioModule {}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {\n  AfterContentInit,\n  AfterViewInit,\n  Attribute,\n  ChangeDetectionStrategy,\n  ChangeDetectorRef,\n  Component,\n  ContentChildren,\n  Directive,\n  DoCheck,\n  ElementRef,\n  EventEmitter,\n  forwardRef,\n  Inject,\n  InjectionToken,\n  Input,\n  OnDestroy,\n  OnInit,\n  Optional,\n  Output,\n  QueryList,\n  ViewChild,\n  ViewEncapsulation,\n} from '@angular/core';\nimport {\n  CanDisableRipple,\n  HasTabIndex,\n  mixinDisableRipple,\n  mixinTabIndex,\n  ThemePalette,\n} from '@angular/material/core';\nimport {FocusMonitor, FocusOrigin} from '@angular/cdk/a11y';\nimport {BooleanInput, coerceBooleanProperty, coerceNumberProperty} from '@angular/cdk/coercion';\nimport {UniqueSelectionDispatcher} from '@angular/cdk/collections';\nimport {ANIMATION_MODULE_TYPE} from '@angular/platform-browser/animations';\nimport {ControlValueAccessor, NG_VALUE_ACCESSOR} from '@angular/forms';\nimport {Subscription} from 'rxjs';\n\n// Increasing integer for generating unique ids for radio components.\nlet nextUniqueId = 0;\n\n/** Change event object emitted by radio button and radio group. */\nexport class MatRadioChange {\n  constructor(\n    /** The radio button that emits the change event. */\n    public source: MatRadioButton,\n    /** The value of the radio button. */\n    public value: any,\n  ) {}\n}\n\n/**\n * Provider Expression that allows mat-radio-group to register as a ControlValueAccessor. This\n * allows it to support [(ngModel)] and ngControl.\n * @docs-private\n */\nexport const MAT_RADIO_GROUP_CONTROL_VALUE_ACCESSOR: any = {\n  provide: NG_VALUE_ACCESSOR,\n  useExisting: forwardRef(() => MatRadioGroup),\n  multi: true,\n};\n\n/**\n * Injection token that can be used to inject instances of `MatRadioGroup`. It serves as\n * alternative token to the actual `MatRadioGroup` class which could cause unnecessary\n * retention of the class and its component metadata.\n */\nexport const MAT_RADIO_GROUP = new InjectionToken<MatRadioGroup>('MatRadioGroup');\n\nexport interface MatRadioDefaultOptions {\n  color: ThemePalette;\n}\n\nexport const MAT_RADIO_DEFAULT_OPTIONS = new InjectionToken<MatRadioDefaultOptions>(\n  'mat-radio-default-options',\n  {\n    providedIn: 'root',\n    factory: MAT_RADIO_DEFAULT_OPTIONS_FACTORY,\n  },\n);\n\nexport function MAT_RADIO_DEFAULT_OPTIONS_FACTORY(): MatRadioDefaultOptions {\n  return {\n    color: 'accent',\n  };\n}\n\n/**\n * A group of radio buttons. May contain one or more `<mat-radio-button>` elements.\n */\n@Directive({\n  selector: 'mat-radio-group',\n  exportAs: 'matRadioGroup',\n  providers: [\n    MAT_RADIO_GROUP_CONTROL_VALUE_ACCESSOR,\n    {provide: MAT_RADIO_GROUP, useExisting: MatRadioGroup},\n  ],\n  host: {\n    'role': 'radiogroup',\n    'class': 'mat-mdc-radio-group',\n  },\n})\nexport class MatRadioGroup implements AfterContentInit, OnDestroy, ControlValueAccessor {\n  /** Selected value for the radio group. */\n  private _value: any = null;\n\n  /** The HTML name attribute applied to radio buttons in this group. */\n  private _name: string = `mat-radio-group-${nextUniqueId++}`;\n\n  /** The currently selected radio button. Should match value. */\n  private _selected: MatRadioButton | null = null;\n\n  /** Whether the `value` has been set to its initial value. */\n  private _isInitialized: boolean = false;\n\n  /** Whether the labels should appear after or before the radio-buttons. Defaults to 'after' */\n  private _labelPosition: 'before' | 'after' = 'after';\n\n  /** Whether the radio group is disabled. */\n  private _disabled: boolean = false;\n\n  /** Whether the radio group is required. */\n  private _required: boolean = false;\n\n  /** Subscription to changes in amount of radio buttons. */\n  private _buttonChanges: Subscription;\n\n  /** The method to be called in order to update ngModel */\n  _controlValueAccessorChangeFn: (value: any) => void = () => {};\n\n  /**\n   * onTouch function registered via registerOnTouch (ControlValueAccessor).\n   * @docs-private\n   */\n  onTouched: () => any = () => {};\n\n  /**\n   * Event emitted when the group value changes.\n   * Change events are only emitted when the value changes due to user interaction with\n   * a radio button (the same behavior as `<input type-\"radio\">`).\n   */\n  @Output() readonly change: EventEmitter<MatRadioChange> = new EventEmitter<MatRadioChange>();\n\n  /** Child radio buttons. */\n  @ContentChildren(forwardRef(() => MatRadioButton), {descendants: true})\n  _radios: QueryList<MatRadioButton>;\n\n  /** Theme color for all of the radio buttons in the group. */\n  @Input() color: ThemePalette;\n\n  /** Name of the radio button group. All radio buttons inside this group will use this name. */\n  @Input()\n  get name(): string {\n    return this._name;\n  }\n  set name(value: string) {\n    this._name = value;\n    this._updateRadioButtonNames();\n  }\n\n  /** Whether the labels should appear after or before the radio-buttons. Defaults to 'after' */\n  @Input()\n  get labelPosition(): 'before' | 'after' {\n    return this._labelPosition;\n  }\n  set labelPosition(v) {\n    this._labelPosition = v === 'before' ? 'before' : 'after';\n    this._markRadiosForCheck();\n  }\n\n  /**\n   * Value for the radio-group. Should equal the value of the selected radio button if there is\n   * a corresponding radio button with a matching value. If there is not such a corresponding\n   * radio button, this value persists to be applied in case a new radio button is added with a\n   * matching value.\n   */\n  @Input()\n  get value(): any {\n    return this._value;\n  }\n  set value(newValue: any) {\n    if (this._value !== newValue) {\n      // Set this before proceeding to ensure no circular loop occurs with selection.\n      this._value = newValue;\n\n      this._updateSelectedRadioFromValue();\n      this._checkSelectedRadioButton();\n    }\n  }\n\n  _checkSelectedRadioButton() {\n    if (this._selected && !this._selected.checked) {\n      this._selected.checked = true;\n    }\n  }\n\n  /**\n   * The currently selected radio button. If set to a new radio button, the radio group value\n   * will be updated to match the new selected button.\n   */\n  @Input()\n  get selected() {\n    return this._selected;\n  }\n  set selected(selected: MatRadioButton | null) {\n    this._selected = selected;\n    this.value = selected ? selected.value : null;\n    this._checkSelectedRadioButton();\n  }\n\n  /** Whether the radio group is disabled */\n  @Input()\n  get disabled(): boolean {\n    return this._disabled;\n  }\n  set disabled(value: BooleanInput) {\n    this._disabled = coerceBooleanProperty(value);\n    this._markRadiosForCheck();\n  }\n\n  /** Whether the radio group is required */\n  @Input()\n  get required(): boolean {\n    return this._required;\n  }\n  set required(value: BooleanInput) {\n    this._required = coerceBooleanProperty(value);\n    this._markRadiosForCheck();\n  }\n\n  constructor(private _changeDetector: ChangeDetectorRef) {}\n\n  /**\n   * Initialize properties once content children are available.\n   * This allows us to propagate relevant attributes to associated buttons.\n   */\n  ngAfterContentInit() {\n    // Mark this component as initialized in AfterContentInit because the initial value can\n    // possibly be set by NgModel on MatRadioGroup, and it is possible that the OnInit of the\n    // NgModel occurs *after* the OnInit of the MatRadioGroup.\n    this._isInitialized = true;\n\n    // Clear the `selected` button when it's destroyed since the tabindex of the rest of the\n    // buttons depends on it. Note that we don't clear the `value`, because the radio button\n    // may be swapped out with a similar one and there are some internal apps that depend on\n    // that behavior.\n    this._buttonChanges = this._radios.changes.subscribe(() => {\n      if (this.selected && !this._radios.find(radio => radio === this.selected)) {\n        this._selected = null;\n      }\n    });\n  }\n\n  ngOnDestroy() {\n    this._buttonChanges?.unsubscribe();\n  }\n\n  /**\n   * Mark this group as being \"touched\" (for ngModel). Meant to be called by the contained\n   * radio buttons upon their blur.\n   */\n  _touch() {\n    if (this.onTouched) {\n      this.onTouched();\n    }\n  }\n\n  private _updateRadioButtonNames(): void {\n    if (this._radios) {\n      this._radios.forEach(radio => {\n        radio.name = this.name;\n        radio._markForCheck();\n      });\n    }\n  }\n\n  /** Updates the `selected` radio button from the internal _value state. */\n  private _updateSelectedRadioFromValue(): void {\n    // If the value already matches the selected radio, do nothing.\n    const isAlreadySelected = this._selected !== null && this._selected.value === this._value;\n\n    if (this._radios && !isAlreadySelected) {\n      this._selected = null;\n      this._radios.forEach(radio => {\n        radio.checked = this.value === radio.value;\n        if (radio.checked) {\n          this._selected = radio;\n        }\n      });\n    }\n  }\n\n  /** Dispatch change event with current selection and group value. */\n  _emitChangeEvent(): void {\n    if (this._isInitialized) {\n      this.change.emit(new MatRadioChange(this._selected!, this._value));\n    }\n  }\n\n  _markRadiosForCheck() {\n    if (this._radios) {\n      this._radios.forEach(radio => radio._markForCheck());\n    }\n  }\n\n  /**\n   * Sets the model value. Implemented as part of ControlValueAccessor.\n   * @param value\n   */\n  writeValue(value: any) {\n    this.value = value;\n    this._changeDetector.markForCheck();\n  }\n\n  /**\n   * Registers a callback to be triggered when the model value changes.\n   * Implemented as part of ControlValueAccessor.\n   * @param fn Callback to be registered.\n   */\n  registerOnChange(fn: (value: any) => void) {\n    this._controlValueAccessorChangeFn = fn;\n  }\n\n  /**\n   * Registers a callback to be triggered when the control is touched.\n   * Implemented as part of ControlValueAccessor.\n   * @param fn Callback to be registered.\n   */\n  registerOnTouched(fn: any) {\n    this.onTouched = fn;\n  }\n\n  /**\n   * Sets the disabled state of the control. Implemented as a part of ControlValueAccessor.\n   * @param isDisabled Whether the control should be disabled.\n   */\n  setDisabledState(isDisabled: boolean) {\n    this.disabled = isDisabled;\n    this._changeDetector.markForCheck();\n  }\n}\n\n// Boilerplate for applying mixins to MatRadioButton.\n/** @docs-private */\nabstract class MatRadioButtonBase {\n  // Since the disabled property is manually defined for the MatRadioButton and isn't set up in\n  // the mixin base class. To be able to use the tabindex mixin, a disabled property must be\n  // defined to properly work.\n  abstract disabled: boolean;\n  constructor(public _elementRef: ElementRef) {}\n}\n\nconst _MatRadioButtonMixinBase = mixinDisableRipple(mixinTabIndex(MatRadioButtonBase));\n\n@Component({\n  selector: 'mat-radio-button',\n  templateUrl: 'radio.html',\n  styleUrls: ['radio.css'],\n  host: {\n    'class': 'mat-mdc-radio-button',\n    '[attr.id]': 'id',\n    '[class.mat-primary]': 'color === \"primary\"',\n    '[class.mat-accent]': 'color === \"accent\"',\n    '[class.mat-warn]': 'color === \"warn\"',\n    '[class.mat-mdc-radio-checked]': 'checked',\n    '[class._mat-animation-noopable]': '_noopAnimations',\n    // Needs to be removed since it causes some a11y issues (see #21266).\n    '[attr.tabindex]': 'null',\n    '[attr.aria-label]': 'null',\n    '[attr.aria-labelledby]': 'null',\n    '[attr.aria-describedby]': 'null',\n    // Note: under normal conditions focus shouldn't land on this element, however it may be\n    // programmatically set, for example inside of a focus trap, in this case we want to forward\n    // the focus to the native element.\n    '(focus)': '_inputElement.nativeElement.focus()',\n  },\n  inputs: ['disableRipple', 'tabIndex'],\n  exportAs: 'matRadioButton',\n  encapsulation: ViewEncapsulation.None,\n  changeDetection: ChangeDetectionStrategy.OnPush,\n})\nexport class MatRadioButton\n  extends _MatRadioButtonMixinBase\n  implements OnInit, AfterViewInit, DoCheck, OnDestroy, CanDisableRipple, HasTabIndex\n{\n  private _uniqueId: string = `mat-radio-${++nextUniqueId}`;\n\n  /** The unique ID for the radio button. */\n  @Input() id: string = this._uniqueId;\n\n  /** Analog to HTML 'name' attribute used to group radios for unique selection. */\n  @Input() name: string;\n\n  /** Used to set the 'aria-label' attribute on the underlying input element. */\n  @Input('aria-label') ariaLabel: string;\n\n  /** The 'aria-labelledby' attribute takes precedence as the element's text alternative. */\n  @Input('aria-labelledby') ariaLabelledby: string;\n\n  /** The 'aria-describedby' attribute is read after the element's label and field type. */\n  @Input('aria-describedby') ariaDescribedby: string;\n\n  /** Whether this radio button is checked. */\n  @Input()\n  get checked(): boolean {\n    return this._checked;\n  }\n  set checked(value: BooleanInput) {\n    const newCheckedState = coerceBooleanProperty(value);\n    if (this._checked !== newCheckedState) {\n      this._checked = newCheckedState;\n      if (newCheckedState && this.radioGroup && this.radioGroup.value !== this.value) {\n        this.radioGroup.selected = this;\n      } else if (!newCheckedState && this.radioGroup && this.radioGroup.value === this.value) {\n        // When unchecking the selected radio button, update the selected radio\n        // property on the group.\n        this.radioGroup.selected = null;\n      }\n\n      if (newCheckedState) {\n        // Notify all radio buttons with the same name to un-check.\n        this._radioDispatcher.notify(this.id, this.name);\n      }\n      this._changeDetector.markForCheck();\n    }\n  }\n\n  /** The value of this radio button. */\n  @Input()\n  get value(): any {\n    return this._value;\n  }\n  set value(value: any) {\n    if (this._value !== value) {\n      this._value = value;\n      if (this.radioGroup !== null) {\n        if (!this.checked) {\n          // Update checked when the value changed to match the radio group's value\n          this.checked = this.radioGroup.value === value;\n        }\n        if (this.checked) {\n          this.radioGroup.selected = this;\n        }\n      }\n    }\n  }\n\n  /** Whether the label should appear after or before the radio button. Defaults to 'after' */\n  @Input()\n  get labelPosition(): 'before' | 'after' {\n    return this._labelPosition || (this.radioGroup && this.radioGroup.labelPosition) || 'after';\n  }\n  set labelPosition(value) {\n    this._labelPosition = value;\n  }\n  private _labelPosition: 'before' | 'after';\n\n  /** Whether the radio button is disabled. */\n  @Input()\n  get disabled(): boolean {\n    return this._disabled || (this.radioGroup !== null && this.radioGroup.disabled);\n  }\n  set disabled(value: BooleanInput) {\n    this._setDisabled(coerceBooleanProperty(value));\n  }\n\n  /** Whether the radio button is required. */\n  @Input()\n  get required(): boolean {\n    return this._required || (this.radioGroup && this.radioGroup.required);\n  }\n  set required(value: BooleanInput) {\n    this._required = coerceBooleanProperty(value);\n  }\n\n  /** Theme color of the radio button. */\n  @Input()\n  get color(): ThemePalette {\n    // As per Material design specifications the selection control radio should use the accent color\n    // palette by default. https://material.io/guidelines/components/selection-controls.html\n    return (\n      this._color ||\n      (this.radioGroup && this.radioGroup.color) ||\n      (this._providerOverride && this._providerOverride.color) ||\n      'accent'\n    );\n  }\n  set color(newValue: ThemePalette) {\n    this._color = newValue;\n  }\n  private _color: ThemePalette;\n\n  /**\n   * Event emitted when the checked state of this radio button changes.\n   * Change events are only emitted when the value changes due to user interaction with\n   * the radio button (the same behavior as `<input type-\"radio\">`).\n   */\n  @Output() readonly change: EventEmitter<MatRadioChange> = new EventEmitter<MatRadioChange>();\n\n  /** The parent radio group. May or may not be present. */\n  radioGroup: MatRadioGroup;\n\n  /** ID of the native input element inside `<mat-radio-button>` */\n  get inputId(): string {\n    return `${this.id || this._uniqueId}-input`;\n  }\n\n  /** Whether this radio is checked. */\n  private _checked: boolean = false;\n\n  /** Whether this radio is disabled. */\n  private _disabled: boolean;\n\n  /** Whether this radio is required. */\n  private _required: boolean;\n\n  /** Value assigned to this radio. */\n  private _value: any = null;\n\n  /** Unregister function for _radioDispatcher */\n  private _removeUniqueSelectionListener: () => void = () => {};\n\n  /** Previous value of the input's tabindex. */\n  private _previousTabIndex: number | undefined;\n\n  /** The native `<input type=radio>` element */\n  @ViewChild('input') _inputElement: ElementRef<HTMLInputElement>;\n\n  /** Whether animations are disabled. */\n  _noopAnimations: boolean;\n\n  constructor(\n    @Optional() @Inject(MAT_RADIO_GROUP) radioGroup: MatRadioGroup,\n    elementRef: ElementRef,\n    private _changeDetector: ChangeDetectorRef,\n    private _focusMonitor: FocusMonitor,\n    private _radioDispatcher: UniqueSelectionDispatcher,\n    @Optional() @Inject(ANIMATION_MODULE_TYPE) animationMode?: string,\n    @Optional()\n    @Inject(MAT_RADIO_DEFAULT_OPTIONS)\n    private _providerOverride?: MatRadioDefaultOptions,\n    @Attribute('tabindex') tabIndex?: string,\n  ) {\n    super(elementRef);\n\n    // Assertions. Ideally these should be stripped out by the compiler.\n    // TODO(jelbourn): Assert that there's no name binding AND a parent radio group.\n    this.radioGroup = radioGroup;\n    this._noopAnimations = animationMode === 'NoopAnimations';\n\n    if (tabIndex) {\n      this.tabIndex = coerceNumberProperty(tabIndex, 0);\n    }\n  }\n\n  /** Focuses the radio button. */\n  focus(options?: FocusOptions, origin?: FocusOrigin): void {\n    if (origin) {\n      this._focusMonitor.focusVia(this._inputElement, origin, options);\n    } else {\n      this._inputElement.nativeElement.focus(options);\n    }\n  }\n\n  /**\n   * Marks the radio button as needing checking for change detection.\n   * This method is exposed because the parent radio group will directly\n   * update bound properties of the radio button.\n   */\n  _markForCheck() {\n    // When group value changes, the button will not be notified. Use `markForCheck` to explicit\n    // update radio button's status\n    this._changeDetector.markForCheck();\n  }\n\n  ngOnInit() {\n    if (this.radioGroup) {\n      // If the radio is inside a radio group, determine if it should be checked\n      this.checked = this.radioGroup.value === this._value;\n\n      if (this.checked) {\n        this.radioGroup.selected = this;\n      }\n\n      // Copy name from parent radio group\n      this.name = this.radioGroup.name;\n    }\n\n    this._removeUniqueSelectionListener = this._radioDispatcher.listen((id, name) => {\n      if (id !== this.id && name === this.name) {\n        this.checked = false;\n      }\n    });\n  }\n\n  ngDoCheck(): void {\n    this._updateTabIndex();\n  }\n\n  ngAfterViewInit() {\n    this._updateTabIndex();\n    this._focusMonitor.monitor(this._elementRef, true).subscribe(focusOrigin => {\n      if (!focusOrigin && this.radioGroup) {\n        this.radioGroup._touch();\n      }\n    });\n  }\n\n  ngOnDestroy() {\n    this._focusMonitor.stopMonitoring(this._elementRef);\n    this._removeUniqueSelectionListener();\n  }\n\n  /** Dispatch change event with current value. */\n  private _emitChangeEvent(): void {\n    this.change.emit(new MatRadioChange(this, this._value));\n  }\n\n  _isRippleDisabled() {\n    return this.disableRipple || this.disabled;\n  }\n\n  _onInputClick(event: Event) {\n    // We have to stop propagation for click events on the visual hidden input element.\n    // By default, when a user clicks on a label element, a generated click event will be\n    // dispatched on the associated input element. Since we are using a label element as our\n    // root container, the click event on the `radio-button` will be executed twice.\n    // The real click event will bubble up, and the generated click event also tries to bubble up.\n    // This will lead to multiple click events.\n    // Preventing bubbling for the second event will solve that issue.\n    event.stopPropagation();\n  }\n\n  /** Triggered when the radio button receives an interaction from the user. */\n  _onInputInteraction(event: Event) {\n    // We always have to stop propagation on the change event.\n    // Otherwise the change event, from the input element, will bubble up and\n    // emit its event object to the `change` output.\n    event.stopPropagation();\n\n    if (!this.checked && !this.disabled) {\n      const groupValueChanged = this.radioGroup && this.value !== this.radioGroup.value;\n      this.checked = true;\n      this._emitChangeEvent();\n\n      if (this.radioGroup) {\n        this.radioGroup._controlValueAccessorChangeFn(this.value);\n        if (groupValueChanged) {\n          this.radioGroup._emitChangeEvent();\n        }\n      }\n    }\n  }\n\n  /** Triggered when the user clicks on the touch target. */\n  _onTouchTargetClick(event: Event) {\n    this._onInputInteraction(event);\n\n    if (!this.disabled) {\n      // Normally the input should be focused already, but if the click\n      // comes from the touch target, then we might have to focus it ourselves.\n      this._inputElement.nativeElement.focus();\n    }\n  }\n\n  /** Sets the disabled state and marks for check if a change occurred. */\n  protected _setDisabled(value: boolean) {\n    if (this._disabled !== value) {\n      this._disabled = value;\n      this._changeDetector.markForCheck();\n    }\n  }\n\n  /** Gets the tabindex for the underlying input element. */\n  private _updateTabIndex() {\n    const group = this.radioGroup;\n    let value: number;\n\n    // Implement a roving tabindex if the button is inside a group. For most cases this isn't\n    // necessary, because the browser handles the tab order for inputs inside a group automatically,\n    // but we need an explicitly higher tabindex for the selected button in order for things like\n    // the focus trap to pick it up correctly.\n    if (!group || !group.selected || this.disabled) {\n      value = this.tabIndex;\n    } else {\n      value = group.selected === this ? this.tabIndex : -1;\n    }\n\n    if (value !== this._previousTabIndex) {\n      // We have to set the tabindex directly on the DOM node, because it depends on\n      // the selected state which is prone to \"changed after checked errors\".\n      const input: HTMLInputElement | undefined = this._inputElement?.nativeElement;\n\n      if (input) {\n        input.setAttribute('tabindex', value + '');\n        this._previousTabIndex = value;\n      }\n    }\n  }\n}\n","<div class=\"mdc-form-field\" #formField\n     [class.mdc-form-field--align-end]=\"labelPosition == 'before'\">\n  <div class=\"mdc-radio\" [class.mdc-radio--disabled]=\"disabled\">\n    <!-- Render this element first so the input is on top. -->\n    <div class=\"mat-mdc-radio-touch-target\" (click)=\"_onTouchTargetClick($event)\"></div>\n    <input #input class=\"mdc-radio__native-control\" type=\"radio\"\n           [id]=\"inputId\"\n           [checked]=\"checked\"\n           [disabled]=\"disabled\"\n           [attr.name]=\"name\"\n           [attr.value]=\"value\"\n           [required]=\"required\"\n           [attr.aria-label]=\"ariaLabel\"\n           [attr.aria-labelledby]=\"ariaLabelledby\"\n           [attr.aria-describedby]=\"ariaDescribedby\"\n           (change)=\"_onInputInteraction($event)\">\n    <div class=\"mdc-radio__background\">\n      <div class=\"mdc-radio__outer-circle\"></div>\n      <div class=\"mdc-radio__inner-circle\"></div>\n    </div>\n    <div mat-ripple class=\"mat-radio-ripple mat-mdc-focus-indicator\"\n         [matRippleTrigger]=\"formField\"\n         [matRippleDisabled]=\"_isRippleDisabled()\"\n         [matRippleCentered]=\"true\">\n      <div class=\"mat-ripple-element mat-radio-persistent-ripple\"></div>\n    </div>\n  </div>\n  <label class=\"mdc-label\" [for]=\"inputId\">\n    <ng-content></ng-content>\n  </label>\n</div>\n"],"names":["AsFormControlPipe","_logger","constructor","transform","value","_valueHash","isBlank","FormControl","this","warn","LOGGER","pure","CastPipesModule","coerceBooleanProperty","UniqueSelectionDispatcher","_listeners","notify","id","name","listener","listen","push","filter","registered","ngOnDestroy","factory","ɵfac","providedIn","mixinDisableRipple","base","disableRipple","_disableRipple","args","super","mixinTabIndex","defaultTabIndex","tabIndex","disabled","_tabIndex","coerceNumberProperty","MatRadioModule","MatCommonModule","CommonModule","MatRippleModule","_c0","_c1","nextUniqueId","MatRadioChange","source","MAT_RADIO_GROUP_CONTROL_VALUE_ACCESSOR","provide","NG_VALUE_ACCESSOR","useExisting","forwardRef","MatRadioGroup","multi","MAT_RADIO_GROUP","InjectionToken","MAT_RADIO_DEFAULT_OPTIONS","color","_name","_updateRadioButtonNames","labelPosition","_labelPosition","v","_markRadiosForCheck","_value","newValue","_updateSelectedRadioFromValue","_checkSelectedRadioButton","_selected","checked","selected","_disabled","required","_required","_changeDetector","_isInitialized","_controlValueAccessorChangeFn","onTouched","change","EventEmitter","ngAfterContentInit","_buttonChanges","_radios","changes","subscribe","find","radio","unsubscribe","_touch","forEach","_markForCheck","isAlreadySelected","_emitChangeEvent","emit","writeValue","markForCheck","registerOnChange","fn","registerOnTouched","setDisabledState","isDisabled","i0","selectors","contentQueries","rf","ctx","dirIndex","MatRadioButton","_t","inputs","outputs","exportAs","features","_MatRadioButtonMixinBase","_elementRef","_checked","newCheckedState","radioGroup","_radioDispatcher","_setDisabled","_color","_providerOverride","inputId","_uniqueId","elementRef","_focusMonitor","animationMode","_removeUniqueSelectionListener","_noopAnimations","focus","options","origin","focusVia","_inputElement","nativeElement","ngOnInit","ngDoCheck","_updateTabIndex","ngAfterViewInit","monitor","focusOrigin","stopMonitoring","_isRippleDisabled","_onInputClick","event","stopPropagation","_onInputInteraction","groupValueChanged","_onTouchTargetClick","group","_previousTabIndex","input","setAttribute","i1","i2","ANIMATION_MODULE_TYPE","viewQuery","_r0","ariaLabel","ariaLabelledby","ariaDescribedby","dependencies","i3","styles","encapsulation","changeDetection"],"sourceRoot":""}